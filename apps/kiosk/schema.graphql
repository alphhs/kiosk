# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

"Requires that exactly one field must be supplied and that field must not be `null`."
directive @oneOf on INPUT_OBJECT

interface ActionInterface {
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    promotion: Promotion!
    promotionId: ID!
    type: String
}

interface BaseModelInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    updatedAt: ISO8601DateTime!
}

interface CalculatorInterface {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    type: String
    updatedAt: ISO8601DateTime!
}

interface GamificationGoal {
    accumulateBy: GamificationGoalAccumulateBy!
    createdAt: ISO8601DateTime!
    currentCycle: String!
    gamificationId: ID!
    gid: ID!
    id: ID!
    name: String!
    nextCycle: String!
    preferences: JSON
    prevCycle: String!
    prevCycles(size: Int!): [String!]!
    repeat: GamificationGoalRepeat!
    type: String!
    updatedAt: ISO8601DateTime!
}

interface KycInterface {
    createdAt: ISO8601DateTime!
    expireAt: ISO8601Date
    id: ID!
    status: KycStatus
    type: String
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
    vendor: Vendor
    vendorId: ID
    websiteId: ID
}

interface Node {
    gid: ID!
    id: ID!
}

interface PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    updatedAt: ISO8601DateTime!
}

interface ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    productCat: String
    sku: String
    slug: String!
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

interface RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

"Type of addressable object"
union Addressable = District | Quarter | State

"Objects which maybe chatroom created"
union Around = Order | Product | Website

"Objects which may be commented on"
union Asset = Branch | BusinessClient | ClientsStore | Merchant | StoreLocation | User | Vendor | Website

union Commentable = FeedbackType

union EventEntree = Order | User

union EventWinning = Promotion | StoreCredit

"Possible target types of Featured"
union FeaturedTarget = Brand | Listing | Merchant

union FollowTarget = Brand | Vendor

union IntegrationReportSource = Order | Vendor | Website

union LotteryEntree = Order | User

union LotteryWinning = Promotion | StoreCredit | eventTry

"Objects which may be related to notification"
union NotificationObject = BusinessClient | ClientsStore | Comment | Employee | FeedbackType | Listing | Merchant | OneSignalNotification | Order | OrderComment | Prescription | Product | Transaction | Vendor | Wallet | Website

"Objects which may be send notification"
union NotificationSender = User | Vendor | Website

"Objects which may be noted on"
union OrderNotable = Order | Promotion | Warranty

union PrizeSource = Promotion

union PromotionApply = Brand | Product | Variant

union Relatable = Product | Vendor

union RelatableTo = Product | Vendor

"Objects which maybe targeted on report"
union ReportTarget = User | Vendor

union ReviewSourceType = Order

union Reviewable = Article | Brand | Comment | Listing | Product | User | Vendor

"Objects which maybe source of the transaction"
union Source = Bank | BankTransaction | Employee | GiftCard | InvitationAccept | Order | Payment | PaymentMethod | Transaction | User | Website

union StoreCreditOriginator = CorporateGateway | GiftCard | Order | User

union Target = Order

union TrackingTarget = LineItem | Order

type AccountsReceivablePaymentSource implements BaseModelInterface & Node & PaymentSourceInterface {
    businessClient: BusinessClient
    canI(action: CanIAction!): Boolean!
    clientsStore: ClientsStore
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    paymentMethod: PaymentMethod
    supplierStockLocation: StockLocation
    updatedAt: ISO8601DateTime!
    user: User
}

"Represents order and user address object"
type Address implements BaseModelInterface & Node {
    "General address for example street"
    address1: String
    address2: String
    alias: String
    alternativePhone: String
    apartment: String
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    birthday: ISO8601Date
    branches: [Branch!]!
    canI(action: CanIAction!): Boolean!
    cdq: [ID!]
    city: String
    company: String
    consumerNo: String
    coordinate: JSON
    country: Country
    countryId: ID
    countryName: String
    createdAt: ISO8601DateTime!
    district: District
    districtId: ID
    districtName: String
    entrance: String
    firstname: String
    floor: String
    gender: String
    geoPoint: String
    gid: ID!
    house: String
    houseKorpus: String
    id: ID!
    intercom: String
    isBillAddress: Boolean
    isCompany: Boolean
    isPup: Boolean
    lastname: String
    latitude: String
    longitude: String
    mnQuarterId: ID
    nationality: String
    note: String
    owningType: String
    passportNumber: String
    phone: String
    pinFl: String
    preferences: JSON
    quarter: District
    quarterName: String
    state: State
    stateId: ID
    stateName: String
    tin: String
    updatedAt: ISO8601DateTime!
    what3words: String
    year: String
    zipcode: String
}

"The connection type for Address."
type AddressConnection {
    "A list of edges."
    edges: [AddressEdge!]!
    "A list of nodes."
    nodes: [Address!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type AddressEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Address!
}

type Adjustment implements BaseModelInterface & Node {
    adjustableId: ID
    adjustableLabel: String
    adjustableType: String
    amount: Float!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    eligible: Boolean
    gid: ID!
    id: ID!
    included: Boolean
    label: String!
    mandatory: Boolean
    order: Order!
    source: Node
    sourceId: ID
    sourceType: String
    state: String
    taxAmount: Float!
    updatedAt: ISO8601DateTime!
}

type Agenda implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: String
    date: ISO8601Date
    gid: ID!
    id: ID!
    location: String
    preview: String
    tagList: [String!]!
    tags: [Tag!]!
    time: String
    title: String
    updatedAt: ISO8601DateTime!
    websiteId: ID
}

"The connection type for Agenda."
type AgendaConnection {
    "A list of edges."
    edges: [AgendaEdge!]!
    "A list of nodes."
    nodes: [Agenda!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type AgendaEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Agenda!
}

type AlibabaOrder implements BaseModelInterface & Node {
    addressComparePrice: Float
    addressMainPrice: Float
    alibabaId: Float
    amount: Float
    amountUsd: Float
    canI(action: CanIAction!): Boolean!
    canceledTotal: Float
    cargoPaid: Boolean
    cargoPrice: Float
    cargoStatus: String
    cargoWeight: Float
    cny: Float
    createdAt: ISO8601DateTime!
    data: JSON
    discount: Float
    displayShipmentBeforePaid: Float
    displayShipmentTotal: Float
    displayShipmentTotalUsd: Float
    gid: ID!
    id: ID!
    lastSyncedAt: String
    lineItems: [LineItem!]
    logisticTrace: JSON
    mongoliaInboundAt: String
    noStockTotal: Float
    note: String
    number: String
    oldWaybill: String
    oldWaybills: JSON
    order: Order
    orderTotalLocalShipping: Float
    paidAt: ISO8601DateTime
    priceUpdatedAt: String
    provider: DropshipProvider
    refund: Float
    refundPayment: Float
    returnTotal: Float
    sellerName: String
    sellerOpenid: String
    shipmentTotal: Float
    shipping: Float
    shippingCalculator: String
    status: String
    tax: Float
    total: Float
    totalItemAmount: Float
    totalItemCount: Int
    totalUsd: Float
    updatedAt: ISO8601DateTime!
    updatedPrice: String
    updatedShipping: String
    uzbekistanInboundAt: String
    warehouse2InboundAt: String
    warehouse2OutboundAt: String
    warehouseInboundAt: String
    warehouseOutboundAt: String
    waybill: String
    waybillStatus: String
    waybills: [AlibabaWaybill!]
    website: Website
    websiteId: ID
}

type AlibabaWaybill implements BaseModelInterface & Node {
    bag: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    entry: String
    gid: ID!
    goods: JSON
    id: ID!
    lid: String
    order: AlibabaOrder
    pickPackStatus: String
    price: Float
    provider: DropshipProvider
    status: String
    step: Int
    updatedAt: ISO8601DateTime!
    waybill: String
    website: Website
    weight: Float
}

type AlifPayInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceId: String
    invoiceNumber: String
    signature: String
    splitMonths: Int
    updatedAt: ISO8601DateTime!
}

type Application implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    confidential: Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String!
    onesignalAppId: String
    onesignalAppKey: String
    redirectUri: String!
    scopes: String!
    secret: String!
    uid: String!
    updatedAt: ISO8601DateTime!
    website: Website
}

type ApprovalComment implements Node {
    comments: [KeyValue!]!
    gid: ID!
    id: ID!
}

type Article implements BaseModelInterface & Node {
    author: Author
    averageRating: Float!
    blocks: JSON
    canI(action: CanIAction!): Boolean!
    canonicalLink: String
    "Returns list of comments"
    comments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CommentConnection!
    contentType: String
    createdAt: ISO8601DateTime!
    editor: User
    gid: ID!
    id: ID!
    image: ArticleImage
    images: [ArticleImage!]!
    impressionsCount: Int
    isDraft: Boolean
    isFeatured: Boolean
    isPublished: Boolean
    items: JSON
    licensing: String
    myReview: Review
    preview: String
    publishedAt: ISO8601DateTime
    publishedBlocks: JSON
    reviews(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ReviewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        isDeleted: Boolean,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ReviewConnection!
    seoDescription: String
    seoKeywords: String
    seoTitle: String
    slug: String
    tagList: [String!]!
    tags: [Tag!]!
    text: String
    title: String
    totalComments: Int
    totalReviews: Int!
    updatedAt: ISO8601DateTime!
    website: Website
    wordCount: Int
}

"The connection type for Article."
type ArticleConnection {
    "A list of edges."
    edges: [ArticleEdge!]!
    "A list of nodes."
    nodes: [Article!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ArticleEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Article!
}

type ArticleImage implements BaseModelInterface & Node {
    alt: String
    article: Article
    attachment: String
    attachmentContentType: String!
    attachmentFileName: String!
    attachmentFileSize: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    imageHeight: Int
    imageWidth: Int
    updatedAt: ISO8601DateTime!
    user: User
    website: Website
}

type AssemblyPart implements BaseModelInterface & Node {
    assemblyId: ID
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    part: Variant
    partId: ID
    quantity: Int
    updatedAt: ISO8601DateTime!
}

type AssetRole implements BaseModelInterface & Node {
    asset: Asset
    assetId: ID
    assetKind: String
    assetName: String
    business: Vendor
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    people: Employee
    roles: [String!]!
    updatedAt: ISO8601DateTime!
    user: User
}

"The connection type for AssetRole."
type AssetRoleConnection {
    "A list of edges."
    edges: [AssetRoleEdge!]!
    "A list of nodes."
    nodes: [AssetRole!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type AssetRoleEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AssetRole!
}

type Attachment implements BaseModelInterface & Node {
    attachment: String
    canI(action: CanIAction!): Boolean!
    contract: Contract
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    updatedAt: ISO8601DateTime!
}

type Audit implements Node {
    action: String
    associated: Node
    associatedId: ID
    associatedJson: JSON
    associatedSku: String
    associatedType: String
    auditable: Node
    auditableId: ID
    auditableType: String
    auditedChanges: JSON
    comment: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    remoteAddress: String
    requestUuid: String
    user: User
    userEmail: String
    userId: ID
    userType: String
    username: String
    version: Int
}

"The connection type for Audit."
type AuditConnection {
    "A list of edges."
    edges: [AuditEdge!]!
    "A list of nodes."
    nodes: [Audit!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type AuditEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Audit!
}

type Author implements BaseModelInterface & Node {
    "Returns list of menus"
    articles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ArticleFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ArticleConnection!
    articlesCount: Int
    avatar(
        "Use CDN Mirror ? defaults to TRUE"
        mirror: Boolean = true,
        "Alias"
        size: String
    ): String
    avatarContentType: String
    avatarFileName: String
    bio: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    followersCount: Int
    fullName: String
    gid: ID!
    id: ID!
    isFeatured: Boolean
    isPublic: Boolean
    shoppyAuthors: Int
    social: JSON
    updatedAt: ISO8601DateTime!
    user: User
    username: String
    website: Website
}

"The connection type for Author."
type AuthorConnection {
    "A list of edges."
    edges: [AuthorEdge!]!
    "A list of nodes."
    nodes: [Author!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type AuthorEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Author!
}

type Availability implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type Badge implements BaseModelInterface & Node {
    active: Boolean
    attachment: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    expireAt: ISO8601DateTime
    gid: ID!
    id: ID!
    "Тухайн харилцагчийн авч болох бүх Listing жагсаалтын буцаана"
    listings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    name: String
    priority: Int
    promotable: Boolean!
    startAt: ISO8601DateTime
    style: String
    updatedAt: ISO8601DateTime!
    url: String
    website: Website!
    websiteId: ID!
}

"The connection type for Badge."
type BadgeConnection {
    "A list of edges."
    edges: [BadgeEdge!]!
    "A list of nodes."
    nodes: [Badge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type BadgeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Badge!
}

type Bank implements BaseModelInterface & Node {
    accountNo: String!
    active: Boolean
    additionalDetails: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String!
    updatedAt: ISO8601DateTime!
}

type BankAccount implements Node {
    "Account name"
    accountName: String!
    "Account number"
    accountNumber: String!
    "Bank name"
    bankName: String!
    gid: ID!
    id: ID!
    "Status"
    status: String
}

type BankTransaction {
    account: String
    amount: Float
    createdAt: ISO8601DateTime
    customerAccount: String
    customerBank: String
    customerName: String
    description: String
    id: ID
    order: Order
    payment: Payment
    ref: String
    transactionDate: ISO8601DateTime
    updatedAt: ISO8601DateTime
    website: Website
}

type BinancePayInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    checkoutUrl: String
    createdAt: ISO8601DateTime!
    expireAt: ISO8601DateTime
    gid: ID!
    id: ID!
    invoiceNumber: String
    prepayId: String
    qrContent: String
    qrImage: String
    universalUrl: String
    updatedAt: ISO8601DateTime!
}

type Booking implements BaseModelInterface & Node {
    bookingVariants: [BookingVariant!]!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    prices: JSON!
    product: Product!
    productId: ID!
    repeats: [String!]
    skips: [JSON!]!
    stockAvailable(date: ISO8601DateTime!, storeLocationId: ID!): [JSON!]!
    stocks(date: ISO8601DateTime!): [JSON!]!
    updatedAt: ISO8601DateTime!
    variation: JSON!
}

type BookingVariant implements BaseModelInterface & Node {
    basePrice: Float!
    booking: Booking!
    bookingId: ID!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    price: Float!
    product: Product!
    productId: ID!
    stock: Int!
    stockLocation: StockLocation
    stockLocationId: ID
    storeLocation: StoreLocation
    storeLocationId: ID
    updatedAt: ISO8601DateTime!
    variant: Variant!
    variantId: ID!
}

type Branch implements BaseModelInterface & Node {
    address: Address
    "Returns list of assets"
    assetRoles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AssetFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AssetRoleConnection!
    businessType: BusinessType
    canI(action: CanIAction!): Boolean!
    clientId(id: ID!): ID
    code: String
    createdAt: ISO8601DateTime!
    createdBy: User
    email: String
    gid: ID!
    id: ID!
    name: String
    phone: String
    phone1: String
    supplySegmentIds: JSON
    updatedAt: ISO8601DateTime!
    vendor: Vendor!
}

"The connection type for Branch."
type BranchConnection {
    "A list of edges."
    edges: [BranchEdge!]!
    "A list of nodes."
    nodes: [Branch!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type BranchEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Branch!
}

type Brand implements BaseModelInterface & Node {
    averageRating: Float!
    blackLogo: Image
    canI(action: CanIAction!): Boolean!
    categoryType: String
    code: String!
    cover: String
    coverSquare: String
    createdAt: ISO8601DateTime!
    createdBy: User
    default: Boolean!
    defaultCurrency: String
    deliveryDuration: String
    deliveryHours: Int
    desktopCover: Image
    facebook: String
    fees: String
    follow(websiteId: ID): Follow!
    follows: [Follow!]!
    gid: ID!
    id: ID!
    isPopUp: Boolean
    isPublished: Boolean
    items: String
    logo: String
    lvl3: String
    lvl4: String
    mailFromAddress: String
    manufacture: String
    metaDescription: String
    metaKeywords: String
    mobileCover: String
    monthlyFee: Float
    myReview: Review
    name: String
    officialLogo: String
    popOffDate: ISO8601DateTime
    popUpDate: ISO8601DateTime
    reviews(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ReviewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        isDeleted: Boolean,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ReviewConnection!
    seoTitle: String
    shoppyFeatured(websiteId: ID): Featured
    shoppyFeatureds(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FeaturedConnection!
    storeLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreLocationConnection!
    storeType: String
    totalReviews: Int!
    updatedAt: ISO8601DateTime!
    url: String
    webData: JSON
    websiteIds: [ID!]!
    websiteNames: String
    "Returns list of brands"
    websites(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BrandListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BrandListingConnection!
    whiteLogo: Image
}

"The connection type for Brand."
type BrandConnection {
    "A list of edges."
    edges: [BrandEdge!]!
    "A list of nodes."
    nodes: [Brand!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type BrandEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Brand!
}

type BrandListing implements BaseModelInterface & Node {
    active: Boolean
    canI(action: CanIAction!): Boolean!
    code: String
    cover: String
    createdAt: ISO8601DateTime!
    data: JSON
    description: String
    desktopCover: Image
    gid: ID!
    id: ID!
    listings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    mobileCover: String
    name: String
    store: Brand!
    storeId: ID
    updatedAt: ISO8601DateTime!
    website: Website!
    websiteId: ID
}

"The connection type for BrandListing."
type BrandListingConnection {
    "A list of edges."
    edges: [BrandListingEdge!]!
    "A list of nodes."
    nodes: [BrandListing!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type BrandListingEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: BrandListing!
}

type BusinessClient implements BaseModelInterface & Node {
    address: String
    alias: String
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    background: String
    canI(action: CanIAction!): Boolean!
    category: SupplierCategory
    categoryId: ID
    client: Vendor!
    clientCodes: [BusinessClientCode!]!
    clientId: ID!
    "Returns a client store"
    clientsStore(id: ID!): ClientsStore
    "Returns list of client stores"
    clientsStores(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ClientsStoreFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ClientsStoreConnection!
    createdAt: ISO8601DateTime!
    creditBalance: Float
    creditLimit: Float
    creditStatus: Float
    creditWallet: Wallet
    creditWallets: [Wallet!]
    currentOrderTotal: Float!
    customerCreditData(clientStoreId: ID, supplierStockLocationId: ID): JSON
    customerDetailCreditData(clientStoreId: ID, supplierStockLocationId: ID): JSON
    data: JSON
    debitWallet: Wallet
    debitWallets: [Wallet!]
    description: String
    email: String
    "Returns list of employees"
    employees(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessUserFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): EmployeeConnection
    facebook: String
    "Returns list of gamifications"
    gamifications(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: GamificationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): GamificationConnection!
    gid: ID!
    id: ID!
    isIndividual: Boolean
    lastApprovalComment: ApprovalComment
    lastAudit: Audit
    localId: String
    logo: String
    manager: Employee
    maxEmployees: Int!
    msCode: String
    name: String
    orderTotal: Float!
    "Returns list of orders"
    orders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        status: OrderStatus
    ): OrderConnection!
    organizationCertificateAttachments: [BusinessVerificationAttachmentType!]
    organizationId: String
    pendingApproval: Boolean!
    personPassportAttachments: [BusinessVerificationAttachmentType!]
    phone: String
    profile: Profile
    "Returns list of gamifications"
    progresses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: GamificationProgressFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ProgressConnection!
    "Returns list of promotions"
    promotions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        dateType: String,
        filter: PromotionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        from: String,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        to: String
    ): PromotionConnection!
    salesManagers: [Employee!]
    specialPermissionCertificateAttachments: [BusinessVerificationAttachmentType!]
    status: String!
    storeLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreLocationConnection!
    supplySegmentIds: [ID!]!
    supplySegments: [SupplySegment!]!
    updatedAt: ISO8601DateTime!
    vendor: Vendor!
    web: String
    website: Website!
}

type BusinessClientCode implements BaseModelInterface & Node {
    branch: Branch!
    branchId: ID!
    canI(action: CanIAction!): Boolean!
    code: String!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    updatedAt: ISO8601DateTime!
    vendor: Vendor!
    vendorId: ID!
}

"The connection type for BusinessClient."
type BusinessClientConnection {
    "A list of edges."
    edges: [BusinessClientEdge!]!
    "A list of nodes."
    nodes: [BusinessClient!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type BusinessClientEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: BusinessClient!
}

type BusinessType implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    code: String
    createdAt: ISO8601DateTime!
    createdBy: User
    gid: ID!
    id: ID!
    name: String
    updatedAt: ISO8601DateTime!
}

"The connection type for BusinessType."
type BusinessTypeConnection {
    "A list of edges."
    edges: [BusinessTypeEdge!]!
    "A list of nodes."
    nodes: [BusinessType!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type BusinessTypeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: BusinessType!
}

type BusinessUserGroupType implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String
    updatedAt: ISO8601DateTime!
    vendor: Vendor
}

"The connection type for BusinessUserGroupType."
type BusinessUserGroupTypeConnection {
    "A list of edges."
    edges: [BusinessUserGroupTypeEdge!]!
    "A list of nodes."
    nodes: [BusinessUserGroupType!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type BusinessUserGroupTypeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: BusinessUserGroupType!
}

type BusinessUserProfile implements Node {
    businessUserVerifications: [BusinessVerificationType!]!
    gid: ID!
    id: ID!
    lastApprovalComment: ApprovalComment
    status: B2bApprovalDecisionStatusEnum!
}

type BusinessUsersSegment implements BaseModelInterface & Node {
    businessUser: Employee!
    businessUserId: ID!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    expiresAt: ISO8601Date!
    gid: ID!
    id: ID!
    segment: SupplySegment!
    segmentId: ID!
    sourceId: ID
    sourceType: String
    status: String!
    updatedAt: ISO8601DateTime!
}

"The connection type for BusinessUsersSegment."
type BusinessUsersSegmentConnection {
    "A list of edges."
    edges: [BusinessUsersSegmentEdge!]!
    "A list of nodes."
    nodes: [BusinessUsersSegment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type BusinessUsersSegmentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: BusinessUsersSegment!
}

type BusinessVerificationAttachmentType implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    key: String!
    large: String
    medium: String
    original: String
    originalFileSize: Int
    small: String
    updatedAt: ISO8601DateTime!
}

type BusinessVerificationType implements BaseModelInterface & Node {
    attachments: [BusinessVerificationAttachmentType!]
    canI(action: CanIAction!): Boolean!
    category: String
    createdAt: ISO8601DateTime!
    createdBy: User
    gid: ID!
    id: ID!
    preferredExpireAt: ISO8601Date
    updatedAt: ISO8601DateTime!
}

type Campaign implements BaseModelInterface & Node {
    campaignContacts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CampaignContactConnection!
    canI(action: CanIAction!): Boolean!
    contacts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ContactConnection!
    createdAt: ISO8601DateTime!
    deliveredAt: ISO8601DateTime
    "Returns list of EMail campaign events"
    events(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: EMailEventFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): EventConnection!
    eventsCount: JSON
    fromEmail: String
    fromName: String
    gid: ID!
    id: ID!
    lastEvents: JSON
    name: String
    preview: String
    recipientsCount: Int
    segment: Segment
    slug: String
    state: String
    subject: String
    template: Template
    totals: JSON
    updatedAt: ISO8601DateTime!
    website: Website
}

type CampaignContact implements BaseModelInterface & Node {
    campaign: Campaign
    canI(action: CanIAction!): Boolean!
    contact: Contact
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    sentAt: ISO8601DateTime
    status: String
    updatedAt: ISO8601DateTime!
}

"The connection type for CampaignContact."
type CampaignContactConnection {
    "A list of edges."
    edges: [CampaignContactEdge!]!
    "A list of nodes."
    nodes: [CampaignContact!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type CampaignContactEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: CampaignContact!
}

type CampaignListing implements BaseModelInterface & Node {
    campaign: ShoppyCampaign!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    ordersCount: Int!
    position: Int
    price: Float!
    updatedAt: ISO8601DateTime!
    variant: Variant!
}

"The connection type for CampaignListing."
type CampaignListingConnection {
    "A list of edges."
    edges: [CampaignListingEdge!]!
    "A list of nodes."
    nodes: [CampaignListing!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type CampaignListingEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: CampaignListing!
}

type CancelReason implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    description: String
    display: String
    gid: ID!
    id: ID!
    position: Int
    title: String
    updatedAt: ISO8601DateTime!
    websiteId: Int
}

"The connection type for CancelReason."
type CancelReasonConnection {
    "A list of edges."
    edges: [CancelReasonEdge!]!
    "A list of nodes."
    nodes: [CancelReason!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type CancelReasonEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: CancelReason!
}

type CandyInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    candyMiniApp: Int
    candyUser: Int
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    qrLink: String
    receiver: String
    updatedAt: ISO8601DateTime!
}

type Card implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    cardHolder: String
    cardIssuer: String
    cardNumber: String!
    createdAt: ISO8601DateTime!
    expiresAt: String!
    gid: ID!
    id: ID!
    status: String!
    tokenDate: ISO8601Date
    type: String!
    updatedAt: ISO8601DateTime!
    user: User!
    userId: ID!
    website: Website!
    websiteId: ID!
}

type ChatAttachment implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    large: String
    medium: String
    original: String
    small: String
    updatedAt: ISO8601DateTime!
}

type Cinema implements BaseModelInterface & Node {
    address: String
    branch: String
    canI(action: CanIAction!): Boolean!
    city: String
    createdAt: ISO8601DateTime!
    email: String
    gid: ID!
    id: ID!
    idx: String
    image: String
    lat: String
    latLon: [String!]
    lon: String
    movies: [Movie!]
    name: String
    phone: String
    preferences: JSON
    screens: [Screen!]
    sessions: [Session!]
    updatedAt: ISO8601DateTime!
}

type ClaimedOnly implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type ClientsStore implements BaseModelInterface & Node {
    assetRoles: [AssetRole!]!
    businessClient: BusinessClient
    businessVerifications: [BusinessVerificationType!]!
    canI(action: CanIAction!): Boolean!
    category: SupplierCategory
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    lastApprovalComment: ApprovalComment
    lastRelationalAudit: Audit
    "Returns list of orders"
    orders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        status: OrderStatus
    ): OrderConnection!
    relationalAudits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    status: String!
    storeLocation: StoreLocation
    "Returns list of ETickets"
    supplierStockLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StockLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StockLocationConnection!
    updatedAt: ISO8601DateTime!
}

"The connection type for ClientsStore."
type ClientsStoreConnection {
    "A list of edges."
    edges: [ClientsStoreEdge!]!
    "A list of nodes."
    nodes: [ClientsStore!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ClientsStoreEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ClientsStore!
}

type Collect implements BaseModelInterface & Node {
    acceptedAt: ISO8601DateTime
    canI(action: CanIAction!): Boolean!
    collectedAt: ISO8601DateTime
    createdAt: ISO8601DateTime!
    driver: User
    driverCode: String
    driverTakenAt: ISO8601DateTime
    gid: ID!
    id: ID!
    order: Order!
    status: String
    storeLocation: StoreLocation
    updatedAt: ISO8601DateTime!
    user: User!
    website: Website!
}

type Comment implements BaseModelInterface & Node {
    averageRating: Float!
    canI(action: CanIAction!): Boolean!
    comment: String
    commentable: Commentable
    createdAt: ISO8601DateTime!
    data: JSON
    gid: ID!
    id: ID!
    ip: String
    isMe: Boolean!
    mentions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserConnection!
    myReview: Review
    reviews(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ReviewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        isDeleted: Boolean,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ReviewConnection!
    title: String
    totalReviews: Int!
    updatedAt: ISO8601DateTime!
    user: User
    userAgent: String
    variants: [Variant!]!
}

"The connection type for Comment."
type CommentConnection {
    "A list of edges."
    edges: [CommentEdge!]!
    "A list of nodes."
    nodes: [Comment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type CommentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Comment!
}

"Represents Commerce Address object"
type CommerceAddress implements BaseModelInterface & Node {
    address1: String
    address2: String
    alternativePhone: String
    birthday: ISO8601Date
    canI(action: CanIAction!): Boolean!
    city: String
    company: String
    countryId: ID
    createdAt: ISO8601DateTime!
    districtId: ID
    firstname: String
    gender: String
    geoPoint: String
    gid: ID!
    id: ID!
    isCompany: Boolean
    lastname: String
    mnQuarterId: ID
    phone: String
    quarterId: ID
    stateId: ID
    stateName: String
    updatedAt: ISO8601DateTime!
    what3words: String
    zipId: ID
    zipcode: String
}

"Represents Commerce Order object"
type CommerceOrder implements BaseModelInterface & Node {
    address: CommerceAddress
    adjustmentTotal: Float!
    billAddress: Address
    canI(action: CanIAction!): Boolean!
    canceledAt: ISO8601DateTime
    canceler: User
    comments: [OrderComment!]!
    completedAt: ISO8601DateTime
    confirmationDelivered: Boolean
    createdAt: ISO8601DateTime!
    currency: String
    driver: User
    driverTakenAt: ISO8601DateTime
    ebarimt: Boolean
    email: String
    extraData: JSON
    flag: String
    flaggedAt: ISO8601DateTime
    flaggedBy: User
    gid: ID!
    id: ID!
    images: [ProductImage!]!
    itemCount: Int
    itemTotal: Float!
    khanId: String
    latestNote: String
    leaseLeft: Float
    leaseState: String
    lineItems: [LineItem!]!
    number: String
    paidAt: ISO8601DateTime
    parcels: [Parcel!]!
    paymentState: String
    paymentTotal: Float
    paymentTypes: [String!]!
    payments: [Payment!]!
    pickPackAt: ISO8601DateTime
    pickPackBy: User
    pickPackCompletedAt: ISO8601DateTime
    pickPackNumber: Int
    pickPackOtp: String
    pickPackStatus: String
    pickPackTrackingNumber: String
    shipAddress: Address
    shipmentState: String
    shipmentTotal: Float!
    shipments: [Shipment!]!
    shippedAt: ISO8601DateTime
    shippingMethod: ShippingMethod
    specialInstructions: String
    state: String
    storeLocation: StoreLocation
    stores: [Brand!]!
    total: Float!
    totalAppliedStoreCredit: Float!
    updatedAt: ISO8601DateTime!
    user: User
    waitUntil: ISO8601DateTime
    website: Website
    whenToShip: ISO8601DateTime
}

"The connection type for CommerceOrder."
type CommerceOrderConnection {
    "A list of edges."
    edges: [CommerceOrderEdge!]!
    "A list of nodes."
    nodes: [CommerceOrder!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type CommerceOrderEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: CommerceOrder!
}

type Contact implements BaseModelInterface & Node {
    campaignContacts: [CampaignContact!]!
    campaigns: [Campaign!]!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    email: String
    events: [Event!]!
    firstName: String
    gid: ID!
    id: ID!
    lastName: String
    source: String
    state: String
    tagList: [String!]!
    updatedAt: ISO8601DateTime!
    user: User
    website: Website
}

"The connection type for Contact."
type ContactConnection {
    "A list of edges."
    edges: [ContactEdge!]!
    "A list of nodes."
    nodes: [Contact!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ContactEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Contact!
}

type Contract implements BaseModelInterface & Node {
    attachments: [Attachment!]!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String
    updatedAt: ISO8601DateTime!
    user: User
}

type CorporateGateway implements BaseModelInterface & Node {
    accounts: [String!]!
    active: Boolean
    bank: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    ibanAccounts: [String!]!
    id: ID!
    name: String
    preferences: JSON
    statements(account: String!, fetch: Boolean, from: String, record: String, size: String, to: String): [BankTransaction!]!
    transferAccount: String
    transferPassword: String
    transferUsername: String
    type: String
    updatedAt: ISO8601DateTime!
    website: Website
}

type Country implements Node {
    gid: ID!
    id: ID!
    iso: String
    iso3: String
    isoName: String
    name: String
    numcode: Int
    states: [State!]!
    statesRequired: Boolean
    updatedAt: ISO8601DateTime
    zipcodeRequired: Boolean
}

"The connection type for Country."
type CountryConnection {
    "A list of edges."
    edges: [CountryEdge!]!
    "A list of nodes."
    nodes: [Country!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type CountryEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Country!
}

type Coupon implements BaseModelInterface & Node {
    amount: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: String
    deactivatedAt: ISO8601DateTime
    gid: ID!
    giftMessage: String
    id: ID!
    inventoryUnitId: ID
    lineItem: LineItem!
    number: String!
    order: Order!
    part: Variant
    product: Product!
    receiverEmail: String
    receiverName: String
    receiverPhone: String
    scannedBy: User
    sender: String
    sentAt: ISO8601DateTime
    state: String
    status: String
    updatedAt: ISO8601DateTime!
    usedAt: ISO8601DateTime
    user: User
    variant: Variant!
    vendor: Vendor
    website: Website
}

type CouponCodeUsagePerUser implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredCouponCodeUsagePerUserLimit: Int!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

"The connection type for Coupon."
type CouponConnection {
    "A list of edges."
    edges: [CouponEdge!]!
    "A list of nodes."
    nodes: [Coupon!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type CouponEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Coupon!
}

type CouponManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    coupons: [Coupon!]!
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    productCat: String
    sku: String
    slug: String!
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

type CreateAdjustment implements ActionInterface & Node {
    calculator: CalculatorInterface!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    promotion: Promotion!
    promotionActionLineItems: [PromotionActionLineItem!]!
    promotionId: ID!
    type: String
}

type CreateItemAdjustments implements ActionInterface & Node {
    calculator: CalculatorInterface!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    preferredActionWithQtyLimit: Int!
    preferredExcludeOnSale: Boolean!
    preferredLimit: Int
    preferredMatchPolicy: String!
    preferredOnlyOnCheapest: Boolean!
    promotion: Promotion!
    promotionActionLineItems: [PromotionActionLineItem!]!
    promotionId: ID!
    type: String
}

type CreateLineItems implements ActionInterface & Node {
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    preferredInterval: Int
    preferredMatchPolicy: String!
    preferredRule: String!
    promotion: Promotion!
    promotionActionLineItems: [PromotionActionLineItem!]!
    promotionId: ID!
    type: String
}

type CreateOnePlusOneItems implements ActionInterface & Node {
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    preferredMatchPolicy: String!
    preferredMaxAmount: Float!
    preferredMaxQuantity: BigInt!
    preferredMinAmount: Float!
    preferredMinQuantity: Int!
    promotion: Promotion!
    promotionActionLineItems: [PromotionActionLineItem!]!
    promotionId: ID!
    type: String
}

type CreatePropertyAdjustments implements ActionInterface & Node {
    calculator: CalculatorInterface!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    preferredExcludeOnSale: Boolean!
    preferredLimit: Int
    preferredMatchPolicy: String!
    preferredOnlyOnCheapest: Boolean!
    preferredPropertiesValues: JSON!
    promotion: Promotion!
    promotionActionLineItems: [PromotionActionLineItem!]!
    promotionId: ID!
    type: String
}

type CreditCard implements BaseModelInterface & Node & PaymentSourceInterface {
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    canI(action: CanIAction!): Boolean!
    cardType: String
    ccType: String
    createdAt: ISO8601DateTime!
    creditLimit: Float
    currentBalance: Float
    default: Boolean!
    gid: ID!
    id: ID!
    lastDigits: String
    minPayment: Float
    month: String
    name: String
    number: String
    openBalance: Float
    registerNum: String
    "Банкнаас ирэх картын хуулга"
    statements(
        "ирээдүйн сар байж болохгүй"
        monthEnd: String,
        "2022.04"
        monthStart: String!
    ): JSON
    status: String
    token: String
    updatedAt: ISO8601DateTime!
    user: User
    website: Website
    year: String
}

"The connection type for CreditCard."
type CreditCardConnection {
    "A list of edges."
    edges: [CreditCardEdge!]!
    "A list of nodes."
    nodes: [CreditCard!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type CreditCardEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: CreditCard!
}

type CreditProfile implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    status: String
    updatedAt: ISO8601DateTime!
    wallet: Wallet
}

type CreditWellbeeSource implements BaseModelInterface & Node & PaymentSourceInterface {
    businessClient: BusinessClient
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    paymentMethod: PaymentMethod
    updatedAt: ISO8601DateTime!
    user: User
}

type DeliveryPackage implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    courier: String!
    courierOrdNumber: String
    createdAt: ISO8601DateTime!
    data: String
    deliveryLogs: JSON
    gid: ID!
    id: ID!
    itemCount: Int
    items: [DeliveryPackageItem!]!
    label: JSON
    labelPdfUrl: String
    lineItems: [LineItem!]!
    merchant: Merchant!
    number: String!
    order: Order!
    parcelNumbers: [String!]!
    pinCode: String
    sender: User
    senderId: ID
    sendingQueuedAt: ISO8601DateTime
    sendingStatus: String!
    status: String!
    trackingStatus: String
    trackingUpdatedAt: ISO8601DateTime
    travel: String
    tutPup: Boolean!
    updatedAt: ISO8601DateTime!
    weight: Float
}

type DeliveryPackageItem implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    inventoryUnit: InventoryUnit!
    inventoryUnitId: ID!
    lineItem: LineItem!
    lineItemId: ID!
    package: DeliveryPackage!
    packageId: ID!
    parcelNumber: String
    updatedAt: ISO8601DateTime!
}

type DepartmentStore implements BaseModelInterface & Node {
    address: String
    canI(action: CanIAction!): Boolean!
    cover: String
    createdAt: ISO8601DateTime!
    data: JSON
    description: String
    email: String
    gid: ID!
    id: ID!
    logo: String
    map: String
    phoneNumber: String
    schedule: JSON
    "Returns list of ETickets"
    stockLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StockLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StockLocationConnection!
    storeLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreLocationConnection!
    "Returns list of brands"
    stores(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BrandFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BrandConnection!
    timeSheets: JSON
    title: String
    updatedAt: ISO8601DateTime!
    winterTimeSheets: JSON
}

"The connection type for DepartmentStore."
type DepartmentStoreConnection {
    "A list of edges."
    edges: [DepartmentStoreEdge!]!
    "A list of nodes."
    nodes: [DepartmentStore!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type DepartmentStoreEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DepartmentStore!
}

type Device implements BaseModelInterface & Node {
    adId: String
    amountSpent: Float
    application: Application
    badgeCount: Float
    canI(action: CanIAction!): Boolean!
    country: String
    createdAt: ISO8601DateTime!
    deviceModel: String
    deviceOs: String
    deviceType: Int
    gameVersion: String
    gid: ID!
    id: ID!
    identifier: String
    ip: String
    lang: String
    language: String
    lastActive: ISO8601DateTime
    oneSignalId: String
    sessionCount: Int
    subscribed: Int
    tags: String
    timezone: Int
    updatedAt: ISO8601DateTime!
    user: User
    webAuth: String
    webP256: String
    website: Website
}

"The connection type for Device."
type DeviceConnection {
    "A list of edges."
    edges: [DeviceEdge!]!
    "A list of nodes."
    nodes: [Device!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type DeviceEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Device!
}

type DigiPayInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceId: String
    invoiceNumber: String
    redirectUrl: String
    updatedAt: ISO8601DateTime!
}

type DigitalContract implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    handedAt: ISO8601DateTime
    id: ID!
    isMaster: Boolean
    order: Order!
    receivedAt: ISO8601DateTime
    registerNum: String
    signedAt: ISO8601DateTime
    updatedAt: ISO8601DateTime!
    user: User!
}

"deprecated:"
type DigitalCreditInvoice implements BaseModelInterface & Node {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    requestNumber: String
    updatedAt: ISO8601DateTime!
}

type Discount {
    createdAt: ISO8601DateTime
    description: String
    discountType: String
    endDate: ISO8601Date
    id: ID!
    isActive: Boolean
    key: String
    percent: Float
    preferences: String
    startDate: ISO8601Date
    updatedAt: ISO8601DateTime
}

type Dispatch implements BaseModelInterface & Node {
    address: String
    calls: [DispatchCall!]!
    callsCount: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    lastCallAt: ISO8601DateTime
    latitude: String
    longitude: String
    status: String
    target: Target!
    updatedAt: ISO8601DateTime!
    website: Website
}

type DispatchCall implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    dispatch: Dispatch!
    gid: ID!
    id: ID!
    latitude: String
    longitude: String
    recipientUser: User!
    status: String!
    updatedAt: ISO8601DateTime!
}

type District implements Node {
    children: [Quarter!]!
    gid: ID!
    id: ID!
    name: String
    preferences: JSON
    quarters: [Quarter!]!
    state: State
    stateId: ID
    zip: Zipcode
}

"The connection type for District."
type DistrictConnection {
    "A list of edges."
    edges: [DistrictEdge!]!
    "A list of nodes."
    nodes: [District!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type DistrictEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: District!
}

type Donation implements BaseModelInterface & Node {
    active: Boolean
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    donationType: String
    gid: ID!
    id: ID!
    isAnonymous: Boolean
    phone: String
    product: Product
    sender: String
    updatedAt: ISO8601DateTime!
    user: User
    website: Website
}

"The connection type for Donation."
type DonationConnection {
    "A list of edges."
    edges: [DonationEdge!]!
    "A list of nodes."
    nodes: [Donation!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type DonationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Donation!
}

type DonationManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    donation: [Donation!]
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    productCat: String
    sku: String
    slug: String!
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

type DownloadableAttachment implements BaseModelInterface & Node {
    attachment: String
    attachmentContentType: String
    attachmentFileName: String
    attachmentFileSize: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    duration: String
    gid: ID!
    id: ID!
    position: Int
    updatedAt: ISO8601DateTime!
    variant: Variant
}

type DropshipBrand implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    key: String!
    name: String
    presentation: String
    provider: DropshipProvider!
    providerId: ID!
    slug: String!
    updatedAt: ISO8601DateTime!
}

"The connection type for DropshipBrand."
type DropshipBrandConnection {
    "A list of edges."
    edges: [DropshipBrandEdge!]!
    "A list of nodes."
    nodes: [DropshipBrand!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type DropshipBrandEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DropshipBrand!
}

type DropshipCategory implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    children: [DropshipCategory!]!
    childrenIds: [ID!]!
    createdAt: ISO8601DateTime!
    depth: Int!
    gid: ID!
    id: ID!
    key: String!
    name: String!
    parent: DropshipCategory
    parentId: ID
    presentation: String!
    prettyName: String!
    productCount: Int
    provider: DropshipProvider!
    providerId: ID!
    slug: String!
    taxonIds: [ID!]!
    taxons: [Taxon!]!
    updatedAt: ISO8601DateTime!
}

"The connection type for DropshipCategory."
type DropshipCategoryConnection {
    "A list of edges."
    edges: [DropshipCategoryEdge!]!
    "A list of nodes."
    nodes: [DropshipCategory!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type DropshipCategoryEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DropshipCategory!
}

type DropshipManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    hiddenTitle: String
    id: ID!
    image: String
    maxQty: Int
    minAllowedQty: Int
    name: String!
    offerId: String
    optionsText: String
    price: Float!
    productCat: String
    sellerOpenid: String
    shipmentCost: Float
    sku: String
    slug: String!
    totalOnHand: Int
    tradeScore: String
    vendor: Vendor
    weight: Float
}

type DropshipProduct implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    currency: String
    data: JSON
    gid: ID!
    id: ID!
    images: JSON
    key: String
    listed: Boolean
    name: String
    price: Float
    provider: DropshipProvider
    providerId: ID
    quantity: Float
    sku: String
    slug: String
    syncedAt: ISO8601Date
    updatedAt: ISO8601DateTime!
}

"The connection type for DropshipProduct."
type DropshipProductConnection {
    "A list of edges."
    edges: [DropshipProductEdge!]!
    "A list of nodes."
    nodes: [DropshipProduct!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type DropshipProductEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DropshipProduct!
}

type DropshipProvider implements BaseModelInterface & Node {
    "Returns list of dropship brands"
    brands(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DropshipBrandFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DropshipBrandConnection!
    canI(action: CanIAction!): Boolean!
    "Returns list of dropship categories"
    categories(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DropshipCategoryFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DropshipCategoryConnection!
    createdAt: ISO8601DateTime!
    currency: String
    gid: ID!
    id: ID!
    name: String
    "Returns list of products owned by parent vendor"
    products(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DropshipProductFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DropshipProductConnection!
    search(brandIds: [ID!], categoryIds: [ID!], first: Int, ids: [ID!], name: String, offset: Int): JSON!
    status: String
    type: String
    updatedAt: ISO8601DateTime!
    vendor: Vendor
}

"The connection type for DropshipProvider."
type DropshipProviderConnection {
    "A list of edges."
    edges: [DropshipProviderEdge!]!
    "A list of nodes."
    nodes: [DropshipProvider!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type DropshipProviderEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DropshipProvider!
}

type DynamicMenu implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    gid: ID!
    id: ID!
    system: Boolean
    title: String
    updatedAt: ISO8601DateTime!
    website: Website
}

type DynamicPage implements BaseModelInterface & Node {
    background: JSON
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    createdBy: User
    gid: ID!
    id: ID!
    items: [JSON!]
    language: String
    layout: String
    menuId: ID
    metaDescription: String
    metaImage: Image
    metaImageId: ID
    metaKeywords: String
    metaTitle: String
    preferences: JSON
    rawItems: [JSON!]
    slug: String
    subPages: [DynamicPage!]!
    title: String
    updatedAt: ISO8601DateTime!
    vendor: Vendor
    vendorId: ID
    visible: Boolean
}

"The connection type for DynamicPage."
type DynamicPageConnection {
    "A list of edges."
    edges: [DynamicPageEdge!]!
    "A list of nodes."
    nodes: [DynamicPage!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type DynamicPageEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DynamicPage!
}

type EMongoliaType implements KycInterface {
    address: String
    civilId: String
    createdAt: ISO8601DateTime!
    expireAt: ISO8601Date
    firstName: String
    id: ID!
    lastName: String
    registerNum: String
    status: KycStatus
    type: String
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
    vendor: Vendor
    vendorId: ID
    websiteId: ID
}

type ETicket implements BaseModelInterface & Node {
    activated: Boolean
    "Returns list of ETickets"
    activations(eTicketId: ID): [ETicketActivation!]
    activeActivation: ETicketActivation
    additionalInfo: JSON
    amount: Int
    attachmentContentType: String
    attachmentFileName: String
    body: JSON
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    date: ISO8601DateTime
    deactivatedAt: ISO8601DateTime
    email: String
    gid: ID!
    groupNo: Int
    id: ID!
    inventoryUnitId: ID
    invite: EventInviteItem
    inviteId: ID
    lineItem: LineItem!
    number: String
    order: Order!
    product: Product!
    qrCode: String
    qrData: String
    receiverEmail: String
    scannedBy: User
    seat: String
    seatInfo: JSON
    sentAt: ISO8601DateTime
    status: String
    updatedAt: ISO8601DateTime!
    usedAt: ISO8601DateTime
    user: User
    variant: Variant!
    vendor: Vendor
    website: Website!
}

type ETicketActivation implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    citizenId: String
    citizenship: String
    createdAt: ISO8601DateTime!
    eTicket: ETicket!
    eTicketsId: ID!
    email: String
    firstName: String
    gid: ID!
    id: ID!
    integrationResponse: JSON
    lastName: String
    organization: String
    phone: String
    phoneAdditional: String
    status: String
    type: String!
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
    website: Website
    websiteId: ID
}

type ETicketActivationMethod implements BaseModelInterface & Node {
    activationMethod: String
    canI(action: CanIAction!): Boolean!
    config: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    title: String
    updatedAt: ISO8601DateTime!
    vendorId: ID
}

"The connection type for ETicketActivationMethod."
type ETicketActivationMethodConnection {
    "A list of edges."
    edges: [ETicketActivationMethodEdge!]!
    "A list of nodes."
    nodes: [ETicketActivationMethod!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ETicketActivationMethodEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ETicketActivationMethod!
}

"The connection type for ETicket."
type ETicketConnection {
    "A list of edges."
    edges: [ETicketEdge!]!
    "A list of nodes."
    nodes: [ETicket!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ETicketEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ETicket!
}

type ETicketManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    eTickets: [ETicket!]!
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    productCat: String
    sku: String
    slug: String!
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

type EmergencyContact implements BaseModelInterface & Node {
    address: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    firstName: String
    gid: ID!
    id: ID!
    lastName: String
    mobile: String
    relation: String
    updatedAt: ISO8601DateTime!
    user: User
}

type Employee implements BaseModelInterface & Node {
    addedBy: User
    "Returns list of assets"
    assets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AssetFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AssetRoleConnection!
    bankAccounts: [BankAccount!]
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    email: String
    fullName: String
    gid: ID!
    "Returns list of business user groups"
    groups(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessUserGroupFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BusinessUserGroupTypeConnection
    id: ID!
    jobTitle: String
    lastName: String
    login: String
    mobile: String
    msCode: String
    profile: BusinessUserProfile
    role: String
    salesManagerBonus: Float
    salesManagerIsVendor: Boolean
    salesManagerTaxpayerNumber: String
    status: String
    updatedAt: ISO8601DateTime!
    user: User
    vendor: Vendor
}

"The connection type for Employee."
type EmployeeConnection {
    "A list of edges."
    edges: [EmployeeEdge!]!
    "A list of nodes."
    nodes: [Employee!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type EmployeeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Employee!
}

type ErpIntegration implements BaseModelInterface & Node {
    active: Boolean
    autoSync: Boolean
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    erp: String
    frequency: String
    gid: ID!
    id: ID!
    integrationRecords(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: IntegrationRecordFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): IntegrationRecordConnection!
    integrationReports(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: IntegrationReportFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): IntegrationReportConnection!
    matchField: String
    name: String
    preferences: JSON
    repeat: String
    time: String
    type: String
    updatedAt: ISO8601DateTime!
    vendor: Vendor
}

type Event implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    client: String
    contact: Contact
    createdAt: ISO8601DateTime!
    device: String
    eventType: String
    gid: ID!
    id: ID!
    ip: String
    note: String
    sourceId: ID
    sourceType: String
    updatedAt: ISO8601DateTime!
    userAgent: String
}

"The connection type for Event."
type EventConnection {
    "A list of edges."
    edges: [EventEdge!]!
    "A list of nodes."
    nodes: [Event!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type EventEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Event!
}

type EventEntryWinning implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    eventEntry: eventEntry!
    gid: ID!
    id: ID!
    source: EventWinning
    sourceId: ID
    sourceType: String
    updatedAt: ISO8601DateTime!
}

type EventInvite implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    company: String!
    createdAt: ISO8601DateTime!
    description: String
    "Returns list of ETickets"
    eTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ETicketFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ETicketConnection
    gid: ID!
    id: ID!
    items(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: EventInviteItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): EventInviteItemConnection
    number: String!
    order: Order
    orderId: ID
    product: Product!
    productId: ID!
    quantity: Int
    references: JSON
    status: String!
    ticketsCount: Int
    total: Float
    updatedAt: ISO8601DateTime!
    usedTicketsCount: Int
    user: User!
    userId: ID!
    website: Website!
    websiteId: ID!
}

"The connection type for EventInvite."
type EventInviteConnection {
    "A list of edges."
    edges: [EventInviteEdge!]!
    "A list of nodes."
    nodes: [EventInvite!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type EventInviteEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: EventInvite!
}

type EventInviteItem implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    "Returns list of ETickets"
    eTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ETicketFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ETicketConnection!
    email: String!
    gid: ID!
    id: ID!
    invite: EventInvite!
    inviteId: ID!
    mobile: String
    quantity: Int!
    receiverName: String!
    status: String!
    updatedAt: ISO8601DateTime!
    variant: Variant!
    variantId: ID!
}

"The connection type for EventInviteItem."
type EventInviteItemConnection {
    "A list of edges."
    edges: [EventInviteItemEdge!]!
    "A list of nodes."
    nodes: [EventInviteItem!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type EventInviteItemEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: EventInviteItem!
}

type FeatureType implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    feature: String!
    gid: ID!
    id: ID!
    updatedAt: ISO8601DateTime!
    website: Website!
}

type Featured implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    createdUser: User
    description: String
    from: ISO8601DateTime
    gid: ID!
    id: ID!
    isActive: Boolean!
    target: FeaturedTarget
    targetId: ID!
    targetType: String!
    to: ISO8601DateTime
    updatedAt: ISO8601DateTime!
    website: Website
}

"The connection type for Featured."
type FeaturedConnection {
    "A list of edges."
    edges: [FeaturedEdge!]!
    "A list of nodes."
    nodes: [Featured!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type FeaturedEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Featured!
}

type FeedbackTopic implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    children: [FeedbackTopic!]!
    createdAt: ISO8601DateTime!
    feedbacks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FeedbackFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FeedbackTypeConnection!
    gid: ID!
    id: ID!
    orderRequired: Boolean!
    parent: FeedbackTopic
    parentId: ID
    position: Int
    positive: Boolean!
    title: String
    updatedAt: ISO8601DateTime!
    website: Website!
    websiteId: ID!
}

"The connection type for FeedbackTopic."
type FeedbackTopicConnection {
    "A list of edges."
    edges: [FeedbackTopicEdge!]!
    "A list of nodes."
    nodes: [FeedbackTopic!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type FeedbackTopicEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: FeedbackTopic!
}

type FeedbackType implements BaseModelInterface & Node {
    body: String!
    canI(action: CanIAction!): Boolean!
    "Returns list of comments"
    comments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CommentConnection!
    createdAt: ISO8601DateTime!
    email: String
    firstName: String
    gid: ID!
    id: ID!
    image: String
    lastName: String
    mainType: String
    order: Order
    phone: String
    resolver: User
    status: String
    topic: FeedbackTopic
    totalComments: Int
    unreadCommentsCount: Int!
    updatedAt: ISO8601DateTime!
    user: User
    website: Website!
}

"The connection type for FeedbackType."
type FeedbackTypeConnection {
    "A list of edges."
    edges: [FeedbackTypeEdge!]!
    "A list of nodes."
    nodes: [FeedbackType!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type FeedbackTypeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: FeedbackType!
}

type FirstOrder implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type FlatPercentItemTotal implements BaseModelInterface & CalculatorInterface & Node {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    preferredFlatPercent: Float!
    type: String
    updatedAt: ISO8601DateTime!
}

type FlatPercentOrderTotal implements BaseModelInterface & CalculatorInterface & Node {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    preferredFlatPercent: Float!
    type: String
    updatedAt: ISO8601DateTime!
}

type FlatRate implements BaseModelInterface & CalculatorInterface & Node {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    preferredAmount: Float!
    preferredCurrency: String!
    type: String
    updatedAt: ISO8601DateTime!
}

type FlexiRate implements BaseModelInterface & CalculatorInterface & Node {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    preferredAdditionalItem: Float!
    preferredCurrency: String!
    preferredFirstItem: Float!
    preferredMaxItems: Int!
    type: String
    updatedAt: ISO8601DateTime!
}

type Follow implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    "Returns followers list"
    followers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FollowerFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FollowerConnection!
    followersCount: Int!
    following: Boolean!
    gid: ID!
    id: ID!
    target: FollowTarget
    updatedAt: ISO8601DateTime!
    website: Website
}

type Follower implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    follow: Follow
    gid: ID!
    id: ID!
    status: String
    updatedAt: ISO8601DateTime!
    user: User
}

"The connection type for Follower."
type FollowerConnection {
    "A list of edges."
    edges: [FollowerEdge!]!
    "A list of nodes."
    nodes: [Follower!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type FollowerEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Follower!
}

type Game implements BaseModelInterface & Node {
    active: Boolean
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    expireAt: ISO8601DateTime
    gid: ID!
    icon: String
    id: ID!
    leaderboard: [JSON!]!
    preferredFreeTryGiftCount: Int
    preferredFreeTryGiftIntervalStartAt: ISO8601DateTime
    preferredFreeTryGiftsEnabled: Boolean
    preferredFreeTryInterval: Int
    preferredMaxScoreOnSingleInstance: Int
    preferredOrderTotalThreshold: Int
    preferredOrderTryApplyOnEachInstance: Boolean
    preferredOrderTryGiftCount: Int
    preferredOrderTryGiftsEnabled: Boolean
    preferredPrizeDistributionAt: ISO8601DateTime
    preferredPrizeDistributionPool: Int
    preferredPrizeDistributionType: String
    preferredScoreThreshold: Int
    preferredTotalPrizePool: Int
    preferredTriesStoreEnabled: Boolean
    preferredTryStorePrice: Int
    preferredUserDailyUsageLimit: Int
    preferredUserTryMaxLimit: Int
    prizes: [GamePrize!]!
    startAt: ISO8601DateTime
    title: String
    updatedAt: ISO8601DateTime!
}

type GamePrize implements BaseModelInterface & Node {
    availableFrom: ISO8601DateTime
    availableUntil: ISO8601DateTime
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String
    preferredMaxEligibleRank: Int
    preferredMinEligibleRank: Int
    quantity: Int
    source: PrizeSource
    sourceId: ID
    sourceType: String
    updatedAt: ISO8601DateTime!
}

type Gamification implements Node {
    active: Boolean!
    createdAt: ISO8601DateTime!
    description: String
    expiresAt: ISO8601DateTime
    gid: ID!
    goalPolicy: String!
    "Returns list of products"
    goalProducts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ProductFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        websiteId: ID
    ): ProductConnection!
    "Returns list of variants"
    goalVariants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: VariantFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        permission: VariantsPermission,
        "Sorting functionality"
        sort: SortFilter
    ): VariantConnection!
    goals: [GamificationGoal!]!
    id: ID!
    name: String!
    preferences: JSON!
    "Returns list of gamifications"
    progresses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: GamificationProgressFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ProgressConnection!
    startsAt: ISO8601DateTime
    updatedAt: ISO8601DateTime!
}

"The connection type for Gamification."
type GamificationConnection {
    "A list of edges."
    edges: [GamificationEdge!]!
    "A list of nodes."
    nodes: [Gamification!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type GamificationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Gamification!
}

type GamificationGoalOrderTotal implements GamificationGoal & Node {
    accumulateBy: GamificationGoalAccumulateBy!
    createdAt: ISO8601DateTime!
    currentCycle: String!
    gamificationId: ID!
    gid: ID!
    id: ID!
    name: String!
    nextCycle: String!
    preferences: JSON
    prevCycle: String!
    prevCycles(size: Int!): [String!]!
    repeat: GamificationGoalRepeat!
    type: String!
    updatedAt: ISO8601DateTime!
}

type GamificationGoalProduct implements GamificationGoal & Node {
    accumulateBy: GamificationGoalAccumulateBy!
    createdAt: ISO8601DateTime!
    currentCycle: String!
    gamificationId: ID!
    gid: ID!
    id: ID!
    name: String!
    nextCycle: String!
    preferences: JSON
    prevCycle: String!
    prevCycles(size: Int!): [String!]!
    productIds: [ID!]!
    repeat: GamificationGoalRepeat!
    storeIds: [ID!]!
    type: String!
    updatedAt: ISO8601DateTime!
    variantIds: [ID!]!
}

type GamificationGoalProperty implements GamificationGoal & Node {
    accumulateBy: GamificationGoalAccumulateBy!
    createdAt: ISO8601DateTime!
    currentCycle: String!
    gamificationId: ID!
    gid: ID!
    id: ID!
    name: String!
    nextCycle: String!
    preferences: JSON
    prevCycle: String!
    prevCycles(size: Int!): [String!]!
    repeat: GamificationGoalRepeat!
    type: String!
    updatedAt: ISO8601DateTime!
}

type GiftCard implements BaseModelInterface & Node {
    amount: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    currency: String
    deactivatedAt: ISO8601DateTime
    gid: ID!
    giftMessage: String
    id: ID!
    inventoryUnitId: ID
    lineItem: LineItem
    number: String
    order: Order
    printed: Boolean!
    product: Product
    purchaserId: ID
    purchaserName: String
    recipientEmail: String
    recipientName: String
    recipientPhone: String
    redeemable: Boolean
    redeemedAt: ISO8601DateTime
    redeemer: User
    redeemerVendor: Vendor
    redemptionCode: String
    sendEmailAt: ISO8601DateTime
    sentAt: ISO8601DateTime
    storeCreditId: ID
    updatedAt: ISO8601DateTime!
}

"The connection type for GiftCard."
type GiftCardConnection {
    "A list of edges."
    edges: [GiftCardEdge!]!
    "A list of nodes."
    nodes: [GiftCard!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type GiftCardEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: GiftCard!
}

type GiftCardManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    giftCards: [GiftCard!]
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    productCat: String
    sku: String
    slug: String!
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

type GolomtCard implements BaseModelInterface & Node & PaymentSourceInterface {
    bank: String!
    canI(action: CanIAction!): Boolean!
    cardHolder: String!
    cardNumber: String!
    createdAt: ISO8601DateTime!
    creditLimit: Float
    currentBalance: Float
    expiry: String
    gid: ID!
    id: ID!
    passwordSet: Boolean
    paymentMethod: PaymentMethod
    paymentMethodId: ID
    statements(from: String!, to: String): JSON
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
}

type GolomtDigitalInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceId: String
    registerNumber: String
    requestId: String
    updatedAt: ISO8601DateTime!
}

type GolomtKYC implements KycInterface {
    address1: String
    address2: String
    address3: String
    apartment: String
    appointment: String
    branchId: String
    city: String
    country: String
    createdAt: ISO8601DateTime!
    creditLimit: Int
    degree: String
    doorNo: String
    embossName: String
    enrollmentDate: String
    entry: String
    expireAt: ISO8601Date
    id: ID!
    isCustomer: Boolean
    isEbankEnabled: Boolean
    isMasterAgreement: Boolean
    isPreApproved: Boolean
    maritalStatus: String
    schoolName: String
    sector: String
    startDate: String
    state: String
    status: KycStatus
    streetName: String
    subDistrict: String
    subSector: String
    town: String
    type: String
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
    vendor: Vendor
    vendorId: ID
    websiteId: ID
    yearsWork: Int
}

type GolomtPosInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    merchantId: String
    pan: String
    referenceNo: String
    response: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type HandlebarTemplate implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    code: String
    createdAt: ISO8601DateTime!
    data: String
    gid: ID!
    id: ID!
    paperSize: String
    updatedAt: ISO8601DateTime!
    website: Website
}

type HiPayInAppInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    checkoutId: String
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    invoiceNumber: String
    requestId: String
    updatedAt: ISO8601DateTime!
}

type HiPayInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    checkoutId: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    requestId: String
    updatedAt: ISO8601DateTime!
}

type History implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type HotelManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    hotel: [HotelProduct!]!
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    productCat: String
    sku: String
    slug: String!
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

type HotelProduct implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    guest: String
    hotel: String
    id: ID!
    lineItem: LineItem
    name: String
    price: Float
    reserve: String
    room: String
    sku: String
    updatedAt: ISO8601DateTime!
    userId: ID
    website: Website
}

type Image implements BaseModelInterface & Node {
    alt: String
    attachmentContentType: String
    attachmentFileName: String
    attachmentFileSize: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    endDate: ISO8601DateTime
    gid: ID!
    group: String
    id: ID!
    link: String
    position: Int
    title: String
    updatedAt: ISO8601DateTime!
    url(format: ImageFormat, height: Int!, width: Int!): String
    user: User
    vendor: Vendor
    viewableId: ID
    viewableType: String
    website: Website
}

"The connection type for Image."
type ImageConnection {
    "A list of edges."
    edges: [ImageEdge!]!
    "A list of nodes."
    nodes: [Image!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ImageEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Image!
}

"Image attachment"
type ImageVariation implements Node {
    alt: String
    attachmentContentType: String
    attachmentFileName: String
    attachmentFileSize: Int
    attachmentId: ID
    gid: ID!
    id: ID!
    large: String
    medium: String
    original: String
    small: String
    url(
        "Extracts an area from an image. The first two arguments are the left and top edges of area to extract, while the last two arguments are the width and height of the area to extract."
        crop: [Int!],
        "Image format"
        format: ImageFormat,
        "Image quality: 0-100"
        quality: Int = 80,
        "Resizes the image to fit within the specified dimensions while retaining the original aspect ratio. If necessary, will pad the remaining area with transparent color if source image has alpha channel, black otherwise."
        resizeAndPad: [Int!],
        "Resizes the image to fill the specified dimensions while retaining the original aspect ratio. If necessary, will crop the image in the larger dimension."
        resizeToFill: [Int!],
        "Resizes the image to fit within the specified dimensions while retaining the original aspect ratio.Will downsize the image if it's larger than the specified dimensions or upsize if it's smaller."
        resizeToFit: [Int!],
        "Downsizes the image to fit within the specified dimensions while retaining the original aspect ratio.Will only resize the image if it's larger than the specified dimensions."
        resizeToLimit: [Int!]
    ): String!
}

type IntegrationRecord implements BaseModelInterface & Node {
    body: JSON
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    erpIntegration: ErpIntegration
    erpIntegrationId: ID
    gid: ID!
    id: ID!
    idx: String
    notFound: Boolean
    preferences: String
    status: String
    updatedAt: ISO8601DateTime!
}

"The connection type for IntegrationRecord."
type IntegrationRecordConnection {
    "A list of edges."
    edges: [IntegrationRecordEdge!]!
    "A list of nodes."
    nodes: [IntegrationRecord!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type IntegrationRecordEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IntegrationRecord!
}

type IntegrationReport implements BaseModelInterface & Node {
    body: JSON
    canI(action: CanIAction!): Boolean!
    category: String
    created: Int
    createdAt: ISO8601DateTime!
    data: JSON
    description: String
    direction: Boolean!
    endedAt: ISO8601DateTime
    excluded: Int
    gid: ID!
    id: ID!
    message: String
    notFound: Int!
    owner: IntegrationReportSource
    ownerId: ID
    ownerType: String
    received: Int!
    skipped: Int!
    source: IntegrationReportSource
    sourceId: ID
    sourceType: String
    startedAt: ISO8601DateTime
    status: String
    synced: Int!
    updatedAt: ISO8601DateTime!
    website: Website
}

"The connection type for IntegrationReport."
type IntegrationReportConnection {
    "A list of edges."
    edges: [IntegrationReportEdge!]!
    "A list of nodes."
    nodes: [IntegrationReport!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type IntegrationReportEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: IntegrationReport!
}

type IntendInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    bonus: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    fullName: String
    gid: ID!
    id: ID!
    installationPrice: Int
    limit: Int
    perMonthAmount: Int
    phone: String
    price: Int
    status: String
    updatedAt: ISO8601DateTime!
    username: String
}

type Interval implements BaseModelInterface & CalculatorInterface & Node {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    preferredAmount: Float!
    preferredCurrency: String!
    preferredInterval: Int!
    preferredMatchPolicy: String!
    preferredRule: String!
    type: String
    updatedAt: ISO8601DateTime!
}

type InventoryUnit implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    inventoryUnitActions: [InventoryUnitAction!]!
    lineItem: LineItem
    order: Order
    originalReturnItem: ReturnItem
    pending: Boolean
    quantity: Int
    shipment: Shipment
    state: String
    updatedAt: ISO8601DateTime!
    variant: Variant
}

type InventoryUnitAction implements BaseModelInterface & Node {
    action: String
    actionBy: User!
    canI(action: CanIAction!): Boolean!
    comment: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    inventoryUnit: InventoryUnit!
    lineItem: LineItem!
    location: StoreLocation
    order: Order!
    quantity: Int
    shipment: Shipment!
    updatedAt: ISO8601DateTime!
    variant: Variant!
}

"The connection type for InventoryUnitAction."
type InventoryUnitActionConnection {
    "A list of edges."
    edges: [InventoryUnitActionEdge!]!
    "A list of nodes."
    nodes: [InventoryUnitAction!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type InventoryUnitActionEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: InventoryUnitAction!
}

type Invitation implements BaseModelInterface & Node {
    accepts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): InvitationAcceptConnection!
    active: Boolean
    canI(action: CanIAction!): Boolean!
    code: String!
    createdAt: ISO8601DateTime!
    endsAt: ISO8601DateTime
    gid: ID!
    id: ID!
    name: String!
    preferences: JSON!
    startsAt: ISO8601DateTime
    type: String!
    updatedAt: ISO8601DateTime!
    userInvitations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserInvitationConnection!
    website: Website!
    websiteId: ID!
}

type InvitationAccept implements BaseModelInterface & Node {
    acceptedAt: ISO8601DateTime!
    acceptedUser: User!
    acceptedUserId: ID!
    active: Boolean!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invitation: Invitation!
    invitationId: ID!
    updatedAt: ISO8601DateTime!
    userInvitation: UserInvitation!
    userInvitationId: ID!
    website: Website!
    websiteId: ID!
}

"The connection type for InvitationAccept."
type InvitationAcceptConnection {
    "A list of edges."
    edges: [InvitationAcceptEdge!]!
    "A list of nodes."
    nodes: [InvitationAccept!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type InvitationAcceptEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: InvitationAccept!
}

type ItemTotal implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredAmountMax: Float!
    preferredAmountMin: Float!
    preferredOperatorMax: String!
    preferredOperatorMin: String!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type JobLog implements BaseModelInterface & Node {
    arguments: JSON
    at: Int
    canI(action: CanIAction!): Boolean!
    completedAt: ISO8601DateTime
    createdAt: ISO8601DateTime!
    errorMessage: String
    file: String
    gid: ID!
    id: ID!
    jobId: String
    jobType: String
    "Latency in seconds"
    latency: Int
    message: String
    percentComplete: Int
    startedAt: ISO8601DateTime
    status: String
    total: Int
    updatedAt: ISO8601DateTime!
}

type KeyValue {
    key: String!
    value: String!
}

"Amazon style Keyword type"
type Keyword implements BaseModelInterface & Node {
    "Alias value/Also known for: Used for search optimization"
    alias: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    "Formatted value"
    full: String
    gid: ID!
    "Google Product category"
    gpc: String
    grouping: String
    id: ID!
    "Mongolian name: Used for translated search"
    mn: String
    "Keyword name: unique identifier for given keyword"
    name: String!
    products(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ProductConnection!
    prototype: Prototype
    updatedAt: ISO8601DateTime!
}

type KhaanLeasingInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoice: String
    invoiceNumber: String
    qrLink: String
    register: String
    updatedAt: ISO8601DateTime!
}

type LeasingInfo implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    customerFee: Float
    gid: ID!
    hasQuickLoan: Boolean
    id: ID!
    incomeConfirm: Boolean
    interest: Float
    maxAmount: Float
    maxMonth: Float
    merchantFee: Float
    status: Int
    tdbmCustomer: Boolean
    tdbmEmployee: Boolean
    updatedAt: ISO8601DateTime!
    userId: ID
}

type LendInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    qrLink: String
    qrString: String
    updatedAt: ISO8601DateTime!
}

type License implements BaseModelInterface & Node {
    additionalData: String
    canI(action: CanIAction!): Boolean!
    claimedAt: ISO8601DateTime
    createdAt: ISO8601DateTime!
    createdBy: User
    gid: ID!
    id: ID!
    inventoryUnitId: ID
    lineItem: LineItem!
    lineItemId: ID
    order: Order
    product: Product!
    serial: String
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
    variant: Variant!
    variantId: ID
}

"The connection type for License."
type LicenseConnection {
    "A list of edges."
    edges: [LicenseEdge!]!
    "A list of nodes."
    nodes: [License!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type LicenseEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: License!
}

type LineItem implements BaseModelInterface & Node {
    actn: String
    additionalTaxTotal: Float
    adjustmentTotal: Float
    adjustments: [Adjustment!]
    alibabaOrder: AlibabaOrder
    amount: Float!
    amountUsd: Float
    attachments: [String!]!
    basePrice: Float
    broughtAt: ISO8601DateTime
    canI(action: CanIAction!): Boolean!
    comment: String
    comments: [Comment!]!
    commission: Float
    commissionUpdated: Boolean
    costCurrency: String
    costPrice: Float
    costRate: Float
    "Returns list of promotions"
    coupons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CouponFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CouponConnection!
    createdAt: ISO8601DateTime!
    currency: String
    data: JSON
    defaultPrice: Float!
    displayAmount: String!
    eTickets: [ETicket!]!
    ebarimtType: String
    fee: Float
    gid: ID!
    giftOrigin: JSON
    "Gift quantity"
    giftQuantity: Int!
    hasMoreVariants(stockLocationIds: [ID!]): Boolean! @deprecated(reason: "Will be removed in future")
    id: ID!
    imeiCodes: [String!]
    imeiCodesEnabled: Boolean
    includedTaxTotal: Float!
    inventoryUnits: [InventoryUnit!]!
    isDigital: Boolean
    labelCodes: [String!]
    labelCodesEnabled: Boolean
    listing: Listing
    location: String
    manifest: ProductManifestInterface!
    movieTicket: MovieTicket
    name: String!
    nonTaxableAdjustmentTotal: Float
    order: Order!
    packageCode: String
    packedAt: ISO8601DateTime
    packedBy: User
    partLineItems: [PartLineItem!]!
    preTaxAmount: Float!
    preferredCostPrice: Float
    prevItem: LineItem
    price: Float!
    priceChannels: JSON!
    priceUsd: Float
    product: Product!
    productCat: String!
    promoQuantity: JSON!
    promoQuantityDisplay: JSON!
    promoQuantityIntervals: JSON!
    promoTotal: Float
    "Actual shippable quantity"
    qty: Int!
    "Ordered quantity"
    quantity: Int!
    receivedAt: ISO8601DateTime
    receivedBy: User
    returnAt: ISO8601DateTime
    returnBy: User
    returnLocation: String
    segment: SupplySegment
    segmentId: ID
    seriesExpiresAt: String @deprecated(reason: "Will be removed in future")
    shipmentAmount: Float
    shipmentAmountUpdated: Boolean
    shipmentPrice: Float
    singleDisplayAmount: String!
    sku: String!
    storeVariantStatus: String
    swappedItems: [LineItem!]
    takeLocation: StoreLocation
    takenAt: ISO8601DateTime
    takenBy: User
    takenLocation: StoreLocation
    takenStatus: String
    taxCategoryId: ID
    taxCode: String
    taxableAdjustmentTotal: Float
    total: Float!
    totalCountOnHand(stockLocationIds: [ID!]): Float @deprecated(reason: "Will be removed in future, use total_on_hand if it exists")
    totalWeight: Float
    totalWeightInKg: Float
    updatedAt: ISO8601DateTime!
    variant: Variant!
    variantId: ID!
    variantInfo: JSON
    vatTotal: Float
    vendor: Vendor!
    vendorId: ID!
    vendorName: String
    vendorRegister: String
    volume: Float
    weight: Float
    weightInKg: Float
}

"The connection type for LineItem."
type LineItemConnection {
    "A list of edges."
    edges: [LineItemEdge!]!
    "A list of nodes."
    nodes: [LineItem!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type LineItemEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: LineItem!
}

type LineItemReport implements BaseModelInterface & Node {
    absTotal: Float
    actn: String
    addedNew: String
    addedTotal: Float
    additionalTaxTotal: Float
    adjustPrice: Float
    adjustmentTotal: Float
    adjustments: [Adjustment!]
    alibabaOrder: AlibabaOrder
    amount: Float!
    amountUsd: Float
    assemblyManifest: [JSON!]!
    attachments: [String!]!
    basePrice: Float
    broughtAt: ISO8601DateTime
    canI(action: CanIAction!): Boolean!
    canceledTotal: Float
    changed: JSON
    checkSum: Float
    comment: String
    comments: [Comment!]!
    commission: Float
    commissionUpdated: Boolean
    completeTotal: Float
    computedFee: Float
    costCurrency: String
    costPrice: Float
    costRate: Float
    "Returns list of promotions"
    coupons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CouponFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CouponConnection!
    createdAt: ISO8601DateTime!
    currency: String
    currencyRate: String
    data: JSON
    defaultPrice: Float!
    displayAmount: String!
    eTickets: [ETicket!]!
    ebarimtType: String
    fee: Float
    finalCount: Int
    finalTotal: Float
    gid: ID!
    giftOrigin: JSON
    "Gift quantity"
    giftQuantity: Int!
    hasMoreVariants(stockLocationIds: [ID!]): Boolean! @deprecated(reason: "Will be removed in future")
    id: ID!
    imeiCodes: [String!]
    imeiCodesEnabled: Boolean
    includedTaxTotal: Float!
    inventoryUnits: [InventoryUnit!]!
    isDigital: Boolean
    labelCodes: [String!]
    labelCodesEnabled: Boolean
    leaseLeft: Int
    leaseTransactionDate: ISO8601DateTime
    listing: Listing
    location: String
    manifest: ProductManifestInterface!
    movieTicket: MovieTicket
    name: String!
    noStockTotal: Float
    nonTaxableAdjustmentTotal: Float
    onShip: JSON
    order: Order!
    orderReport: OrderReport
    originalPrice: Float
    packageCode: String
    packedAt: ISO8601DateTime
    packedBy: User
    partLineItems: [PartLineItem!]!
    preTaxAmount: Float!
    preferredCostPrice: Float
    prevItem: LineItem
    price: Float!
    priceChannels: JSON!
    priceUsd: Float
    product: Product!
    productCat: String!
    promoQuantity: JSON!
    promoQuantityDisplay: JSON!
    promoQuantityIntervals: JSON!
    promoTotal: Float
    "Actual shippable quantity"
    qty: Int!
    "Ordered quantity"
    quantity: Int!
    receivedAt: ISO8601DateTime
    receivedBy: User
    returnAt: ISO8601DateTime
    returnBy: User
    returnLocation: String
    returnTotal: Float
    segment: SupplySegment
    segmentId: ID
    seriesExpiresAt: String @deprecated(reason: "Will be removed in future")
    shipmentAmount: Float
    shipmentAmountUpdated: Boolean
    shipmentPrice: Float
    shippedAt: ISO8601DateTime
    singleDisplayAmount: String!
    sku: String!
    storeCreditUsage: Int
    storeVariantStatus: String
    swappedItems: [LineItem!]
    takeLocation: StoreLocation
    takenAmount: Float
    takenAt: ISO8601DateTime
    takenBy: User
    takenLocation: StoreLocation
    takenStatus: String
    taxCategoryId: ID
    taxCode: String
    taxableAdjustmentTotal: Float
    ticketInfo: JSON
    total: Float!
    totalCountOnHand(stockLocationIds: [ID!]): Float @deprecated(reason: "Will be removed in future, use total_on_hand if it exists")
    totalPercentage: Int
    totalWeight: Float
    totalWeightInKg: Float
    transferAmount: Float
    updatedAt: ISO8601DateTime!
    variant: Variant!
    variantId: ID!
    variantInfo: JSON
    vatTotal: Float
    vendor: Vendor!
    vendorId: ID!
    vendorName: String
    vendorRegister: String
    volume: Float
    weight: Float
    weightInKg: Float
}

type Listing implements BaseModelInterface & Node {
    activeSince: ISO8601DateTime
    activeUntil: ISO8601DateTime
    afterPay: Boolean!
    approved: Boolean
    averageRating: Float!
    badges: [Badge!]!
    bonus: Float
    campaigns: [ID!]
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    createdBy: User
    featured: Boolean
    featuredUntil: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    hasRelatedProducts: Boolean!
    hideOnSearch: Boolean!
    id: ID!
    impressionsCount: Int
    isBlocking: Boolean
    isExcSelling: Boolean
    maxQty: Int
    minQty: Int
    myReview: Review
    options: JSON
    otherVendorsSelling: Boolean
    product: Product!
    "Returns list of promotions"
    promotions(dateType: String, filter: PromotionFilter, from: String, to: String): [Promotion!]
    properties: [Property!]!
    prototypes: [Prototype!]!
    published: Boolean
    relatedProducts: [Relation!]
    reviews(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ReviewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        isDeleted: Boolean,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ReviewConnection!
    seller: Merchant
    seoDescription: String
    seoKeywords: String
    seoTitle: String
    shippingCategory: ShippingCategory
    shippingCategoryId: ID
    sizingGuides(filter: SizingGuideFilter): [SizingGuide!]!
    slug: String
    stepQty: Int!
    stockLocations: [StockLocation!]
    storeListingId: ID
    storeListings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreListingConnection!
    taxCategory: TaxCategory
    taxCategoryId: ID
    taxons: [Taxon!]!
    totalReviews: Int!
    updatedAt: ISO8601DateTime!
    vendorIsSelling: Boolean
    website: Website!
}

"The connection type for Listing."
type ListingConnection {
    "A list of edges."
    edges: [ListingEdge!]!
    "A list of nodes."
    nodes: [Listing!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ListingEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Listing!
}

type Log implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    func: String
    gid: ID!
    id: ID!
    order: Order
    request: JSON
    updatedAt: ISO8601DateTime!
    user: User
}

type LookBook implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    cover(format: ImageFormat, height: Int!, width: Int!): String
    coverContentType: String
    coverFileName: String
    coverSquare(format: ImageFormat, height: Int!, width: Int!): String
    coverSquareContentType: String
    coverSquareFileName: String
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    isDraft: Boolean
    lookBookImages: [LookBookImage!]!
    tagList: [String!]!
    title: String
    updatedAt: ISO8601DateTime!
    website: Website
}

"The connection type for LookBook."
type LookBookConnection {
    "A list of edges."
    edges: [LookBookEdge!]!
    "A list of nodes."
    nodes: [LookBook!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type LookBookEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: LookBook!
}

type LookBookImage implements BaseModelInterface & Node {
    attachment(format: ImageFormat, height: Int!, width: Int!): String
    attachmentContentType: String
    attachmentFileName: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    lookBook: LookBook
    lookBookTags: [LookBookTag!]!
    position: Int
    title: String
    updatedAt: ISO8601DateTime!
}

type LookBookTag implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    left: Float
    lookBook: LookBook
    lookBookImage: LookBookImage
    position: Int
    product: Product
    top: Float
    updatedAt: ISO8601DateTime!
}

type LoyaltyCard implements BaseModelInterface & Node {
    active: Boolean
    address: String
    amount: Float
    baseAmount: Float
    birthDate: String
    bonusAddedAmount: Float
    bonusBalance: Float
    bonusPaymentPercent: Float
    bonusPercent: Float
    bonusUsedAmount: Float
    canI(action: CanIAction!): Boolean!
    cardTemplateName: String
    createdAt: ISO8601DateTime!
    customerId: String
    discountAmount: Float
    discountPercent: Float
    email: String
    expireDate: ISO8601DateTime
    firstName: String
    gender: String
    gid: ID!
    giftBalance: Float
    giftUsedAmount: Float
    homeAddress: Address
    id: ID!
    isChangeUseBonus: Boolean
    isShowBirthDate: Boolean
    itemBonusBalance: Float
    lastName: String
    "Returns list of loyalty card transcactions"
    loyaltyCardTransactions: [JSON!]
    loyaltyType: String
    maritalStatus: String
    notAddUseBonus: Boolean
    note: String
    number: String
    phone: String
    pointBalance: Float
    purchaseAmount: Float
    registerNumber: String
    totalBonusBalance: Float
    totalEarnedPoints: Float
    totalUsedPoints: Float
    updatedAt: ISO8601DateTime!
    useBonus: Boolean
    user: User
    voucherPaymentPercent: Float
    website: Website
    workAddress: String
}

type MassMessage implements BaseModelInterface & Node {
    acceptedBy: User
    canI(action: CanIAction!): Boolean!
    content: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    messagesCount: Int!
    roomIds: [ID!]
    segment: String
    sendAt: ISO8601DateTime
    sentIds: [ID!]
    status: String
    updatedAt: ISO8601DateTime!
    user: User!
    website: Website!
}

"The connection type for MassMessage."
type MassMessageConnection {
    "A list of edges."
    edges: [MassMessageEdge!]!
    "A list of nodes."
    nodes: [MassMessage!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type MassMessageEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: MassMessage!
}

type MassPromotion implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    createdBy: User!
    finishedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    promotion: Promotion!
    status: String
    updatedAt: ISO8601DateTime!
    userCount: Int
    users: String
}

"The connection type for MassPromotion."
type MassPromotionConnection {
    "A list of edges."
    edges: [MassPromotionEdge!]!
    "A list of nodes."
    nodes: [MassPromotion!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type MassPromotionEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: MassPromotion!
}

type MbankInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    invoiceUrl: String
    updatedAt: ISO8601DateTime!
}

type Member implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    messages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MessageConnection!
    role: String
    room: Room!
    seenMessage: Message
    unreadMessages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MessageConnection!
    updatedAt: ISO8601DateTime!
    user: User
}

type Merchant implements BaseModelInterface & Node {
    address: String
    afterPay: AfterPay!
    afterPayApprovedAt: ISO8601DateTime
    afterPayApprover: User
    afterPayTypes: [String!]
    alias: String
    allowCampaign: Boolean
    allowSelfBuy: Boolean!
    "Returns list of assets"
    assetRoles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AssetFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AssetRoleConnection!
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    autoApprove: Boolean
    background: String
    banks: [Bank!]!
    canI(action: CanIAction!): Boolean!
    cartAmount: Float
    category: SupplierCategory
    categoryId: ID
    createdAt: ISO8601DateTime!
    deliveryType: String
    description: String
    ebarimtType: String
    email: String
    facebook: String
    featured: Boolean
    featuredFrom: ISO8601DateTime
    featuredTo: ISO8601DateTime
    follow(websiteId: ID): Follow!
    follows: [Follow!]!
    "Returns list of fulfillment ready orders"
    fulfillmentDashboard(filter: OrderFilter): JSON
    fulfillmentDays: String
    gid: ID!
    id: ID!
    impressionsCount: Int!
    "Тухайн харилцагчийн авч болох бүх Listing жагсаалтын буцаана"
    listings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    listingsCount: Int
    localId: String
    maxCartAmount: Float
    minStock: Int
    organizationId: String
    page(id: ID, slug: String): DynamicPage
    "Returns list of pages"
    pages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PageFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DynamicPageConnection!
    paymentMethods: [PaymentMethod!]!
    phone: String
    preferences: JSON
    receiveOrderNotifications: Boolean!
    shippingCategoryId: Float
    state: String
    taxons: [Taxon!]!
    totalSales: Float!
    updatedAt: ISO8601DateTime!
    vendor: Vendor!
    vendorById: ID
    vendorId: ID
    web: String
    website: Website!
    websiteById: ID
}

"The connection type for Merchant."
type MerchantConnection {
    "A list of edges."
    edges: [MerchantEdge!]!
    "A list of nodes."
    nodes: [Merchant!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type MerchantEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Merchant!
}

type Message implements BaseModelInterface & Node {
    attachments: [ChatAttachment!]!
    canI(action: CanIAction!): Boolean!
    content: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    mine: Boolean
    room: Room
    roomId: ID
    status: String
    type: String
    updatedAt: ISO8601DateTime!
    user: User
}

"The connection type for Message."
type MessageConnection {
    "A list of edges."
    edges: [MessageEdge!]!
    "A list of nodes."
    nodes: [Message!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type MessageEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Message!
}

type MessengerLoanInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceId: String
    invoiceNumber: String
    updatedAt: ISO8601DateTime!
}

type MnCitizenIdentity implements KycInterface {
    back: String
    backVerifiedAt: ISO8601DateTime
    createdAt: ISO8601DateTime!
    expireAt: ISO8601Date
    front: String
    frontVerifiedAt: ISO8601DateTime
    id: ID!
    selfie: String
    selfieVerifiedAt: ISO8601DateTime
    status: KycStatus
    type: String
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
    vendor: Vendor
    vendorId: ID
    websiteId: ID
}

type MongolChatInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    qrLink: String
    updatedAt: ISO8601DateTime!
}

type MoniSource implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    expireDate: String
    gid: ID!
    id: ID!
    invoiceId: String
    merchantName: String
    mobile: String
    paymentMethod: PaymentMethod!
    paymentMethodId: ID!
    updatedAt: ISO8601DateTime!
    user: User!
    userId: ID!
}

type MonpayInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    qrLink: String
    updatedAt: ISO8601DateTime!
    uuid: String
}

type MonpayV2Invoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    invoiceNumber: String
    monpayId: String
    qrLink: String
    receiver: String
    updatedAt: ISO8601DateTime!
}

type MostInAppInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    custToken: String
    gid: ID!
    id: ID!
    tranToken: String
    updatedAt: ISO8601DateTime!
}

type MostInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    qpayAccountId: Int
    qrCode: String
    qrImage: String
    traceNo: String
    updatedAt: ISO8601DateTime!
}

type Movie implements BaseModelInterface & Node {
    attributes: [String!]
    canI(action: CanIAction!): Boolean!
    cinemas: [Cinema!]
    createdAt: ISO8601DateTime!
    genres: [String!]
    gid: ID!
    id: ID!
    idx: String
    image: String
    imdb: String
    openingDate: ISO8601Date
    rating: String
    runtime: Int
    sessions: [Session!]
    synopsis: String
    title: String
    trailerUrl: String
    updatedAt: ISO8601DateTime!
}

"The connection type for Movie."
type MovieConnection {
    "A list of edges."
    edges: [MovieEdge!]!
    "A list of nodes."
    nodes: [Movie!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type MovieEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Movie!
}

type MovieTicket implements BaseModelInterface & Node {
    amount: Float!
    area: Int!
    areaCategoryCode: String
    canI(action: CanIAction!): Boolean!
    cinema: Cinema!
    colIndex: Int!
    column: String!
    createdAt: ISO8601DateTime!
    data: String
    errorDescription: String
    expireAt: ISO8601DateTime
    gid: ID!
    historyId: String
    id: ID!
    idx: String
    movie: Movie!
    number: String
    order: Order
    row: String!
    rowIndex: Int!
    screen: Screen!
    seat: String!
    session: Session!
    status: String
    ticketType: TicketType!
    transNumber: String
    updatedAt: ISO8601DateTime!
    user: User
}

"The connection type for MovieTicket."
type MovieTicketConnection {
    "A list of edges."
    edges: [MovieTicketEdge!]!
    "A list of nodes."
    nodes: [MovieTicket!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type MovieTicketEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: MovieTicket!
}

type MovieTicketManifest implements Node & ProductManifestInterface {
    areaCategoryCode: String
    areaNumber: String
    brand: Brand
    canSupply: Boolean
    cinema: Cinema!
    column: Int
    columnIndex: Int
    data: String
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    productCat: String
    row: Int
    rowIndex: Int
    seat: String
    session: Session!
    sku: String
    slug: String!
    status: String
    ticketType: TicketType
    ticketTypeCode: String
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

type MultiPercent implements BaseModelInterface & CalculatorInterface & Node {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    preferredOrder: String!
    preferredPercents: String!
    preferredRule: String!
    type: String
    updatedAt: ISO8601DateTime!
}

type Mutation {
    "Accept mass chat message"
    acceptMassChatMessage(
        "Parameters for acceptMassChatMessage"
        input: acceptMassChatMessageInput!
    ): MassMessage
    acceptPrescription(
        "Parameters for acceptPrescription"
        input: acceptPrescriptionInput!
    ): Prescription
    actionCollect(
        "Parameters for actionCollect"
        input: actionCollectInput!
    ): Collect
    activationETicket(
        "Parameters for activationETicket"
        input: activationETicketInput!
    ): ETicketActivation
    activationSyncETicket(
        "Parameters for activationSyncETicket"
        input: activationSyncETicketInput!
    ): ETicketActivation
    "Add a bank account into user"
    addBankAccount(
        "Parameters for addBankAccount"
        input: addBankAccountInput!
    ): Bank
    "Add Store Listings by SKU code"
    addBatchStoreListings(
        "Parameters for addBatchStoreListings"
        input: addBatchStoreListingsInput!
    ): Boolean
    addCampaignList(
        "Parameters for addCampaignList"
        input: addCampaignListInput!
    ): ShoppyCampaign
    addComment(
        "Parameters for addComment"
        input: addCommentInput!
    ): Comment
    addEmployee(
        "Parameters for addEmployee"
        input: addEmployeeInput!
    ): Employee
    addFeedback(
        "Parameters for AddFeedback"
        input: AddFeedbackInput!
    ): FeedbackType
    addFeedbackTopic(
        "Parameters for AddFeedbackTopic"
        input: AddFeedbackTopicInput!
    ): FeedbackTopic
    "Захиалгын тэмдэглэл бичнэ"
    addOrderNote(
        "Parameters for addOrderNote"
        input: addOrderNoteInput!
    ): OrderComment
    addPrescriptionItem(
        "Parameters for addPrescriptionItem"
        input: addPrescriptionItemInput!
    ): PrescriptionItem
    "Promotion-ы тэмдэглэл бичнэ"
    addPromotionNote(
        "Parameters for addPromotionNote"
        input: addPromotionNoteInput!
    ): OrderComment
    addStockToLocation(
        "Parameters for addStockToLocation"
        input: addStockToLocationInput!
    ): StockItem
    addToCart(
        "Parameters for addToCart"
        input: addToCartInput!
    ): Order
    addToWish(
        "Parameters for addToWish"
        input: addToWishInput!
    ): WishedProduct
    applyCoupon(
        "Parameters for applyCoupon"
        input: applyCouponInput!
    ): Order
    approveOrders(
        "Parameters for approveOrders"
        input: approveOrdersInput!
    ): String
    assignMassPromo(
        "Parameters for assignMassPromo"
        input: assignMassPromoInput!
    ): Boolean
    """

    sms болон мэйлээр ирсэн OTP токенийг ашиглан шинэ нууц үг зохионо
    Энэ функцыг нэвтрээгүй хэрэглэгч нууц үгээ мартсан үед ашиглана
    Нэвтэрсэн хэрэглэгч `updateProfile` функцын тусламжтай нууц үгээ шинэчлэнэ
    """
    authChangePassword(
        "Parameters for authChangePassword"
        input: authChangePasswordInput!
    ): Boolean
    authChangePasswordWithOld(
        "Parameters for authChangePasswordWithOld"
        input: authChangePasswordWithOldInput!
    ): Boolean
    "Checks if email or mobile registered"
    authCheckLogin(
        "Parameters for authCheckLogin"
        input: authCheckLoginInput!
    ): JSON
    "CODY системд хэрэглэгчийн бүртгэл үүсгэх"
    authRegister(
        "Parameters for authRegister"
        input: authRegisterInput!
    ): Boolean
    "Нэвтрээгүй хэрэглэгч нууц үгээ сэргээх хүсэлт илгээснээр `OTP` token очно"
    authResetPassword(
        "Parameters for authResetPassword"
        input: authResetPasswordInput!
    ): String
    "sms болон mail ээр ирсэн otp г хүчинтэй эсэхийг лавлана"
    authValidateOtp(
        "Parameters for authValidateOTP"
        input: authValidateOTPInput!
    ): Boolean
    batchUpdateVariants(
        "Parameters for batchUpdateVariants"
        input: batchUpdateVariantsInput!
    ): Product
    blackFridayPromotion(
        "Parameters for blackFridayPromotion"
        input: blackFridayPromotionInput!
    ): lotteryEntry
    cancelOrderTemplate(
        "Parameters for cancelOrderTemplate"
        input: cancelOrderTemplateInput!
    ): OrderTemplate
    changeItem(
        "Parameters for changeItem"
        input: changeItemInput!
    ): Order
    changeLoyaltyCardPassword(
        "Parameters for changeLoyaltyCardPassword"
        input: changeLoyaltyCardPasswordInput!
    ): LoyaltyCard
    changeWalletPin(
        "Parameters for changeWalletPin"
        input: changeWalletPinInput!
    ): Wallet
    "Charge printed gift cards"
    chargeGiftCard(
        "Parameters for chargeGiftCard"
        input: chargeGiftCardInput!
    ): Order
    checkAlifPayCard(
        "Parameters for checkAlifPayCard"
        input: checkAlifPayCardInput!
    ): Boolean
    checkGolomtCardPassword(
        "Parameters for checkGolomtCardPassword"
        input: checkGolomtCardPasswordInput!
    ): JSON
    checkIntendUser(
        "Parameters for checkIntendUser"
        input: checkIntendUserInput!
    ): Boolean
    checkLoyaltyCardInfo(
        "Parameters for checkLoyaltyCardInfo"
        input: checkLoyaltyCardInfoInput!
    ): JSON
    checkMobile(
        "Parameters for checkMobile"
        input: checkMobileInput!
    ): Boolean
    checkPayment(
        "Parameters for checkPayment"
        input: checkPaymentInput!
    ): Payment
    checkPosStageTicket(
        "Parameters for checkPosStageTicket"
        input: checkPosStageTicketInput!
    ): JSON
    checkSegmentWhiteList(
        "Parameters for checkSegmentWhiteList"
        input: checkSegmentWhiteListInput!
    ): Boolean
    christmasSlotPromotion(
        "Parameters for christmasSlotPromotion"
        input: christmasSlotPromotionInput!
    ): lotteryEntry
    claimGift(
        "Parameters for claimGift"
        input: claimGiftInput!
    ): Order
    claimPromotion(
        "Parameters for claimPromotion"
        input: claimPromotionInput!
    ): JSON
    clearViewTrack(
        "Parameters for clearViewTrack"
        input: clearViewTrackInput!
    ): Boolean
    clearWish(
        "Parameters for clearWish"
        input: clearWishInput!
    ): Wishlist
    collectOrder(
        "Parameters for collectOrder"
        input: collectOrderInput!
    ): Collect
    confirmAlifPayCharge(
        "Parameters for confirmAlifPayCharge"
        input: confirmAlifPayChargeInput!
    ): Boolean
    confirmGolomtVcc(
        "Parameters for confirmGolomtVCC"
        input: confirmGolomtVCCInput!
    ): JSON
    confirmIntendInvoice(
        "Parameters for confirmIntendInvoice"
        input: confirmIntendInvoiceInput!
    ): Boolean
    confirmMerchant(
        "Parameters for confirmMerchant"
        input: confirmMerchantInput!
    ): Merchant
    confirmPosStageTicket(
        "Parameters for confirmPosStageTicket"
        input: confirmPosStageTicketInput!
    ): JSON
    confirmPrescription(
        "Parameters for confirmPrescription"
        input: confirmPrescriptionInput!
    ): Prescription
    createAddress(
        "Parameters for createAddress"
        input: createAddressInput!
    ): Address
    createAssetRole(
        "Parameters for createAssetRole"
        input: createAssetRoleInput!
    ): AssetRole
    createBranch(
        "Parameters for createBranch"
        input: createBranchInput!
    ): Branch
    createCampaign(
        "Parameters for createCampaign"
        input: createCampaignInput!
    ): ShoppyCampaign
    createCard(
        "Parameters for createCard"
        input: createCardInput!
    ): Card
    "Create chat room"
    createChatRoom(
        "Parameters for createChatRoom"
        input: createChatRoomInput!
    ): Room
    createEMailContact(
        "Parameters for createEMailContact"
        input: createEMailContactInput!
    ): Contact
    createForm(
        "Parameters for createForm"
        input: createFormInput!
    ): ShoppyForm
    createLease(
        "Parameters for createLease"
        input: createLeaseInput!
    ): User
    createListings(
        "Parameters for createListings"
        input: createListingsInput!
    ): Boolean
    createLoyaltyCard(
        "Parameters for createLoyaltyCard"
        input: createLoyaltyCardInput!
    ): LoyaltyCard
    createOptionValueImage(
        "Parameters for createOptionValueImage"
        input: createOptionValueImageInput!
    ): ProductImage
    createOrUpdateStoreListing(
        "Parameters for createOrUpdateStoreListing"
        input: createOrUpdateStoreListingInput!
    ): [StoreListing!]
    "Create new order for web, pos channels"
    createOrder(
        "Parameters for CreateOrder"
        input: CreateOrderInput!
    ): Order
    createOrderTemplate(
        "Parameters for createOrderTemplate"
        input: createOrderTemplateInput!
    ): OrderTemplate
    createOrderTemplateFromOrder(
        "Parameters for createOrderTemplateFromOrder"
        input: createOrderTemplateFromOrderInput!
    ): OrderTemplate
    createPoll(
        "Parameters for createPoll"
        input: createPollInput!
    ): Poll
    createPrescription(
        "Parameters for createPrescription"
        input: createPrescriptionInput!
    ): Prescription
    createProduct(
        "Parameters for createProduct"
        input: createProductInput!
    ): Product
    createPushTemplate(
        "Parameters for createPushTemplate"
        input: createPushTemplateInput!
    ): PushTemplate
    createReport(
        "Parameters for createReport"
        input: createReportInput!
    ): Boolean
    createReportReason(
        "Parameters for createReportReason"
        input: createReportReasonInput!
    ): ReportReason
    createReview(
        "Parameters for createReview"
        input: createReviewInput!
    ): Review
    createSalePrice(
        "Parameters for createSalePrice"
        input: createSalePriceInput!
    ): SalePrice
    createShipper(
        "Parameters for createShipper"
        input: createShipperInput!
    ): Shipper
    createShoppyImage(
        "Parameters for createShoppyImage"
        input: createShoppyImageInput!
    ): Image
    createStockLocation(
        "Parameters for createStockLocation"
        input: createStockLocationInput!
    ): StockLocation
    createTecAlliancePrices(
        "Parameters for createTecAlliancePrices"
        input: createTecAlliancePricesInput!
    ): JSON
    createTracking(
        "Parameters for createTracking"
        input: createTrackingInput!
    ): TrackingType
    createUPointCard(
        "Parameters for createUPointCard"
        input: createUPointCardInput!
    ): UPointCard
    createUserAddress(
        "Parameters for createUserAddress"
        input: createUserAddressInput!
    ): UserAddress
    createUserArticle(
        "Parameters for createUserArticle"
        input: createUserArticleInput!
    ): UserArticle
    createVariant(
        "Parameters for createVariant"
        input: createVariantInput!
    ): Variant
    createVariantImage(
        "Parameters for createVariantImage"
        input: createVariantImageInput!
    ): ProductImage
    createVendor(
        "Parameters for createVendor"
        input: createVendorInput!
    ): Vendor
    createWishlist(
        "Parameters for createWishlist"
        input: createWishlistInput!
    ): Wishlist
    deactivateCard(
        "Parameters for deactivateCard"
        input: deactivateCardInput!
    ): Card
    deactivateVoucher(
        "Parameters for deactivateVoucher"
        input: deactivateVoucherInput!
    ): Order
    "Remove employee role from asset"
    destroyAssetRole(
        "Parameters for destroyAssetRole"
        input: destroyAssetRoleInput!
    ): AssetRole
    "Destroy a bank account of user"
    destroyBankAccount(
        "Parameters for destroyBankAccount"
        input: destroyBankAccountInput!
    ): Bank
    destroyBatchVariants(
        "Parameters for destroyBatchVariants"
        input: destroyBatchVariantsInput!
    ): Product
    destroyBranch(
        "Parameters for destroyBranch"
        input: destroyBranchInput!
    ): Branch
    destroyDepartmentStore(
        "Parameters for destroyDepartmentStore"
        input: destroyDepartmentStoreInput!
    ): DepartmentStore
    "Remove employee from business"
    destroyEmployee(
        "Parameters for destroyEmployee"
        input: destroyEmployeeInput!
    ): Employee
    destroyFeedbackTopic(
        "Parameters for destroyFeedbackTopic"
        input: destroyFeedbackTopicInput!
    ): FeedbackTopic
    destroyForm(
        "Parameters for destroyForm"
        input: destroyFormInput!
    ): ShoppyForm
    destroyLineItem(
        "Parameters for destroyLineItem"
        input: destroyLineItemInput!
    ): LineItem
    destroyListings(
        "Parameters for destroyListings"
        input: destroyListingsInput!
    ): Boolean
    destroyMerchant(
        "Parameters for destroyMerchant"
        input: destroyMerchantInput!
    ): Merchant
    destroyOrderTemplate(
        "Parameters for destroyOrderTemplate"
        input: destroyOrderTemplateInput!
    ): OrderTemplate
    destroyPoll(
        "Parameters for destroyPoll"
        input: destroyPollInput!
    ): Poll
    destroyProductImage(
        "Parameters for destroyProductImage"
        input: destroyProductImageInput!
    ): ProductImage
    destroyProductOptionValueImage(
        "Parameters for destroyProductOptionValueImage"
        input: destroyProductOptionValueImageInput!
    ): ProductImage
    destroyPushTemplate(
        "Parameters for destroyPushTemplate"
        input: destroyPushTemplateInput!
    ): PushTemplate
    destroyReview(
        "Parameters for destroyReview"
        input: destroyReviewInput!
    ): Review
    destroyReviews(
        "Parameters for destroyReviews"
        input: destroyReviewsInput!
    ): Boolean
    destroySalePrice(
        "Parameters for destroySalePrice"
        input: destroySalePriceInput!
    ): SalePrice
    destroySavedCard(
        "Parameters for destroySavedCard"
        input: destroySavedCardInput!
    ): Boolean
    destroyShipper(
        "Parameters for destroyShipper"
        input: destroyShipperInput!
    ): Shipper
    destroyShoppyImage(
        "Parameters for destroyShoppyImage"
        input: destroyShoppyImageInput!
    ): Image
    destroyStockItem(
        "Parameters for destroyStockItem"
        input: destroyStockItemInput!
    ): StockItem
    destroyStockLocation(
        "Parameters for destroyStockLocation"
        input: destroyStockLocationInput!
    ): StockLocation
    destroyStoreListing(
        "Parameters for destroyStoreListing"
        input: destroyStoreListingInput!
    ): Boolean
    destroyUserAddress(
        "Parameters for destroyUserAddress"
        input: destroyUserAddressInput!
    ): UserAddress
    destroyUserArticle(
        "Parameters for destroyUserArticle"
        input: destroyUserArticleInput!
    ): Boolean
    destroyVariant(
        "Parameters for destroyVariant"
        input: destroyVariantInput!
    ): Boolean
    "Can remove wishlist with wishedProductId or wishlistId + variantId"
    destroyWish(
        "Parameters for destroyWish"
        input: destroyWishInput!
    ): WishedProduct
    destroyWishlist(
        "Parameters for destroyWishlist"
        input: destroyWishlistInput!
    ): Wishlist
    "Disable current user"
    disableCurrentUser(
        "Parameters for disableCurrentUser"
        input: disableCurrentUserInput!
    ): User
    disableTotp(
        "Parameters for disableTotp"
        input: disableTotpInput!
    ): User
    emptyCart(
        "Parameters for emptyCart"
        input: emptyCartInput!
    ): Order
    enableTotp(
        "Parameters for enableTotp"
        input: enableTotpInput!
    ): User
    eventBuy(
        "Parameters for eventBuy"
        input: eventBuyInput!
    ): Boolean
    generateLoyaltyCardQr(
        "Parameters for generateLoyaltyCardQr"
        input: generateLoyaltyCardQrInput!
    ): JSON
    generateUserTokenQr(
        "Parameters for generateUserTokenQr"
        input: generateUserTokenQrInput!
    ): UserToken
    generateVariants(
        "Parameters for generateVariants"
        input: generateVariantsInput!
    ): Product
    golomtOtp(
        "Parameters for golomtOTP"
        input: golomtOTPInput!
    ): JSON
    halloweenPromotion(
        "Parameters for halloweenPromotion"
        input: halloweenPromotionInput!
    ): lotteryEntry
    handleCartItem(
        "Parameters for HandleCartItem"
        input: HandleCartItemInput!
    ): LineItem
    imageSearch(
        "Parameters for imageSearch"
        input: imageSearchInput!
    ): JSON
    importShoppyImages(
        "Parameters for importShoppyImages"
        input: importShoppyImagesInput!
    ): [Image!]
    inviteEmployee(
        "Parameters for inviteEmployee"
        input: inviteEmployeeInput!
    ): Employee
    inviteMerchant(
        "Parameters for inviteMerchant"
        input: inviteMerchantInput!
    ): Merchant
    joinBusiness(
        "Parameters for joinBusiness"
        input: joinBusinessInput!
    ): Employee
    leaseAcceptTerm(
        "Parameters for leaseAcceptTerm"
        input: leaseAcceptTermInput!
    ): Boolean
    leaseCancel(
        "Parameters for leaseCancel"
        input: leaseCancelInput!
    ): Boolean
    leaseChangeName(
        "Parameters for leaseChangeName"
        input: leaseChangeNameInput!
    ): Boolean
    leaseComplete(
        "Parameters for leaseComplete"
        input: leaseCompleteInput!
    ): Order
    leaseCompleteFix(
        "Parameters for leaseCompleteFix"
        input: leaseCompleteFixInput!
    ): User
    leaseDeclineTerm(
        "Parameters for leaseDeclineTerm"
        input: leaseDeclineTermInput!
    ): Boolean
    leaseMakeNormal(
        "Parameters for leaseMakeNormal"
        input: leaseMakeNormalInput!
    ): Boolean
    leaseUpdateAddress(
        "Parameters for leaseUpdateAddress"
        input: leaseUpdateAddressInput!
    ): User
    leaseUpdateEducation(
        "Parameters for leaseUpdateEducation"
        input: leaseUpdateEducationInput!
    ): UserEducation
    leaseUpdateEmergency(
        "Parameters for leaseUpdateEmergency"
        input: leaseUpdateEmergencyInput!
    ): [EmergencyContact!]
    leaseUpdateEmployment(
        "Parameters for leaseUpdateEmployment"
        input: leaseUpdateEmploymentInput!
    ): UserEmployment
    leaseUpdateFinance(
        "Parameters for leaseUpdateFinance"
        input: leaseUpdateFinanceInput!
    ): UserFinance
    leaseUploadPassport(
        "Parameters for leaseUploadPassport"
        input: leaseUploadPassportInput!
    ): Boolean
    "Leave chat room"
    leaveChatRoom(
        "Parameters for leaveChatRoom"
        input: leaveChatRoomInput!
    ): Room
    linkDevice(
        "Parameters for linkDevice"
        input: linkDeviceInput!
    ): Device
    mcsCheckRegister(
        "Parameters for mcsCheckRegister"
        input: mcsCheckRegisterInput!
    ): JSON
    mcsRegister(
        "Parameters for mcsRegister"
        input: mcsRegisterInput!
    ): JSON
    mcsResetPassword(
        "Parameters for mcsResetPassword"
        input: mcsResetPasswordInput!
    ): Boolean
    mcsSignup(
        "Parameters for mcsSignup"
        input: mcsSignupInput!
    ): JSON
    mcsVerify(
        "Parameters for mcsVerify"
        input: mcsVerifyInput!
    ): JSON
    "Payment for completed orders"
    orderPay(
        "Parameters for orderPay"
        input: orderPayInput!
    ): JSON
    passCoupon(
        "Parameters for passCoupon"
        input: passCouponInput!
    ): Coupon
    passETicket(
        "Parameters for passETicket"
        input: passETicketInput!
    ): ETicket
    payCargoPrice(
        "Parameters for payCargoPrice"
        input: payCargoPriceInput!
    ): Order
    "call payment method on current order"
    paymentAction(
        "Parameters for paymentAction"
        input: paymentActionInput!
    ): JSON
    performId1(
        "Parameters for performId1"
        input: performId1Input!
    ): User
    performLineItemAction(
        "Parameters for performLineItemAction"
        input: performLineItemActionInput!
    ): LineItem
    performOrderAction(
        "Parameters for performOrderAction"
        input: performOrderActionInput!
    ): Order
    quickBuy(
        "Parameters for quickBuy"
        input: quickBuyInput!
    ): Order
    readAllNotification(
        "Parameters for readAllNotification"
        input: readAllNotificationInput!
    ): Boolean
    readNotification(
        "Parameters for readNotification"
        input: readNotificationInput!
    ): Notification
    readyShipment(
        "Parameters for readyShipment"
        input: readyShipmentInput!
    ): Shipment
    receivePreorderShipment(
        "Parameters for receivePreorderShipment"
        input: receivePreorderShipmentInput!
    ): Shipment
    refreshOrderTrackings(
        "Parameters for refreshOrderTrackings"
        input: refreshOrderTrackingsInput!
    ): Boolean
    registerQPayCard(
        "Parameters for registerQPayCard"
        input: registerQPayCardInput!
    ): JSON
    removeCampaignList(
        "Parameters for removeCampaignList"
        input: removeCampaignListInput!
    ): CampaignListing
    "Remove chat message"
    removeChatMessage(
        "Parameters for removeChatMessage"
        input: removeChatMessageInput!
    ): Boolean
    removePrescription(
        "Parameters for removePrescription"
        input: removePrescriptionInput!
    ): Prescription
    removePrescriptionItem(
        "Parameters for removePrescriptionItem"
        input: removePrescriptionItemInput!
    ): PrescriptionItem
    removeViewTrack(
        "Parameters for removeViewTrack"
        input: removeViewTrackInput!
    ): Boolean
    requestCardOtp(
        "Parameters for requestCardOtp"
        input: requestCardOtpInput!
    ): Boolean
    requestGolomtVcc(
        "Parameters for requestGolomtVCC"
        input: requestGolomtVCCInput!
    ): JSON
    "Generate OTP Token to user mobile"
    requestListingOtp(
        "Parameters for requestListingOTP"
        input: requestListingOTPInput!
    ): Listing
    requestMerchant(
        "Parameters for requestMerchant"
        input: requestMerchantInput!
    ): Merchant
    requestPaymentReturn(
        "Parameters for requestPaymentReturn"
        input: requestPaymentReturnInput!
    ): PaymentReturn
    resendGiftCard(
        "Parameters for resendGiftCard"
        input: resendGiftCardInput!
    ): GiftCard
    resendIntendSms(
        "Parameters for resendIntendSms"
        input: resendIntendSmsInput!
    ): Boolean
    resendShipmentTracking(
        "Parameters for resendShipmentTracking"
        input: resendShipmentTrackingInput!
    ): Order
    reviewDriver(
        "Parameters for reviewDriver"
        input: reviewDriverInput!
    ): Review
    searchAddress(
        "Parameters for searchAddress"
        input: searchAddressInput!
    ): JSON
    "Mark as seen in chat room"
    seenChatMessage(
        "Parameters for seenChatMessage"
        input: seenChatMessageInput!
    ): Room
    selectPrescriptionItem(
        "Parameters for selectPrescriptionItem"
        input: selectPrescriptionItemInput!
    ): PrescriptionItem
    sendChangeLoyaltyCardPasswordOtp(
        "Parameters for sendChangeLoyaltyCardPasswordOtp"
        input: sendChangeLoyaltyCardPasswordOtpInput!
    ): JSON
    "Send message to chat room"
    sendChatMessage(
        "Parameters for sendChatMessage"
        input: sendChatMessageInput!
    ): Message
    sendCoupon(
        "Parameters for sendCoupon"
        input: sendCouponInput!
    ): Coupon
    sendCreateLoyaltyCardOtp(
        "Parameters for sendCreateLoyaltyCardOtp"
        input: sendCreateLoyaltyCardOtpInput!
    ): JSON
    sendErpLoyaltyRequest(
        "Parameters for SendErpLoyaltyRequest"
        input: SendErpLoyaltyRequestInput!
    ): JSON
    "Send invoice of order via Email"
    sendInvoice(
        "Parameters for sendInvoice"
        input: sendInvoiceInput!
    ): Boolean
    sendInvoiceNotification(
        "Parameters for sendInvoiceNotification"
        input: sendInvoiceNotificationInput!
    ): Boolean
    sendJobApplicationEmail(
        "Parameters for sendJobApplicationEmail"
        input: sendJobApplicationEmailInput!
    ): Boolean
    sendNotification(
        "Parameters for sendNotification"
        input: sendNotificationInput!
    ): Boolean
    sendUserTokenQr(
        "Parameters for sendUserTokenQr"
        input: sendUserTokenQrInput!
    ): UserToken
    setAvailability(
        "Parameters for setAvailability"
        input: setAvailabilityInput!
    ): TrackableType
    setGolomtCardPassword(
        "Parameters for setGolomtCardPassword"
        input: setGolomtCardPasswordInput!
    ): JSON
    shipShipment(
        "Parameters for shipShipment"
        input: shipShipmentInput!
    ): Shipment
    shoppyBox(
        "Parameters for shoppyBox"
        input: shoppyBoxInput!
    ): eventEntry
    shoppyhubPromotion(
        "Parameters for shoppyhubPromotion"
        input: shoppyhubPromotionInput!
    ): lotteryEntry
    submitAnswer(
        "Parameters for submitAnswer"
        input: submitAnswerInput!
    ): QuizResult
    submitForm(
        "Parameters for submitForm"
        input: submitFormInput!
    ): ShoppyForm
    swapOrderDriver(
        "Parameters for swapOrderDriver"
        input: swapOrderDriverInput!
    ): Order
    syncListings(
        "Parameters for syncListings"
        input: syncListingsInput!
    ): Boolean
    syncListingsSeo(
        "Parameters for syncListingsSeo"
        input: syncListingsSeoInput!
    ): Boolean
    syncReport(
        "Parameters for syncReport"
        input: syncReportInput!
    ): Boolean
    toggleFollow(
        "Parameters for toggleFollow"
        input: toggleFollowInput!
    ): Follow
    toggleWish(
        "Parameters for toggleWish"
        input: toggleWishInput!
    ): Wishlist
    topUpGiftCard(
        "Parameters for topUpGiftCard"
        input: topUpGiftCardInput!
    ): GiftCard
    transferShipment(
        "Parameters for transferShipment"
        input: transferShipmentInput!
    ): Shipment
    unlockWalletPin(
        "Parameters for unlockWalletPin"
        input: unlockWalletPinInput!
    ): Wallet
    updateAddress(
        "Parameters for updateAddress"
        input: updateAddressInput!
    ): Address
    updateAfterPay(
        "Parameters for updateAfterPay"
        input: updateAfterPayInput!
    ): Merchant
    updateAssetRole(
        "Parameters for updateAssetRole"
        input: updateAssetRoleInput!
    ): AssetRole
    updateAssetRoleBatch(
        "Parameters for updateAssetRoleBatch"
        input: updateAssetRoleBatchInput!
    ): [AssetRole!]
    updateAvatar(
        "Parameters for updateAvatar"
        input: updateAvatarInput!
    ): User
    "Update a bank account of user"
    updateBankAccount(
        "Parameters for updateBankAccount"
        input: updateBankAccountInput!
    ): Bank
    updateBranch(
        "Parameters for updateBranch"
        input: updateBranchInput!
    ): Branch
    updateBtobOrderTemplate(
        "Parameters for updateBtobOrderTemplate"
        input: updateBtobOrderTemplateInput!
    ): OrderTemplate
    updateCampaign(
        "Parameters for updateCampaign"
        input: updateCampaignInput!
    ): ShoppyCampaign
    updateCampaignList(
        "Parameters for updateCampaignList"
        input: updateCampaignListInput!
    ): CampaignListing
    updateCard(
        "Parameters for updateCard"
        input: updateCardInput!
    ): Card
    updateChannel(
        "Parameters for updateChannel"
        input: updateChannelInput!
    ): Cinema
    "update order to address/delivery step"
    updateCheckoutOrder(
        "Parameters for updateCheckoutOrder"
        input: updateCheckoutOrderInput!
    ): Order
    "update order in manual order"
    updateCompleteOrder(
        "Parameters for updateCompleteOrder"
        input: updateCompleteOrderInput!
    ): Order
    updateEmployee(
        "Parameters for updateEmployee"
        input: updateEmployeeInput!
    ): Employee
    updateFeedback(
        "Parameters for updateFeedback"
        input: updateFeedbackInput!
    ): FeedbackType
    updateFeedbackTopic(
        "Parameters for updateFeedbackTopic"
        input: updateFeedbackTopicInput!
    ): FeedbackTopic
    updateForm(
        "Parameters for updateForm"
        input: updateFormInput!
    ): ShoppyForm
    updateFormEntry(
        "Parameters for updateFormEntry"
        input: updateFormEntryInput!
    ): ShoppyFormEntry
    updateItem(
        "Parameters for updateItem"
        input: updateItemInput!
    ): Order
    updateKyc(
        "Parameters for updateKyc"
        input: updateKycInput!
    ): User
    updateKycGolomt(
        "Parameters for updateKycGolomt"
        input: updateKycGolomtInput!
    ): GolomtKYC
    updateListing(
        "Parameters for updateListing"
        input: updateListingInput!
    ): Listing
    updateListingBatch(
        "Parameters for updateListingBatch"
        input: updateListingBatchInput!
    ): Boolean
    updateListingEs(
        "Parameters for updateListingES"
        input: updateListingESInput!
    ): Boolean
    "Update options for specific listings"
    updateListingOptions(
        "Parameters for updateListingOptions"
        input: updateListingOptionsInput!
    ): Listing
    "Change user email address or mobile number"
    updateLogin(
        "Parameters for updateLogin"
        input: updateLoginInput!
    ): User
    "Update mass chat message"
    updateMassChatMessage(
        "Parameters for updateMassChatMessage"
        input: updateMassChatMessageInput!
    ): MassMessage
    updateMerchant(
        "Parameters for updateMerchant"
        input: updateMerchantInput!
    ): Merchant
    updateOrder(
        "Parameters for updateOrder"
        input: updateOrderInput!
    ): Order
    updateOrderTemplate(
        "Parameters for updateOrderTemplate"
        input: updateOrderTemplateInput!
    ): OrderTemplate
    updatePoll(
        "Parameters for updatePoll"
        input: updatePollInput!
    ): Poll
    updatePositionOptionValueImage(
        "Parameters for updatePositionOptionValueImage"
        input: updatePositionOptionValueImageInput!
    ): ProductOptionValue
    updatePositionSalePrices(
        "Parameters for updatePositionSalePrices"
        input: updatePositionSalePricesInput!
    ): Variant
    updatePositionVariantImage(
        "Parameters for updatePositionVariantImage"
        input: updatePositionVariantImageInput!
    ): Variant
    updatePrescription(
        "Parameters for updatePrescription"
        input: updatePrescriptionInput!
    ): Prescription
    updatePrescriptionItem(
        "Parameters for updatePrescriptionItem"
        input: updatePrescriptionItemInput!
    ): PrescriptionItem
    updateProduct(
        "Parameters for updateProduct"
        input: updateProductInput!
    ): Product
    updatePushTemplate(
        "Parameters for updatePushTemplate"
        input: updatePushTemplateInput!
    ): PushTemplate
    updateReportReason(
        "Parameters for updateReportReason"
        input: updateReportReasonInput!
    ): ReportReason
    "Update sale for specific listings"
    updateSaleListing(
        "Parameters for updateSaleListing"
        input: updateSaleListingInput!
    ): [Listing!]
    updateSalePrice(
        "Parameters for updateSalePrice"
        input: updateSalePriceInput!
    ): SalePrice
    updateShipmentTracking(
        "Parameters for updateShipmentTracking"
        input: updateShipmentTrackingInput!
    ): Boolean
    updateShipper(
        "Parameters for updateShipper"
        input: updateShipperInput!
    ): Shipper
    updateStockItem(
        "Parameters for updateStockItem"
        input: updateStockItemInput!
    ): StockItem
    updateStockLocation(
        "Parameters for updateStockLocation"
        input: updateStockLocationInput!
    ): StockLocation
    updateUserAddress(
        "Parameters for updateUserAddress"
        input: updateUserAddressInput!
    ): UserAddress
    updateUserClearance(
        "Parameters for updateUserClearance"
        input: updateUserClearanceInput!
    ): User
    updateUserProfile(
        "Parameters for updateUserProfile"
        input: updateUserProfileInput!
    ): User
    updateVariant(
        "Parameters for updateVariant"
        input: updateVariantInput!
    ): Variant
    updateVendor(
        "Parameters for updateVendor"
        input: updateVendorInput!
    ): Vendor
    updateVendorLogo(
        "Parameters for updateVendorLogo"
        input: updateVendorLogoInput!
    ): Vendor
    updateWishedProduct(
        "Parameters for updateWishedProduct"
        input: updateWishedProductInput!
    ): WishedProduct
    updateWishlist(
        "Parameters for updateWishlist"
        input: updateWishlistInput!
    ): Wishlist
    uploadSegmentWhiteList(
        "Parameters for uploadSegmentWhiteList"
        input: uploadSegmentWhiteListInput!
    ): SegmentWhiteListReport
    useCoupon(
        "Parameters for useCoupon"
        input: useCouponInput!
    ): Coupon
    useGiftCard(
        "Parameters for useGiftCard"
        input: useGiftCardInput!
    ): GiftCard
    useLoyaltyCard(
        "Parameters for useLoyaltyCard"
        input: useLoyaltyCardInput!
    ): Order
    useStoreCredit(
        "Parameters for useStoreCredit"
        input: useStoreCreditInput!
    ): Order
    useStoreCreditById(
        "Parameters for useStoreCreditByID"
        input: useStoreCreditByIDInput!
    ): Order
    useUPointCard(
        "Parameters for useUPointCard"
        input: useUPointCardInput!
    ): Order
    useUserTokenQr(
        "Parameters for useUserTokenQr"
        input: useUserTokenQrInput!
    ): UserToken
    useVoucher(
        "Parameters for useVoucher"
        input: useVoucherInput!
    ): Order
    validateApplePayMerchant(
        "Parameters for validateApplePayMerchant"
        input: validateApplePayMerchantInput!
    ): JSON
    verifyCard(
        "Parameters for verifyCard"
        input: verifyCardInput!
    ): Card
    verifyEMongolia(
        "Parameters for verifyEMongolia"
        input: verifyEMongoliaInput!
    ): String
    verifyLogin(
        "Parameters for verifyLogin"
        input: verifyLoginInput!
    ): User
    verifyMnCitizenIdentity(
        "Parameters for verifyMnCitizenIdentity"
        input: verifyMnCitizenIdentityInput!
    ): MnCitizenIdentity
    viewTrack(
        "Parameters for viewTrack"
        input: viewTrackInput!
    ): RecentlyViewedListing
}

type NetCapitalInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    contractNo: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    payday: String
    phone: String
    tanCode: String
    term: String
    updatedAt: ISO8601DateTime!
}

type News implements BaseModelInterface & Node {
    active: Boolean
    author: User
    body: String
    canI(action: CanIAction!): Boolean!
    cat: String
    cover: JSON
    createdAt: ISO8601DateTime!
    data: JSON
    gid: ID!
    id: ID!
    impressionsCount: Int
    tagList: [String!]!
    tags: [Tag!]!
    thumbnail: JSON
    title: String
    updatedAt: ISO8601DateTime!
}

"The connection type for News."
type NewsConnection {
    "A list of edges."
    edges: [NewsEdge!]!
    "A list of nodes."
    nodes: [News!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type NewsEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: News!
}

type Notice implements BaseModelInterface & Node {
    body: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    expireAt: ISO8601DateTime
    gid: ID!
    id: ID!
    link: String
    linkName: String
    path: String
    position: Int
    startAt: ISO8601DateTime
    title: String
    updatedAt: ISO8601DateTime!
    website: Website
}

"The connection type for Notice."
type NoticeConnection {
    "A list of edges."
    edges: [NoticeEdge!]!
    "A list of nodes."
    nodes: [Notice!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type NoticeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Notice!
}

type Notification implements BaseModelInterface & Node {
    activityType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    isRead: Boolean
    record: NotificationObject
    sender: NotificationSender
    title: String
    updatedAt: ISO8601DateTime!
    user: User
    website: Website
}

"The connection type for Notification."
type NotificationConnection {
    "A list of edges."
    edges: [NotificationEdge!]!
    "A list of nodes."
    nodes: [Notification!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type NotificationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Notification!
}

type NumurInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    transNumber: String
    updatedAt: ISO8601DateTime!
}

type NutritionFact implements BaseModelInterface & Node {
    altMeasures: JSON
    brand: String
    canI(action: CanIAction!): Boolean!
    code: String
    createdAt: ISO8601DateTime!
    fullNutrients: JSON
    gid: ID!
    id: ID!
    name: String
    nfCalories: Float
    nfCholesterol: Float
    nfDietaryFiber: Float
    nfP: Float
    nfPotassium: Float
    nfProtein: Float
    nfSaturatedFat: Float
    nfSodium: Float
    nfSugars: Float
    nfTotalCarbohydrate: Float
    nfTotalFat: Float
    servingQty: Float
    servingUnit: String
    servingWeightGrams: Float
    updatedAt: ISO8601DateTime!
    vendor: Vendor
}

"The connection type for NutritionFact."
type NutritionFactConnection {
    "A list of edges."
    edges: [NutritionFactEdge!]!
    "A list of nodes."
    nodes: [NutritionFact!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type NutritionFactEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: NutritionFact!
}

type OmniwayInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    qrContent: String
    qrImage: String
    updatedAt: ISO8601DateTime!
}

type OneSignalNotification implements BaseModelInterface & Node {
    appUrl: String
    canI(action: CanIAction!): Boolean!
    contents: JSON
    createdAt: ISO8601DateTime!
    deliveryType: String
    gid: ID!
    headings: JSON
    id: ID!
    image: String
    sendAfter: ISO8601DateTime
    status: String
    updatedAt: ISO8601DateTime!
    webUrl: String
}

type OneUsePerUser implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredPerUserLimit: Int
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type OptionType implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String!
    "Returns list of option values"
    optionValues(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OptionValueFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): OptionValueConnection!
    position: Int!
    presentation: String
    updatedAt: ISO8601DateTime!
}

"The connection type for OptionType."
type OptionTypeConnection {
    "A list of edges."
    edges: [OptionTypeEdge!]!
    "A list of nodes."
    nodes: [OptionType!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type OptionTypeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: OptionType!
}

type OptionValue implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String!
    optionType: OptionType!
    optionTypeId: ID!
    position: Int
    presentation: String
    updatedAt: ISO8601DateTime!
}

"The connection type for OptionValue."
type OptionValueConnection {
    "A list of edges."
    edges: [OptionValueEdge!]!
    "A list of nodes."
    nodes: [OptionValue!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type OptionValueEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: OptionValue!
}

"Represents Order object"
type Order implements BaseModelInterface & Node & PaymentSourceInterface {
    additionalTaxTotal: Float
    adjustmentTotal: Float!
    adjustments: [Adjustment!]!
    alertSentAt: ISO8601DateTime
    alibabaOrders: [AlibabaOrder!]!
    allAdjustments: [Adjustment!]!
    approvedAt: ISO8601DateTime
    approvedOrder: Order
    approvedOrderId: ID
    approver: User
    archived: Boolean!
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    billAddress: Address
    branch: Branch
    canI(action: CanIAction!): Boolean!
    canPurchase: Boolean!
    cancelNote: String
    cancelReason: CancelReason
    canceledAt: ISO8601DateTime
    canceler: User
    cancellable: Boolean!
    cargoFee: Float
    categoryId: ID
    channel: String
    "chat room of order"
    chatRoom: Room
    clientsStore: ClientsStore
    collect: Collect
    collectStartedAt: ISO8601DateTime
    comments: [OrderComment!]!
    completedAt: ISO8601DateTime
    confirmationDelivered: Boolean
    consideredRisky: Boolean
    containsFragile: Boolean
    contractStatus: Int
    createdAt: ISO8601DateTime!
    createdBy: User
    creditOwed: Float
    currency: String
    deliveryLocation: String
    deliverySignature: [String!]
    deliveryStatusTut: [JSON!]
    digital: Boolean!
    dispatches: [Dispatch!]!
    displayAdjustmentTotal: String
    displayItemTotal: String!
    displayPromoTotal: String!
    displayShipTotal: String!
    displayTaxTotal: String!
    displayTotal: String!
    distance: Float
    driver: User
    driverCode: String
    driverShippingAt: ISO8601DateTime
    driverTakenAt: ISO8601DateTime
    driverUrl: String
    dropship: Boolean!
    ebarimt: Boolean
    ebarimtId: String
    ebarimtLogs: [Log!]!
    editable: Boolean!
    email: String
    extraData: JSON
    feedbacks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FeedbackFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FeedbackTypeConnection!
    flag: String
    flaggedAt: ISO8601DateTime
    flaggedBy: User
    gid: ID!
    giftOrigin: JSON
    id: ID!
    images: [ProductImage!]!
    includedTaxTotal: Float!
    initialTotal: Float
    integrationReports(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: IntegrationReportFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): IntegrationReportConnection!
    isBuyer: Boolean!
    isGreen: Boolean!
    isSeller: Boolean!
    itemCount: Int
    itemTotal: Float!
    key: String
    khanId: String
    lastIpAddress: String
    latestNote: String
    leaseBank: Float
    leaseDownPayment: Float
    leaseLeft: Float
    leaseSource: TdbmLeaseSource
    leaseState: String
    leasingContract: DigitalContract
    lineItems: [LineItem!]!
    "Returns list of line items owned by parent vendor"
    lineItemsAd(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        excludeBankPending: Boolean,
        filter: LineItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        ready: Boolean,
        reportType: String,
        "Sorting functionality"
        sort: SortFilter
    ): LineItemConnection
    "Line items. Warning: uses up a lot of complexity "
    lineItemsResolved(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: LineItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): LineItemConnection
    localShippingFee: Float
    nonTaxableAdjustmentTotal: Float
    notes: Int
    number: String!
    outstandingBalance: Float!
    package: DeliveryPackage
    packages: [DeliveryPackage!]!
    paidAt: ISO8601DateTime
    parcels: [Parcel!]!
    payment: String
    paymentAccountData: JSON
    paymentDataByMethod: JSON
    paymentReturns: [PaymentReturn!]!
    paymentState: String
    paymentTotal: Float!
    paymentTypes: [String!]!
    payments: [Payment!]!
    pickPackAt: ISO8601DateTime
    pickPackBy: User
    pickPackCompletedAt: ISO8601DateTime
    pickPackNumber: Int
    pickPackOtp: String
    pickPackStatus: String
    pickPackTrackingNumber: String
    posData: JSON
    preferredShippingSlipData: JSON
    preorderDownPayment: Float!
    preorderState: String
    promoTotal: Float
    "Returns list of promotion action promises"
    promotionActionPromises(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PromotionActionPromiseFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        statuses: [String!]
    ): PromotionActionPromiseConnection!
    promotionIds: [ID!]!
    "Returns list of promotion action line items"
    promotionLineItems(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PromotionActionLineItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PromotionActionLineItemConnection!
    promotions: [Promotion!]!
    "Order invoice data"
    qPayInvoice: QPayInvoice
    readyCount: Int!
    registerNum: String
    segment: SupplySegment
    shipAddress: Address
    shipmentState: String
    shipmentTotal: Float!
    shipmentTrackings: [ShipmentTracking!]!
    shipments(
        "Shipper ID"
        shipperId: ID
    ): [Shipment!]!
    shippedAt: ISO8601DateTime
    shipperManifest: [ShipperManifest!]!
    shippingMethod: ShippingMethod
    shippingMethodNames: String
    "Returns list of shipping methods"
    shippingMethods(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShippingMethodFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShippingMethodConnection!
    shippingSlipTemplate: HandlebarTemplate
    sms: [Sms!]!
    specialInstructions: String
    state: String!
    stateChanges: [StateChange!]!
    stateLockVersion: Int!
    status: OrderStatusType!
    storeLocation: StoreLocation
    stores: [Brand!]!
    subOrders: [Order!]!
    supplierStockLocation: StockLocation
    takenItemsCount: Int
    taxTotal: Float
    taxableAdjustmentTotal: Float
    template: OrderTemplate
    templateId: ID
    token: String!
    total: Float!
    totalAfterStoreCredit: Float!
    totalAppliedStoreCredit: Float!
    totalAppliedWalletAmount: Float!
    totalAppliedWalletBonus: Float!
    totalPoint: Float
    totalQuantity: Int!
    transactionCount: Int
    transactions: [BankTransaction!]!
    tutLengthExceeded: Boolean
    tutTotalWeight: Float
    updatedAt: ISO8601DateTime!
    usableLoyaltyPoints: Float
    usableStoreCredit: Float
    useBilling: Boolean
    user: User
    userGeneratedUrl: String
    vatTotal: Float
    vendor: Vendor
    vendors: [Vendor!]!
    verified: Boolean
    waitUntil: ISO8601DateTime
    walletAmount: Float
    website: Website
    weight: Float
    whenToShip: ISO8601DateTime
}

type OrderComment implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    comment: String
    commentTypeId: ID
    commentable: OrderNotable
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    mentions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserConnection!
    title: String
    updatedAt: ISO8601DateTime!
    user: User
}

"The connection type for OrderComment."
type OrderCommentConnection {
    "A list of edges."
    edges: [OrderCommentEdge!]!
    "A list of nodes."
    nodes: [OrderComment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type OrderCommentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: OrderComment!
}

"The connection type for Order."
type OrderConnection {
    "A list of edges."
    edges: [OrderEdge!]!
    "A list of nodes."
    nodes: [Order!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type OrderEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Order!
}

type OrderReport implements BaseModelInterface & Node & PaymentSourceInterface {
    additionalTaxTotal: Float
    adjustmentFivePercent: Float
    adjustmentTotal: Float
    adjustments: [Adjustment!]!
    alertSentAt: ISO8601DateTime
    alibabaOrders: [AlibabaOrder!]!
    allAdjustments: [Adjustment!]!
    approvedAt: ISO8601DateTime
    approvedOrder: Order
    approvedOrderId: ID
    approver: User
    archived: Boolean!
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    availablePayments: JSON
    balanceDue: Float
    billAddress: Address
    branch: Branch
    canI(action: CanIAction!): Boolean!
    canPurchase: Boolean!
    cancelNote: String
    cancelReason: CancelReason
    canceledAt: ISO8601DateTime
    canceler: User
    cancellable: Boolean!
    cargoFee: Float
    categoryId: ID
    channel: String
    "chat room of order"
    chatRoom: Room
    clientsStore: ClientsStore
    collect: Collect
    collectStartedAt: ISO8601DateTime
    comments: [OrderComment!]!
    completedAt: ISO8601DateTime
    confirmationDelivered: Boolean
    consideredRisky: Boolean
    containsFragile: Boolean
    contractStatus: Int
    createdAt: ISO8601DateTime!
    createdBy: User
    creditOwed: Float
    currency: String
    deliveryLocation: String
    deliveryPhoto: [String!]!
    deliverySignature: [String!]!
    deliveryStatusTut: [JSON!]
    digital: Boolean!
    dispatches: [Dispatch!]!
    displayAdjustmentTotal: String
    displayItemTotal: String!
    displayPromoTotal: String!
    displayShipTotal: String!
    displayTaxTotal: String!
    displayTotal: String!
    distance: Float
    driver: User
    driverCode: String
    driverShippingAt: ISO8601DateTime
    driverTakenAt: ISO8601DateTime
    driverUrl: String
    dropship: Boolean!
    ebarimt: Boolean
    ebarimtId: String
    ebarimtLogs: [Log!]!
    editable: Boolean!
    email: String
    extraData: JSON
    feedbacks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FeedbackFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FeedbackTypeConnection!
    flag: String
    flaggedAt: ISO8601DateTime
    flaggedBy: User
    gid: ID!
    giftOrigin: JSON
    hasGiftCards: Boolean
    id: ID!
    images: [ProductImage!]!
    includedTaxTotal: Float!
    initialTotal: Float
    integrationReports(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: IntegrationReportFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): IntegrationReportConnection!
    isBuyer: Boolean!
    isGreen: Boolean!
    isSeller: Boolean!
    itemCount: Int
    itemTotal: Float!
    key: String
    khanId: String
    lastIpAddress: String
    latestNote: String
    leaseBank: Float
    leaseCommission: Float
    leaseDownPayment: Float
    leaseLeft: Float
    leaseSource: TdbmLeaseSource
    leaseState: String
    leasingContract: DigitalContract
    lineItems: [LineItem!]!
    "Returns list of line items owned by parent vendor"
    lineItemsAd(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        excludeBankPending: Boolean,
        filter: LineItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        ready: Boolean,
        reportType: String,
        "Sorting functionality"
        sort: SortFilter
    ): LineItemConnection
    "Line items. Warning: uses up a lot of complexity "
    lineItemsResolved(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: LineItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): LineItemConnection
    localShippingFee: Float
    nonTaxableAdjustmentTotal: Float
    notes: Int
    number: String!
    orderCount: Int
    outstandingBalance: Float!
    package: DeliveryPackage
    packages: [DeliveryPackage!]!
    paidAt: ISO8601DateTime
    parcels: [Parcel!]!
    payment: String
    paymentAccountData: JSON
    paymentDataByMethod: JSON
    paymentReferenceIds: JSON
    paymentReturns: [PaymentReturn!]!
    paymentState: String
    paymentTotal: Float!
    paymentTypes: [String!]!
    payments: [Payment!]!
    phoneComments: String
    pickPackAt: ISO8601DateTime
    pickPackBy: User
    pickPackCompletedAt: ISO8601DateTime
    pickPackNumber: Int
    pickPackOtp: String
    pickPackStatus: String
    pickPackTrackingNumber: String
    posData: JSON
    preferredShippingSlipData: JSON
    preorderDownPayment: Float!
    preorderState: String
    promoTotal: Float
    promotion: JSON
    "Returns list of promotion action promises"
    promotionActionPromises(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PromotionActionPromiseFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        statuses: [String!]
    ): PromotionActionPromiseConnection!
    promotionIds: [ID!]!
    "Returns list of promotion action line items"
    promotionLineItems(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PromotionActionLineItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PromotionActionLineItemConnection!
    promotions: [Promotion!]
    "Order invoice data"
    qPayInvoice: QPayInvoice
    readyCount: Int!
    registerNum: String
    segment: SupplySegment
    shipAddress: Address
    shipmentState: String
    shipmentTotal: Float!
    shipmentTrackings: [ShipmentTracking!]!
    shipments(
        "Shipper ID"
        shipperId: ID
    ): [Shipment!]!
    shippedAt: ISO8601DateTime
    shipperManifest: [ShipperManifest!]!
    shippingMethod: ShippingMethod
    shippingMethodNames: String
    "Returns list of shipping methods"
    shippingMethods(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShippingMethodFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShippingMethodConnection!
    shippingSlipTemplate: HandlebarTemplate
    sms: [Sms!]!
    specialInstructions: String
    state: String!
    stateChanges: [StateChange!]!
    stateLockVersion: Int!
    status: OrderStatusType!
    storeCredit: Float
    storeCreditOrigins(
        "gift_card, order"
        type: String
    ): JSON
    storeLocation: StoreLocation
    stores: [Brand!]!
    subOrders: [Order!]!
    supplierStockLocation: StockLocation
    takenItemsCount: Int
    taxTotal: Float
    taxableAdjustmentTotal: Float
    template: OrderTemplate
    templateId: ID
    token: String!
    total: Float!
    totalAfterStoreCredit: Float!
    totalAppliedStoreCredit: Float!
    totalAppliedWalletAmount: Float!
    totalAppliedWalletBonus: Float!
    totalPoint: Float
    totalQuantity: Int!
    tracking: [String!]!
    transactionCount: Int
    transactions: [BankTransaction!]!
    tutLengthExceeded: Boolean
    tutTotalWeight: Float
    updatedAt: ISO8601DateTime!
    usableLoyaltyPoints: Float
    usableStoreCredit: Float
    useBilling: Boolean
    user: User
    userGeneratedUrl: String
    vatComments: Int
    vatTotal: Float
    vendor: Vendor
    vendors: JSON
    verified: Boolean
    waitUntil: ISO8601DateTime
    walletAmount: Float
    website: Website
    weight: Float
    whenToShip: ISO8601DateTime
}

type OrderStatusType implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON! @deprecated(reason: "Use OrderType for this info")
    description: String
    gid: ID!
    id: ID!
    isCancelable: Boolean!
    isEditable: Boolean!
    isFeedbackEnabled: Boolean!
    isOutOfStock: Boolean!
    isPaid: Boolean!
    "can be paid"
    isPayable: Boolean!
    isShipped: Boolean!
    lineItems: [ShipmentLineItemStatusType!]! @deprecated(reason: "Use OrderType for this info")
    shipmentProgress: JSON
    status: String!
    title: String!
    updatedAt: ISO8601DateTime!
}

type OrderTemplate implements BaseModelInterface & Node {
    billAddress: Address
    branch: Branch
    business: Vendor
    businessTypes: [BusinessType!]!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    dayOfWeek: String
    extraData: JSON
    gid: ID!
    id: ID!
    isDefault: Boolean!
    items: [OrderTemplateItem!]!
    lastOrder: Order
    message: String
    name: String
    nextDate: ISO8601DateTime
    orders: [Order!]
    rule: String
    shipAddress: Address
    status: String
    storeLocation: StoreLocation
    time: String
    totalQuantity: Int!
    updatedAt: ISO8601DateTime!
    user: User
    vendor: Vendor
    website: Website
    whenToShip: ISO8601DateTime
}

"The connection type for OrderTemplate."
type OrderTemplateConnection {
    "A list of edges."
    edges: [OrderTemplateEdge!]!
    "A list of nodes."
    nodes: [OrderTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type OrderTemplateEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: OrderTemplate!
}

type OrderTemplateItem implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    orderTemplate: OrderTemplate
    quantity: String
    updatedAt: ISO8601DateTime!
    variant: Variant
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type Parcel implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    description: String
    driverId: User
    gid: ID!
    id: ID!
    otp: String
    sentById: User
    serviceGeneratedUrl: String
    shipment: Shipment
    sourceId: ID!
    sourceType: String!
    status: String
    trackingNumber: String
    updatedAt: ISO8601DateTime!
    userGeneratedUrl: String
}

type PartLineItem implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    lineItem: LineItem
    quantity: Int
    updatedAt: ISO8601DateTime!
    variant: Variant
}

type PassInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    orderId: String
    phone: String
    shop: String
    updatedAt: ISO8601DateTime!
}

type PayMeSource implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    cancelTime: ISO8601DateTime
    cardExpiry: String
    cardNumber: String
    cardToken: String
    createTime: ISO8601DateTime
    createdAt: ISO8601DateTime!
    fiscalSent: Boolean!
    gid: ID!
    id: ID!
    invoiceNumber: String
    paymentMethod: PaymentMethod
    paymentMethodId: ID
    performTime: ISO8601DateTime
    phone: String
    reason: String
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
}

type Payment implements BaseModelInterface & Node {
    accountNo: String
    amount: Float!
    avsResponse: String
    bankList: JSON
    bankName: String
    canI(action: CanIAction!): Boolean!
    capturedBy: User
    createdAt: ISO8601DateTime!
    cvvResponseCode: String
    cvvResponseMessage: String
    depositedOn: ISO8601Date
    gid: ID!
    id: ID!
    number: String
    order: Order
    paymentAccountData: JSON
    paymentMethod: PaymentMethod
    qrCode: String
    qrImage: String
    responseCode: String
    source: PaymentSourceInterface
    sourceId: ID
    sourceType: String
    state: String
    storeCreditEvent: StoreCreditEvent
    transactionReferenceNo: String
    type: String
    updatedAt: ISO8601DateTime!
    website: Website
}

"The connection type for Payment."
type PaymentConnection {
    "A list of edges."
    edges: [PaymentEdge!]!
    "A list of nodes."
    nodes: [Payment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PaymentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Payment!
}

type PaymentMethod implements BaseModelInterface & Node {
    active: Boolean
    afterPay: Boolean!
    autoCapture: Boolean
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    currencies: [String!]!
    data: JSON!
    description: String
    displayOn: String
    eBarimt: Boolean!
    fee: Float!
    gid: ID!
    id: ID!
    methodType: PaymentMethodKind!
    name: String!
    paymentSourceClass: String
    position: Int
    returnable: Boolean!
    settlementDays: Int
    storeLocation: StoreLocation
    type: String
    updatedAt: ISO8601DateTime!
    vendor: Vendor
    website: Website
}

type PaymentReturn implements BaseModelInterface & Node {
    accountBank: String
    accountName: String
    accountNumber: String
    amount: Float
    canI(action: CanIAction!): Boolean!
    commission: Float
    createdAt: ISO8601DateTime!
    creator: User
    deletedAt: ISO8601DateTime
    description: String
    gid: ID!
    id: ID!
    journalNo: String
    lineItemIds: [ID!]!
    lineItems: [LineItem!]!
    message: String
    note: String
    order: Order
    otherFee: Float
    paidAt: ISO8601DateTime
    payment: Payment
    reason: PaymentReturnReason
    returnItems: [PaymentReturnItem!]!
    returner: User
    returnsCount: Int
    source: PaymentReturnSource
    status: String
    storeLocation: StoreLocation
    transactionId: ID
    transactionType: String
    transferAt: ISO8601DateTime
    updatedAt: ISO8601DateTime!
    uuid: String
    website: Website
}

"The connection type for PaymentReturn."
type PaymentReturnConnection {
    "A list of edges."
    edges: [PaymentReturnEdge!]!
    "A list of nodes."
    nodes: [PaymentReturn!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PaymentReturnEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PaymentReturn!
}

type PaymentReturnItem implements BaseModelInterface & Node {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    lineItem: LineItem!
    lineItemId: ID!
    order: Order!
    paymentReturn: PaymentReturn!
    quantity: Int
    updatedAt: ISO8601DateTime!
}

type PaymentReturnReason implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    description: String
    gid: ID!
    id: ID!
    name: String
    updatedAt: ISO8601DateTime!
    website: Website
}

"The connection type for PaymentReturnReason."
type PaymentReturnReasonConnection {
    "A list of edges."
    edges: [PaymentReturnReasonEdge!]!
    "A list of nodes."
    nodes: [PaymentReturnReason!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PaymentReturnReasonEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PaymentReturnReason!
}

type PaymentReturnSource implements Node {
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    name: String
    website: Website
}

"The connection type for PaymentReturnSource."
type PaymentReturnSourceConnection {
    "A list of edges."
    edges: [PaymentReturnSourceEdge!]!
    "A list of nodes."
    nodes: [PaymentReturnSource!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PaymentReturnSourceEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PaymentReturnSource!
}

type PaymentSource implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    gid: ID!
    id: ID!
    idx: String
    idx2: String
    invoice: String
    order: Order
    orderId: ID
    payment: Payment
    paymentId: ID
    paymentMethod: PaymentMethod
    paymentMethodId: ID
    type: String
    updatedAt: ISO8601DateTime!
    user: User
}

"The connection type for PaymentSource."
type PaymentSourceConnection {
    "A list of edges."
    edges: [PaymentSourceEdge!]!
    "A list of nodes."
    nodes: [PaymentSource!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PaymentSourceEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PaymentSource!
}

type PaypalInvoice implements BaseModelInterface & Node {
    authorizationId: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    orderId: String
    payeeId: String
    updatedAt: ISO8601DateTime!
}

type PercentOnLineItem implements BaseModelInterface & CalculatorInterface & Node {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    preferredPercent: Float!
    type: String
    updatedAt: ISO8601DateTime!
}

type PickUpLocation implements BaseModelInterface & Node {
    acceptcard: String
    acceptcash: String
    acceptindividuals: String
    address: String
    canI(action: CanIAction!): Boolean!
    clientcode: String
    code: String
    comment: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    latitude: String
    longitude: String
    maxweight: String
    name: String
    parentcode: String
    parentname: String
    phone: String
    terminalType: String
    traveldescription: String
    updatedAt: ISO8601DateTime!
    worktime: String
}

type PocketInAppInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    holdId: String
    id: ID!
    info: String
    invoiceId: String
    terminalId: String
    updatedAt: ISO8601DateTime!
}

type PocketInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    heldId: String
    id: ID!
    info: String
    invoiceId: String
    phone: String
    qrCode: String
    qrImage: String
    updatedAt: ISO8601DateTime!
}

type PocketZeroInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    customerId: String
    duration: String
    email: String
    expireAt: ISO8601DateTime
    gid: ID!
    holdAmount: String
    holdId: String
    id: ID!
    invoiceId: String
    invoiceNumber: String
    isUsed: Boolean
    lastName: String
    name: String
    phone: String
    register: String
    updatedAt: ISO8601DateTime!
}

type Poll implements BaseModelInterface & Node {
    active: Boolean
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    creator: User
    expireAt: ISO8601DateTime
    gid: ID!
    id: ID!
    image: String
    question: String
    questions: [PollQuestion!]!
    startAt: ISO8601DateTime
    updatedAt: ISO8601DateTime!
    website: Website
}

type PollAnswer implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    question: PollQuestion
    updatedAt: ISO8601DateTime!
    user: User
    voteDate: ISO8601DateTime
}

"The connection type for PollAnswer."
type PollAnswerConnection {
    "A list of edges."
    edges: [PollAnswerEdge!]!
    "A list of nodes."
    nodes: [PollAnswer!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PollAnswerEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PollAnswer!
}

"The connection type for Poll."
type PollConnection {
    "A list of edges."
    edges: [PollEdge!]!
    "A list of nodes."
    nodes: [Poll!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PollEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Poll!
}

type PollQuestion implements BaseModelInterface & Node {
    answers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PollAnswerConnection!
    answersCount: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String
    poll: Poll
    updatedAt: ISO8601DateTime!
}

type PosListing implements BaseModelInterface & Node {
    activeSince: ISO8601DateTime
    activeUntil: ISO8601DateTime
    approved: Boolean
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    createdBy: User
    gid: ID!
    id: ID!
    product: Product!
    published: Boolean
    slug: String
    storeLocation: StoreLocation!
    updatedAt: ISO8601DateTime!
}

"The connection type for PosListing."
type PosListingConnection {
    "A list of edges."
    edges: [PosListingEdge!]!
    "A list of nodes."
    nodes: [PosListing!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PosListingEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PosListing!
}

type Prescription implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    code: String
    createdAt: ISO8601DateTime!
    description: String
    diagnosis: String
    doctorHospital: String
    doctorName: String
    gid: ID!
    id: ID!
    image(
        "small, medium, large, default: medium"
        size: String
    ): String!
    image1(
        "small, medium, large, default: medium"
        size: String
    ): String!
    items: [PrescriptionItem!]!
    number: String!
    order: Order
    orderId: ID
    patientName: String
    prescriptionDate: ISO8601Date
    prescriptionVariants: [PrescriptionVariant!]!
    reviewComment: String
    reviewedAt: ISO8601DateTime
    reviewer: User
    reviewerId: ID
    status: PrescriptionStatus!
    updatedAt: ISO8601DateTime!
    user: User!
    userId: ID!
    variants: [Variant!]!
    website: Website!
    websiteId: ID!
}

"The connection type for Prescription."
type PrescriptionConnection {
    "A list of edges."
    edges: [PrescriptionEdge!]!
    "A list of nodes."
    nodes: [Prescription!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PrescriptionEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Prescription!
}

type PrescriptionItem implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    drugName: String
    drugNumber: String
    frequency: Int
    gid: ID!
    id: ID!
    lineItem: LineItem
    lineItemId: ID
    prescription: Prescription!
    prescriptionId: ID!
    prescriptionVariants: [PrescriptionVariant!]!
    quantity: Int
    status: PrescriptionItemStatus
    updatedAt: ISO8601DateTime!
    variantIds: [ID!]!
    variants: [Variant!]!
}

type PrescriptionVariant implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    item: PrescriptionItem!
    itemId: ID!
    prescription: Prescription!
    prescriptionId: ID!
    quantity: Int
    selected: Boolean!
    updatedAt: ISO8601DateTime!
    variant: Variant!
    variantId: ID!
}

type Price implements BaseModelInterface & Node {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    currency: String!
    gid: ID!
    id: ID!
    position: Int!
    price: Float
    salePrices: [SalePrice!]!
    stockLocation: StockLocation
    stockLocationId: ID
    updatedAt: ISO8601DateTime!
    variant: Variant!
    variantId: ID!
}

type Printing implements BaseModelInterface & Node {
    attachment: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    firstName: String
    gid: ID!
    id: ID!
    lastName: String
    lineItem: LineItem
    mobile: String
    order: Order
    product: Product
    updatedAt: ISO8601DateTime!
    website: Website
}

"The connection type for Printing."
type PrintingConnection {
    "A list of edges."
    edges: [PrintingEdge!]!
    "A list of nodes."
    nodes: [Printing!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PrintingEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Printing!
}

type PrintingManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    printings: [Printing!]
    productCat: String
    sku: String
    slug: String!
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

type Product implements BaseModelInterface & Node {
    assembliesParts: [AssemblyPart!]!
    attributes: JSON
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    availableOn: ISO8601DateTime
    availableUntil: ISO8601DateTime
    averageRating: Float!
    barcode: String
    booking: Booking
    bookingStock: Booking
    brand: Brand
    canI(action: CanIAction!): Boolean!
    canSupply: Boolean!
    cancelDuration: Int
    "chat room of current user on product"
    chatRoom: Room
    condition: String
    createdAt: ISO8601DateTime!
    currency: String
    currentListing: Listing
    data: JSON!
    dates: [String!]
    deletedAt: ISO8601DateTime
    description: String
    discontinueOn: ISO8601DateTime
    documents: [ProductDocument!]!
    "Returns list of donations"
    donations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DonationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DonationConnection!
    featured: Boolean
    features: JSON
    fragile: Boolean
    gid: ID!
    giftCard: Boolean
    id: ID!
    image(
        "Use CDN Mirror ? defaults to TRUE"
        mirror: Boolean = true,
        "Alias"
        size: ProductImageSize
    ): String
    images: [ProductImage!]!
    info: JSON
    isListedOnWebsite: Boolean
    keyword: Keyword
    keywordId: ID
    labelCode: String
    listings: [Listing!]!
    "Тухайн харилцагчийн авч болох бүх Listing жагсаалтын буцаана"
    listingsCon(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    master: Variant!
    merchantSku: String
    metaDescription: String
    metaKeywords: String
    metaTitle: String
    myReview: Review
    name: String
    nonReturnable: Boolean
    optionTypes: [OptionType!]!
    optionValues: [OptionValue!]!
    packageCode: String
    posMaxQty: Int
    posVariants: [Variant!]
    possibleOptionValues: [OptionValue!]!
    preferredAssemblyPartsCalculationType: String
    preferredAssemblyStockScope: String
    preferredEticketActivationMethod: String
    preferredEticketRequireActivation: Boolean
    price(
        "optional currency"
        currency: String
    ): Float!
    prices: [Price!]!
    productCat: String
    productOptionValues: [ProductOptionValue!]!
    productProperties: [ProductProperty!]!
    promotionable: Boolean
    "get single property by name"
    property(
        "name"
        name: String!
    ): String
    prototype: Prototype
    reviews(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ReviewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        isDeleted: Boolean,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ReviewConnection!
    saleExpireAt: ISO8601DateTime
    salePrices: [SalePrice!]!
    sellingPrice(
        "optional currency"
        currency: String,
        "Stock Location ID"
        stockLocationId: ID,
        "optional website id"
        websiteId: ID
    ): Float!
    shippingCategoryId: ID
    sizingGuide: SizingGuide
    sizingGuideId: ID
    sku: String!
    slug: String!
    stage: Stage
    stockLocations: [StockLocation!]!
    storeId: ID
    taxCategoryId: ID
    taxCode: String
    title: String!
    totalDonated: Float!
    totalOnHand(excludedVariantId: ID, stockLocationId: [ID!]): Float!
    totalOnHandAll(
        "stock location id"
        stockLocationIds: [ID!]
    ): Float! @deprecated(reason: "Will be removed soon")
    totalReviews: Int!
    translations: [ProductTranslation!]!
    updatedAt: ISO8601DateTime!
    variantSeries: [Variant!]!
    variants: [Variant!]!
    variantsIncludingMaster: [Variant!]!
    variantsIncludingMasterAndSeries: [Variant!]! @deprecated(reason: "Will be removed soon")
    vendor: Vendor
    youtube: String
}

"The connection type for Product."
type ProductConnection {
    "A list of edges."
    edges: [ProductEdge!]!
    "A list of nodes."
    nodes: [Product!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

type ProductDocument implements BaseModelInterface & Node {
    alt: String
    attachmentContentType: String
    attachmentFileName: String
    attachmentFileSize: Int
    attachmentHeight: Int
    attachmentProcessing: Boolean
    attachmentWidth: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    position: Int
    updatedAt: ISO8601DateTime!
    url(
        "Use CDN Mirror ? defaults to TRUE"
        mirror: Boolean = true,
        "Alias"
        size: ProductImageSize
    ): String
    variant: Variant
}

"An edge in a connection."
type ProductEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Product!
}

type ProductImage implements BaseModelInterface & Node {
    alt: String
    attachmentContentType: String
    attachmentFileName: String
    attachmentFileSize: Int
    attachmentHeight: Int
    attachmentProcessing: Boolean
    attachmentWidth: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    position: Int
    updatedAt: ISO8601DateTime!
    url(
        "Use CDN Mirror ? defaults to TRUE"
        mirror: Boolean = true,
        "Alias"
        size: ProductImageSize
    ): String!
    variant: Variant
}

type ProductManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    product: Product
    productCat: String
    sku: String
    slug: String!
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

type ProductOptionValue implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    images: [ProductImage!]!
    optionValue: OptionValue!
    position: Int!
    updatedAt: ISO8601DateTime!
}

type ProductProperty implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    position: Int
    product: Product!
    property: Property!
    updatedAt: ISO8601DateTime!
    value: String
}

type ProductReturn implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    lineItem: LineItem!
    order: Order
    price: Float
    quantity: Int
    returnAt: String
    returnBy: User
    returnByDate: String
    returnLocation: StoreLocation
    state: String
    updatedAt: ISO8601DateTime!
    variant: Variant!
}

"The connection type for ProductReturn."
type ProductReturnConnection {
    "A list of edges."
    edges: [ProductReturnEdge!]!
    "A list of nodes."
    nodes: [ProductReturn!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ProductReturnEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ProductReturn!
}

type ProductTranslation implements BaseModelInterface & Node {
    body: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    locale: String
    metaDescription: String
    metaKeywords: String
    metaTitle: String
    name: String
    product: Product
    title: String
    updatedAt: ISO8601DateTime!
}

type Profile implements BaseModelInterface & Node {
    balance: Float
    blocked: String
    businessClient: BusinessClient
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    creditLimit: Float
    customerId: String
    customerName: String
    gid: ID!
    id: ID!
    registrationNo: String
    updatedAt: ISO8601DateTime!
}

type Progress implements Node {
    amount: Float!
    amountChange: Float!
    createdAt: ISO8601DateTime!
    cycle: String!
    date: ISO8601DateTime!
    gamification: Gamification!
    gid: ID!
    goal: GamificationGoal!
    id: ID!
    owner: Node!
    percentage: Float!
    percentageChange: Float!
    preferences: JSON
    target: Node!
    updatedAt: ISO8601DateTime!
}

"The connection type for Progress."
type ProgressConnection {
    "A list of edges."
    edges: [ProgressEdge!]!
    "A list of nodes."
    nodes: [Progress!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ProgressEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Progress!
}

type Promotion implements BaseModelInterface & Node {
    actionManifests: [PromotionActionManifest!]!
    actions: [ActionInterface!]!
    advertise: Boolean
    applies: [PromotionApply!]
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    autoClaim: Boolean
    canI(action: CanIAction!): Boolean!
    claimedQuantity: Int
    code: String
    createdAt: ISO8601DateTime!
    creditsCount: Int
    description: String
    entitlements(canSupply: Boolean, requireApprove: Boolean): [PromotionApply!]
    expiresAt: ISO8601DateTime
    gid: ID!
    id: ID!
    image: Image
    link: String
    matchPolicy: String
    myCode: String
    myCodeStatus: String
    name: String!
    "Returns list of orders"
    orders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        status: OrderStatus
    ): OrderConnection!
    path: String
    preferences: JSON
    priority: Int
    rule: JSON
    ruleManifests: [PromotionRuleManifest!]!
    rules: [RuleInterface!]!
    startsAt: ISO8601DateTime
    tagList: [String!]!
    terms: String
    type: String
    updatedAt: ISO8601DateTime!
    usageLimit: Int
}

type PromotionAction implements ActionInterface & Node {
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    promotion: Promotion!
    promotionId: ID!
    type: String
}

type PromotionActionFreeShipping implements ActionInterface & Node {
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    promotion: Promotion!
    promotionId: ID!
    type: String
}

type PromotionActionLineItem implements Node {
    details: String
    gid: ID!
    id: ID!
    interval: Int
    lineItemId: ID
    maxQuantity: Int
    preferences: JSON
    promotionAction: PromotionAction
    promotionActionId: ID
    promotionActionType: String
    quantity: Int
    step: Float
    variant: Variant
    variantId: ID
}

"The connection type for PromotionActionLineItem."
type PromotionActionLineItemConnection {
    "A list of edges."
    edges: [PromotionActionLineItemEdge!]!
    "A list of nodes."
    nodes: [PromotionActionLineItem!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PromotionActionLineItemEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PromotionActionLineItem!
}

type PromotionActionManifest implements Node {
    action: String!
    currency: String
    gid: ID!
    id: ID!
    interval: Int
    limit: Int
    listings: [Listing!]!
    products: [Product!]!
    rule: String
    saleAmount: Float
    salePercent: Float
    variants: [Variant!]!
}

type PromotionActionPromise implements BaseModelInterface & Node {
    "Returns list of products"
    adjustedLineItems: [LineItem!]!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    isEligible: Boolean!
    order: Order!
    preferredLimit: String
    promotionAction: PromotionAction!
    promotionActionId: Int
    promotionActionLineItems: [PromotionActionLineItem!]!
    promotionActionType: String
    status: String
    totalAmountEligibleItems: Float!
    updatedAt: ISO8601DateTime!
}

"The connection type for PromotionActionPromise."
type PromotionActionPromiseConnection {
    "A list of edges."
    edges: [PromotionActionPromiseEdge!]!
    "A list of nodes."
    nodes: [PromotionActionPromise!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PromotionActionPromiseEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PromotionActionPromise!
}

"The connection type for Promotion."
type PromotionConnection {
    "A list of edges."
    edges: [PromotionEdge!]!
    giftsCount: Int
    "A list of nodes."
    nodes: [Promotion!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    percentsCount: Int
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PromotionEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Promotion!
}

type PromotionRule implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleBadge implements Node & RuleInterface {
    badgeIds: [ID!]!
    badges: [Taxon!]!
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredMatchPolicy: String!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleBusinessClient implements Node & RuleInterface {
    businessClientIds: [String!]
    businessClients: [BusinessClient!]
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredMatchPolicy: String!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleManifest implements Node {
    badges: [Badge!]!
    gid: ID!
    id: ID!
    maxAmount: Int
    maxQuantity: Int
    minAmount: Int
    minQuantity: Int
    policy: String
    products: [Product!]!
    rule: String!
    stores: [Brand!]!
    taxons: [Taxon!]!
    variants: [Variant!]!
    vendors: [Vendor!]!
}

type PromotionRuleProduct implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredFromBasePrice: Boolean
    preferredMatchPolicy: String!
    preferredMaxAmount: Float!
    preferredMaxQuantity: Int!
    preferredMinAmount: Float!
    preferredMinQuantity: Int!
    productGroupId: ID
    productIds: [ID!]!
    products: [Product!]!
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleSegment implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredMatchPolicy: String!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    segmentIds: [ID!]!
    segments: [SupplySegment!]!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleShippingMethod implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredMatchPolicy: String!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    shippingMethodIds: [String!]
    shippingMethods: [ShippingMethod!]
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleStockLocation implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredFromBasePrice: Boolean
    preferredMatchPolicy: String!
    preferredMaxAmount: Float!
    preferredMaxQuantity: Int!
    preferredMinAmount: Float!
    preferredMinQuantity: Int!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    stockLocationIds: [ID!]!
    stockLocations: [StockLocation!]!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleStore implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredFromBasePrice: Boolean
    preferredMatchPolicy: String!
    preferredMaxAmount: Float!
    preferredMaxQuantity: Int!
    preferredMinAmount: Float!
    preferredMinQuantity: Int!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    storeIds: [ID!]!
    stores: [Brand!]!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleStoreLocation implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredMatchPolicy: String!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    storeLocationIds: [ID!]!
    storeLocations: [StoreLocation!]!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleTaxon implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredMatchPolicy: String!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    taxonIds: [ID!]!
    taxons: [Taxon!]!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type PromotionRuleUser implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
    userIds: [ID!]!
    users: [User!]!
}

type PromotionRuleVariant implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredFromBasePrice: Boolean
    preferredHasCouponCodeItemLimit: Boolean
    preferredMatchPolicy: String!
    preferredMaxAmount: Float!
    preferredMaxQuantity: Int!
    preferredMinAmount: Float!
    preferredMinQuantity: Int!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
    variantIds: [ID!]!
    variants: [Variant!]!
}

type PromotionRuleVendor implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredFromBasePrice: Boolean
    preferredMatchPolicy: String!
    preferredMaxAmount: Float!
    preferredMaxQuantity: Int!
    preferredMinAmount: Float!
    preferredMinQuantity: Int!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
    vendorIds: [ID!]!
    vendors: [Vendor!]!
}

type PromotionRuleWebsite implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
    websiteIds: [ID!]!
    websites: [Website!]!
}

type Property implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String!
    presentation: String
    updatedAt: ISO8601DateTime!
}

"The connection type for Property."
type PropertyConnection {
    "A list of edges."
    edges: [PropertyEdge!]!
    "A list of nodes."
    nodes: [Property!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PropertyEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Property!
}

type PropertyValue implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    property: Property!
    updatedAt: ISO8601DateTime!
    value: String
}

"The connection type for PropertyValue."
type PropertyValueConnection {
    "A list of edges."
    edges: [PropertyValueEdge!]!
    "A list of nodes."
    nodes: [PropertyValue!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PropertyValueEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PropertyValue!
}

type Prototype implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    depth: Int
    expanded: Int
    gid: ID!
    hasChildren: Boolean
    id: ID!
    keywords: [Keyword!]!
    lft: Int
    name: String
    optionTypeIds: [ID!]!
    "Returns list of option types"
    optionTypes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OptionTypeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): OptionTypeConnection!
    options: JSON
    parentId: ID
    parentIds: [ID!]!
    position: Int
    presentation: String
    prettyName: String
    prettyOptions: JSON
    prettyPresentation: String
    properties: [Property!]!
    rgt: Int
    updatedAt: ISO8601DateTime!
}

"The connection type for Prototype."
type PrototypeConnection {
    "A list of edges."
    edges: [PrototypeEdge!]!
    "A list of nodes."
    nodes: [Prototype!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PrototypeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Prototype!
}

type PurchasedDownloadable implements BaseModelInterface & Node {
    attachments: [DownloadableAttachment!]!
    canI(action: CanIAction!): Boolean!
    contentType: String
    createdAt: ISO8601DateTime!
    expireDate: ISO8601DateTime
    gid: ID!
    id: ID!
    order: Order!
    orderId: ID!
    product: Product!
    productId: ID!
    status: String
    updatedAt: ISO8601DateTime!
    user: User!
    userId: ID!
    variant: Variant!
    variantId: ID!
}

"The connection type for PurchasedDownloadable."
type PurchasedDownloadableConnection {
    "A list of edges."
    edges: [PurchasedDownloadableEdge!]!
    "A list of nodes."
    nodes: [PurchasedDownloadable!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PurchasedDownloadableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PurchasedDownloadable!
}

type PushTemplate implements BaseModelInterface & Node {
    appId: ID
    appIds: [ID!]!
    apps: [Application!]!
    body: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deeplink: String
    gid: ID!
    id: ID!
    name: String!
    title: String!
    updatedAt: ISO8601DateTime!
    url: String
    website: Website!
    websiteId: ID!
}

"The connection type for PushTemplate."
type PushTemplateConnection {
    "A list of edges."
    edges: [PushTemplateEdge!]!
    "A list of nodes."
    nodes: [PushTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type PushTemplateEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PushTemplate!
}

type QPayCard implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    cardIssuer: String!
    cardNumber: String!
    cardType: String!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    isDefault: Boolean!
    paymentMethod: PaymentMethod
    paymentMethodId: ID
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
}

type QPayDeepLink {
    description: String!
    link: String!
    logo: String!
    name: String!
}

type QPayInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deepLinks: [QPayDeepLink!]
    gid: ID!
    id: ID!
    invoiceId: String
    qrCode: String
    qrImage: String
    qrUrl: String
    status: String
    updatedAt: ISO8601DateTime!
}

type Quarter implements Node {
    district: District
    districtId: ID
    gid: ID!
    id: ID!
    name: String
    preferences: JSON
    zip: Zipcode
}

"The connection type for Quarter."
type QuarterConnection {
    "A list of edges."
    edges: [QuarterEdge!]!
    "A list of nodes."
    nodes: [Quarter!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type QuarterEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Quarter!
}

type Query {
    activeQuiz: Quiz
    "Search address by location"
    address(
        "parent id"
        filterId: ID,
        "for details"
        id: ID,
        lat: String,
        limit: Int,
        lon: String,
        page: Int,
        "Search value of address"
        q: String,
        "au100, au200, au300, ...au800"
        type: String
    ): [UbcAddress!]!
    agendas(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AgendaFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AgendaConnection!
    "Returns list of movies"
    allMovies(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MovieFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MovieConnection!
    "Fetch article by id"
    article(id: ID, impression: Boolean, slug: String): Article!
    "Returns list of menus"
    articles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ArticleFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ArticleConnection!
    "Returns list of authors"
    authors(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuthorFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuthorConnection!
    availableTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ProductConnection!
    badge(id: ID!): Badge
    badges(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BadgeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BadgeConnection!
    branch(id: ID!): Branch!
    brand(code: String, id: ID, name: String): Brand
    "Returns list of brands"
    brands(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BrandFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BrandConnection!
    "Returns current user's accessible vendor or first result"
    business(id: ID): Vendor!
    businessClient(id: ID!): BusinessClient
    "Returns list of business types"
    businessTypes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessTypeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BusinessTypeConnection!
    campaign(id: ID!): ShoppyCampaign!
    campaigns(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CampaignFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShoppyCampaignConnection!
    "Returns list of cancel orders"
    cancelReasons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CancelReasonConnection!
    "Fetch Channel by id"
    channel(id: ID!): Merchant!
    chatRoom(id: ID!): Room
    "List of chat rooms"
    chatRooms(
        active: Boolean,
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: RoomFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): RoomConnection!
    cinema(
        "Cinema ID"
        id: ID!
    ): Cinema
    cinemas: [Cinema!]!
    "Returns a client store"
    clientsStore(id: ID!): ClientsStore
    "Returns list of client stores"
    clientsStores(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ClientsStoreFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ClientsStoreConnection!
    countries(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CountryFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CountryConnection!
    coupon(id: ID, number: String): Coupon
    creditCard(id: ID): CreditCard!
    currentOrder(currency: String, flag: String, key: String, number: String, orderToken: String): Order
    "Returns current website data"
    currentWebsite: Website
    departmentStore(id: ID!): DepartmentStore
    departmentStores(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DepartmentStoreFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DepartmentStoreConnection!
    districts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DistrictFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DistrictConnection!
    downloadable(id: ID!): PurchasedDownloadable!
    dropshipAlibabaDiscounts(discountType: String, key: String): [Discount!]!
    dropshipProduct(id: ID!): DropshipProduct!
    "Returns list of dropship products"
    dropshipProducts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DropshipProductFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DropshipProductConnection!
    dropshipProvider(id: ID!): DropshipProvider!
    "Returns list of dropship providers"
    dropshipProviders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ProviderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DropshipProviderConnection!
    eTicket(id: ID, number: String): ETicket
    "Returns information of ETickets Nfc activated user info"
    eTicketNfcChecker(
        "Nfc ID"
        nfcId: ID
    ): ETicketActivation
    "Returns list of ETickets"
    eTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ETicketFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ETicketConnection!
    "Fetch employee by id"
    employee(id: ID!): Employee!
    emuPickupLocations(stateId: ID!): [PickUpLocation!]
    eventInvite(id: ID!): EventInvite!
    eventInvites(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: EventInviteFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): EventInviteConnection!
    featured(targetId: ID!, targetType: String!): Featured
    feedback(id: ID!): FeedbackType!
    feedbackComments(id: ID!): [Comment!]!
    feedbackTopics(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FeedbackTopicFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FeedbackTopicConnection!
    feedbacks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FeedbackFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FeedbackTypeConnection!
    flatTaxon(depth: Int): JSON
    "ShoppyForm"
    form(
        id: ID,
        "permalink: pathname"
        permalink: String
    ): ShoppyForm
    forms(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FormFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShoppyFormConnection!
    game(id: ID): Game
    "Returns list of gamifications"
    gamifications(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: GamificationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): GamificationConnection!
    gc(id: String, redemptionCode: String, websiteId: ID): GiftCard
    "Fetch VCC by id"
    golomtCard(id: ID!): GolomtCard!
    "Returns list of inventory unit actions"
    inventoryUnitActions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: InventoryUnitActionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): InventoryUnitActionConnection
    lastUsedPaymentMethods: [PaymentMethod!]!
    leaseV3Sources(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentSourceFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentSourceConnection!
    lineItem(id: ID!): LineItem
    "Fetch Listing by id"
    listing(id: ID, impression: Boolean, slug: String): Listing!
    "Тухайн харилцагчийн авч болох бүх Listing жагсаалтын буцаана"
    listings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    lookBook(id: ID): LookBook
    lookBooks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: LookBookFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): LookBookConnection!
    massPromotions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MassPromoFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MassPromotionConnection!
    "Return current logged in user info"
    me: User!
    menu(
        "id"
        id: ID,
        "title: if no id is provided defaults to \"system_navigation\""
        title: String = "system_navigation"
    ): DynamicMenu
    menus: [DynamicMenu!]!
    "Returns list of merchants"
    merchants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MerchantFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MerchantConnection!
    movie(
        "Movie ID"
        id: ID!
    ): Movie
    movieTicket(id: ID!): MovieTicket
    "Returns list of movie tickets"
    movieTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MovieTicketFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MovieTicketConnection!
    movies(upcoming: Boolean = false): [Movie!]!
    news(id: ID!, impression: Boolean): News
    "Returns list of menus"
    newses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: NewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): NewsConnection!
    "Fetches an object given its ID."
    node(
        "ID of the object."
        id: ID!
    ): Node
    "Fetches a list of objects given a list of IDs."
    nodes(
        "ID of the object."
        ids: [ID!]!
    ): [Node!]!
    notices(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: NoticeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): NoticeConnection!
    notifications(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: NotificationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): NotificationConnection!
    nutritionFact(id: ID!): NutritionFact!
    optionType(id: ID!): OptionType!
    "Fetch Order"
    order(id: ID, number: String, token: String): Order!
    "Returns an Order template with a given id"
    orderTemplate(id: ID!): OrderTemplate!
    "Returns list of orders"
    orders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        status: OrderStatus
    ): OrderConnection!
    "returns single dynamic page"
    page(
        id: ID,
        "SLUG: pathname"
        slug: String
    ): DynamicPage
    "Returns list of pages"
    pages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PageFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DynamicPageConnection!
    payment(id: ID, number: String): Payment!
    "Returns a website payment acount data"
    paymentAccountData: JSON
    "Returns list of payment methods"
    paymentMethods(active: Boolean, afterPay: Boolean, displayOn: [PmDisplayKind!]): [PaymentMethod!]!
    "Fetch Payment Return by id"
    paymentReturn(id: ID!): PaymentReturn!
    paymentReturnReasons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentReturnReasonFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentReturnReasonConnection!
    paymentReturnSources(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentReturnSourceFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentReturnSourceConnection!
    "Poll/QA"
    poll(id: ID!): Poll
    polls(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PollFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PollConnection!
    prescription(id: ID!): Prescription
    "Prescriptions list"
    prescriptions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PrescriptionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PrescriptionConnection!
    "Fetch product by id, slug or else"
    product(brand: String, id: ID, sku: String, slug: String): Product
    "Returns list of products"
    products(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ProductFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        websiteId: ID
    ): ProductConnection!
    promotion(id: ID!): Promotion!
    "Returns list of promotions"
    promotions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        dateType: String,
        filter: PromotionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        from: String,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        to: String
    ): PromotionConnection!
    "Returns list of properties"
    properties(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PropertyFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PropertyConnection!
    "Return translation of the product properties"
    propertiesTranslation: JSON!
    "List of property values"
    propertyValues(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PropertyValueFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PropertyValueConnection!
    prototype(id: ID!): Prototype!
    prototypes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PrototypeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PrototypeConnection!
    pushTemplates(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PushTemplateFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PushTemplateConnection!
    quarters(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: QuarterFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): QuarterConnection!
    quiz(id: ID): Quiz
    "Returns list of rate"
    rate(rate: String!): JSON!
    relatedProducts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: RelationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): RelationConnection!
    reportReasons: [ReportReason!]!
    "Gets Address by id"
    savedAddress(
        "address id"
        id: ID!
    ): Address!
    screens: [Screen!]!
    "search address by names of location"
    searchAddressByNames(country: String, district: String, locality: String, province: String): JSON!
    session(
        "Session ID"
        id: ID!
    ): Session
    "Shipment details"
    shipment(id: ID, number: String): Shipment!
    "Returns list of shipment"
    shipments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShipmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShipmentConnection!
    "Returns list of shippers"
    shippers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShipperConnection!
    "Returns list of shipping category"
    shippingCategories(filter: ShippingCategoryFilter): [ShippingCategory!]!
    "Returns list of shipping methods"
    shippingMethods(filter: ShippingMethodFilter): [ShippingMethod!]!
    shoppyImages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShoppyImageFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ImageConnection!
    "Fetch Sizing guide by id"
    sizingGuide(id: ID!): SizingGuide!
    stage(id: ID): Stage!
    states(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StateFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StateConnection!
    storeCredits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreCreditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreCreditConnection!
    storeLocation(id: ID!): StoreLocation
    storeLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreLocationConnection!
    "Returns list of address"
    storesAddresses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        categoryIds: [ID!],
        filter: AddressFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        wid: ID
    ): AddressConnection!
    "Returns list of supplier category"
    supplierCategories(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SupplierCategoryFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SupplierCategoryConnection!
    supplySegment(id: ID!): SupplySegment
    supplySegments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SupplySegmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SupplySegmentConnection!
    tag(name: String!): Tag
    tags(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: TagFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        websiteSpecific: Boolean
    ): TagConnection!
    taxCategories(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TaxCategoryConnection!
    taxRates(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TaxRateConnection!
    taxon(id: ID, permalink: String, suffix: String): Taxon
    taxons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: TaxonFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TaxonConnection!
    ticketTemplates(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: TicketTemplateFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TicketTemplateConnection
    "Returns list of trackables"
    trackables(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TrackableTypeConnection!
    unreadNotifications: Int!
    unseenChatRooms: Int
    "Return a address of user"
    userAddress(id: ID!): UserAddress!
    "Returns list of address for an user"
    userAddresses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserAddressFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserAddressConnection!
    "Returns list of user agreements"
    userAgreements(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserAgreementFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserAgreementConnection!
    userTokenInfo(number: String!): JSON!
    "Returns list of users"
    users(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserConnection!
    "Returns list of users"
    usersList(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserConnection!
    "Fetch variant by id"
    variant(id: ID!): Variant!
    "Get Vendor by id"
    vendor(id: ID!): Vendor!
    "Returns list of vendors"
    vendors(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: VendorFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): VendorConnection!
    walletRequests(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WalletRequestFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WalletRequestConnection!
    wallets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WalletFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WalletConnection!
    "Тухайн сайтын авч болох бүх Listing жагсаалтын буцаана"
    webListings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    "Fetch website by id"
    website(id: ID, index: String): Website!
    wishedProducts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WishedProductFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WishedProductConnection!
    wishlist(accessHash: String): Wishlist!
    wishlists(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WishlistFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WishlistConnection!
    zones: [Zone!]!
}

type Quiz implements BaseModelInterface & Node {
    active: Boolean
    available: Boolean
    canI(action: CanIAction!): Boolean!
    cover: String
    createdAt: ISO8601DateTime!
    data: JSON
    description: String
    expireAt: ISO8601DateTime
    gid: ID!
    gradeBy: String
    id: ID!
    permalink: String
    preferredEntryPerUser: Int
    preferredFrequency: String
    preferredOnDisplay: Int
    preferredRewardPerUser: Int
    preferredTime: Int
    questions: [QuizQuestion!]!
    rewards: [QuizReward!]!
    startAt: ISO8601DateTime
    title: String
    updatedAt: ISO8601DateTime!
}

type QuizAnswer implements BaseModelInterface & Node {
    body: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    score: Int
    updatedAt: ISO8601DateTime!
}

type QuizQuestion implements BaseModelInterface & Node {
    answers: [QuizAnswer!]!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String
    question: QuizQuestion!
    updatedAt: ISO8601DateTime!
}

type QuizResult implements BaseModelInterface & Node {
    answers: [QuizAnswer!]
    availableRewards: Int
    canI(action: CanIAction!): Boolean!
    claimedRewards: Int
    createdAt: ISO8601DateTime!
    finalScore: Int
    gid: ID!
    id: ID!
    possibleRewards: [QuizReward!]
    rewards: [QuizReward!]
    updatedAt: ISO8601DateTime!
    winnerStatus: Boolean
}

type QuizReward implements BaseModelInterface & Node {
    availableFrom: ISO8601DateTime
    availableUntil: ISO8601DateTime
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    image: String
    maxScore: Int
    minScore: Int
    name: String
    updatedAt: ISO8601DateTime!
}

type RecentlyViewedListing implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    listing: Listing!
    updatedAt: ISO8601DateTime!
    viewCount: Int!
}

"The connection type for RecentlyViewedListing."
type RecentlyViewedListingConnection {
    "A list of edges."
    edges: [RecentlyViewedListingEdge!]!
    "A list of nodes."
    nodes: [RecentlyViewedListing!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type RecentlyViewedListingEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: RecentlyViewedListing!
}

type Regex implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    preferredRegex: String!
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type Relation implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    discountAmount: Float
    expireAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: String
    relatable: Relatable
    relatedTo: RelatableTo
    relationType: RelationType!
    startAt: ISO8601DateTime
    updatedAt: ISO8601DateTime!
    website: Website
    websiteId: ID
}

"The connection type for Relation."
type RelationConnection {
    "A list of edges."
    edges: [RelationEdge!]!
    "A list of nodes."
    nodes: [Relation!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type RelationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Relation!
}

type RelationType implements BaseModelInterface & Node {
    appliesTo: String!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    name: String!
    updatedAt: ISO8601DateTime!
}

type Replenish implements BaseModelInterface & CalculatorInterface & Node {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    preferredAmount: Float!
    preferredSegmentId: ID!
    preferredSkuList: String!
    skuList: [String!]!
    type: String
    updatedAt: ISO8601DateTime!
}

type Report implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    message: String
    reportReason: ReportReason
    status: String
    target: ReportTarget
    targetId: ID
    targetType: String
    updatedAt: ISO8601DateTime!
    user: User
    website: Website
}

"The connection type for Report."
type ReportConnection {
    "A list of edges."
    edges: [ReportEdge!]!
    "A list of nodes."
    nodes: [Report!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ReportEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Report!
}

type ReportReason implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    name: String
    position: Int
    status: String
    updatedAt: ISO8601DateTime!
    website: Website
}

type ReturnItem implements BaseModelInterface & Node {
    acceptanceStatus: String
    acceptanceStatusErrors: String
    additionalTaxTotal: Float!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    customerReturnId: ID
    exchangeVariant: Variant
    gid: ID!
    id: ID!
    includedTaxTotal: Float!
    inventoryUnit: InventoryUnit
    overrideReimbursementTypeId: ID
    preTaxAmount: Float!
    preferredReimbursementTypeId: ID
    receptionStatus: String
    reimbursementId: ID
    resellable: Boolean!
    returnAuthorizationId: ID
    updatedAt: ISO8601DateTime!
}

type Review implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    comment: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    images: [String!]!
    rating: Float!
    reviewable: Reviewable
    reviewableId: ID!
    reviewableType: String!
    source: ReviewSourceType
    sourceId: ID
    sourceType: String
    updatedAt: ISO8601DateTime!
    user: User!
    website: Website!
}

"The connection type for Review."
type ReviewConnection {
    "A list of edges."
    edges: [ReviewEdge!]!
    "A list of nodes."
    nodes: [Review!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ReviewEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Review!
}

type Room implements BaseModelInterface & Node {
    adminRead: Boolean!
    around: Around
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    hasSeen: Boolean
    id: ID!
    lastMessage: Message
    lastMessageId: ID
    members: [Member!]!
    messageCount: Int
    messages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MessageConnection!
    status: String
    test: String
    title: String
    unseen: Boolean
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
}

"The connection type for Room."
type RoomConnection {
    "A list of edges."
    edges: [RoomEdge!]!
    "A list of nodes."
    nodes: [Room!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type RoomEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Room!
}

type SalePrice implements BaseModelInterface & Node {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    createdBy: User
    currency: String
    deletedAt: ISO8601DateTime
    eventLabel: String
    expireAt: ISO8601DateTime
    forceOthers: Boolean
    gid: ID!
    id: ID!
    isEvent: Boolean
    position: Int
    qty: Int
    segment: SupplySegment
    segmentId: ID
    startAt: ISO8601DateTime
    stockLocation: StockLocation
    stockLocationId: ID
    updatedAt: ISO8601DateTime!
    variant: Variant!
    variantId: String!
    website: Website
    websiteId: ID
}

type Screen implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    cinema: Cinema!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    idx: String
    name: String
    svg: String
    updatedAt: ISO8601DateTime!
}

type Segment implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    contactCount: Int
    createdAt: ISO8601DateTime!
    data: JSON
    gid: ID!
    id: ID!
    name: String
    operator: String
    status: String
    updatedAt: ISO8601DateTime!
    website: Website
}

type SegmentClient implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    client: BusinessClient!
    createdAt: ISO8601DateTime!
    data: JSON!
    gid: ID!
    id: ID!
    segment: SupplySegment!
    segmentedAt: ISO8601Date!
    status: String!
    updatedAt: ISO8601DateTime!
}

"The connection type for SegmentClient."
type SegmentClientConnection {
    "A list of edges."
    edges: [SegmentClientEdge!]!
    "A list of nodes."
    nodes: [SegmentClient!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type SegmentClientEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: SegmentClient!
}

type SegmentWhiteList implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    company: String
    createdAt: ISO8601DateTime!
    email: String
    entries: [WhiteListEntry!]!
    entriesCount: Int!
    gid: ID!
    id: ID!
    lastEntryDate: ISO8601DateTime
    mobile: String
    referral: User
    registerNo: String!
    segment: SupplySegment!
    status: String
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
}

"The connection type for SegmentWhiteList."
type SegmentWhiteListConnection {
    "A list of edges."
    edges: [SegmentWhiteListEdge!]!
    "A list of nodes."
    nodes: [SegmentWhiteList!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type SegmentWhiteListEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: SegmentWhiteList!
}

type SegmentWhiteListReport implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    created: Int
    createdAt: ISO8601DateTime!
    createdBy: User
    createdById: ID
    gid: ID!
    id: ID!
    skipped: Int
    total: Int
    updatedAt: ISO8601DateTime!
}

type Series implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    code: String
    createdAt: ISO8601DateTime!
    expiresAt: ISO8601DateTime
    gid: ID!
    id: ID!
    name: String
    no: String
    updatedAt: ISO8601DateTime!
    vendor: Vendor
}

type Session implements Node {
    attributes: [String!]
    cinema: Cinema!
    date: ISO8601Date
    gid: ID!
    id: ID!
    movie: Movie!
    screen: Screen!
    seatPlan: JSON
    seatsAvailable: Int
    tickets: JSON
    time: String
}

type Shipment implements BaseModelInterface & Node {
    additionalTaxTotal: Float
    address: Address
    adjustmentTotal: Float
    canI(action: CanIAction!): Boolean!
    cargoCost: Float
    cost: Float
    createdAt: ISO8601DateTime!
    deliveryPhoto: String
    deliveryPhoto1: String
    digital: Boolean!
    dueDate: ISO8601DateTime
    gid: ID!
    id: ID!
    includedTaxTotal: Float!
    itemTotal: Float!
    lineItemManifest: [ShipmentManifest!]!
    manifest: [ShipmentManifest!]!
    nonTaxableAdjustmentTotal: Float
    number: String!
    order: Order
    packedByEmail: String
    pinCode: String
    preTaxAmount: Float!
    promoTotal: Float
    selectedShippingRate: ShippingRate
    shippedAt: ISO8601DateTime
    shippedBy: User
    shipper: Shipper
    shippingMethods: [ShippingMethod!]
    signature: String
    state: String
    step: Int!
    stockLocation: StockLocation
    taxableAdjustmentTotal: Float
    tracking: String
    updatedAt: ISO8601DateTime!
    weight: Float
}

"The connection type for Shipment."
type ShipmentConnection {
    "A list of edges."
    edges: [ShipmentEdge!]!
    "A list of nodes."
    nodes: [Shipment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ShipmentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Shipment!
}

type ShipmentInventoryUnitStatusType implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    quantity: Int
    status: String
    updatedAt: ISO8601DateTime!
}

type ShipmentLineItemStatusType implements BaseModelInterface & Node {
    adjustmentTotal: Int
    amount: Int!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    gid: ID!
    id: ID!
    inventoryUnits: [ShipmentInventoryUnitStatusType!]!
    price: Int!
    productCat: String
    quantity: Int!
    sellingPrice: Int!
    shipper: Shipper @deprecated(reason: "Use shipment instead")
    status: String
    updatedAt: ISO8601DateTime!
    variant: Variant!
}

type ShipmentManifest implements Node {
    gid: ID!
    id: ID!
    lineItem: LineItem!
    part: Boolean
    product: Product!
    quantity: Int!
    states: JSON!
    total: Float!
    units: [InventoryUnit!]!
    variant: Variant!
}

type ShipmentTracking implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    order: Order!
    orderId: ID!
    pending: Boolean!
    preferences: JSON
    refreshedAt: ISO8601DateTime
    status: String
    target: TrackingTarget
    targetId: ID
    targetType: String
    trackingNumber: String
    type: String!
    updatedAt: ISO8601DateTime!
}

"The connection type for ShipmentTracking."
type ShipmentTrackingConnection {
    "A list of edges."
    edges: [ShipmentTrackingEdge!]!
    "A list of nodes."
    nodes: [ShipmentTracking!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ShipmentTrackingEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ShipmentTracking!
}

type Shipper implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    email: String
    gid: ID!
    id: ID!
    logo: String
    methodsCount: Int!
    name: String
    phoneNumber: String
    "Returns list of shipment"
    shipments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShipmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShipmentConnection!
    "Returns list of shipping methods"
    shippingMethods(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShippingMethodFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShippingMethodConnection!
    status: String
    taxer: Boolean!
    updatedAt: ISO8601DateTime!
    vendor: Vendor
    website: Website!
}

"The connection type for Shipper."
type ShipperConnection {
    "A list of edges."
    edges: [ShipperEdge!]!
    "A list of nodes."
    nodes: [Shipper!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ShipperEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Shipper!
}

type ShipperManifest implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    cost: Float!
    createdAt: ISO8601DateTime!
    description: String
    email: String
    gid: ID!
    id: ID!
    logo: String
    name: String
    phoneNumber: String
    shipments: [Shipment!]!
    status: String
    updatedAt: ISO8601DateTime!
}

type ShippingCategory implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    name: String
    shippingMethods: [ShippingMethod!]!
    step: Int!
    updatedAt: ISO8601DateTime!
    website: Website
}

type ShippingMethod implements BaseModelInterface & Node {
    adminName: String
    calculatorAttributes: JSON
    calculatorType: String
    canI(action: CanIAction!): Boolean!
    channel: String
    code: String
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    description: String
    displayOn: String
    gid: ID!
    id: ID!
    logo: String
    name: String
    phone: String
    shipper: Shipper
    shipperId: ID
    shippingCategories: [ShippingCategory!]!
    shippingCategoryIds: [ID!]!
    step: Int!
    taxCategoryId: ID
    trackingUrl: String
    updatedAt: ISO8601DateTime!
    website: Website
    zoneIds: [ID!]!
    zones: [Zone!]!
}

"The connection type for ShippingMethod."
type ShippingMethodConnection {
    "A list of edges."
    edges: [ShippingMethodEdge!]!
    "A list of nodes."
    nodes: [ShippingMethod!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ShippingMethodEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ShippingMethod!
}

type ShippingRate implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    cost: Float
    createdAt: ISO8601DateTime!
    description: String
    displayCost: String
    gid: ID!
    id: ID!
    name: String
    selected: Boolean
    shipment: Shipment
    shippingMethod: ShippingMethod
    taxRateId: ID
    updatedAt: ISO8601DateTime!
}

type ShopifyAction implements ActionInterface & Node {
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    promotion: Promotion!
    promotionId: ID!
    type: String
}

type ShopifyRule implements Node & RuleInterface {
    code: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    preferences: JSON
    productGroupId: ID
    promotion: Promotion!
    promotionId: ID!
    type: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type ShoppyCampaign implements BaseModelInterface & Node {
    campaignListings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CampaignListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CampaignListingConnection!
    canI(action: CanIAction!): Boolean!
    cover: String
    createdAt: ISO8601DateTime!
    description: String
    endsAt: ISO8601DateTime!
    fulfillDate: ISO8601Date
    gid: ID!
    id: ID!
    itemsCount: Int!
    listingsCount: Int!
    location: String
    maxItemsCount: Int!
    minItemsCount: Int!
    startsAt: ISO8601DateTime!
    status: String!
    title: String!
    updatedAt: ISO8601DateTime!
    "Returns list of variants"
    variants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: VariantFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        permission: VariantsPermission,
        "Sorting functionality"
        sort: SortFilter
    ): VariantConnection!
    vendor: Vendor!
    website: Website!
}

"The connection type for ShoppyCampaign."
type ShoppyCampaignConnection {
    "A list of edges."
    edges: [ShoppyCampaignEdge!]!
    "A list of nodes."
    nodes: [ShoppyCampaign!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ShoppyCampaignEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ShoppyCampaign!
}

type ShoppyForm implements BaseModelInterface & Node {
    active: Boolean
    canI(action: CanIAction!): Boolean!
    cover: String
    createdAt: ISO8601DateTime!
    createdBy: User
    data: JSON
    description: String
    entries(filter: FormEntryFilter): [ShoppyFormEntry!]!
    fieldLabels: [String!]
    fields: [ShoppyFormField!]!
    gid: ID!
    id: ID!
    permalink: String
    preferences: JSON
    title: String
    updatedAt: ISO8601DateTime!
    website: Website
}

type ShoppyFormAnswer implements BaseModelInterface & Node {
    body: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    entry: ShoppyFormEntry!
    field: ShoppyFormField!
    gid: ID!
    id: ID!
    updatedAt: ISO8601DateTime!
}

"The connection type for ShoppyForm."
type ShoppyFormConnection {
    "A list of edges."
    edges: [ShoppyFormEdge!]!
    "A list of nodes."
    nodes: [ShoppyForm!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type ShoppyFormEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ShoppyForm!
}

type ShoppyFormEntry implements BaseModelInterface & Node {
    answers: [ShoppyFormAnswer!]!
    availableFields: JSON
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    form: ShoppyForm!
    gid: ID!
    id: ID!
    note: String
    status: String
    updatedAt: ISO8601DateTime!
    user: User
    website: Website!
}

type ShoppyFormField implements BaseModelInterface & Node {
    active: Boolean!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    description: String
    fieldType: String
    gid: ID!
    id: ID!
    label: String
    position: Int
    preferences: JSON
    updatedAt: ISO8601DateTime!
}

type SimpleInAppInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceId: String
    invoiceNumber: String
    updatedAt: ISO8601DateTime!
}

type SimpleInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceId: String
    invoiceNumber: String
    qrLink: String
    updatedAt: ISO8601DateTime!
}

type SizingGuide implements BaseModelInterface & Node {
    ageGroup: String
    brand: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    csv: JSON
    data: String
    description: String
    gender: String
    gid: ID!
    grouping: String
    id: ID!
    store: Brand
    title: String
    updatedAt: ISO8601DateTime!
    vendor: Vendor
}

"The connection type for SizingGuide."
type SizingGuideConnection {
    "A list of edges."
    edges: [SizingGuideEdge!]!
    "A list of nodes."
    nodes: [SizingGuide!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type SizingGuideEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: SizingGuide!
}

type Sms implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    content: String
    createdAt: ISO8601DateTime!
    expireAfter: Int
    from: String
    gid: ID!
    id: ID!
    operator: String
    price: Float
    sender: String
    sentAt: ISO8601DateTime
    sourceId: ID
    sourceType: String
    status: String
    to: String
    updatedAt: ISO8601DateTime!
    website: Website
}

"The connection type for Sms."
type SmsConnection {
    "A list of edges."
    edges: [SmsEdge!]!
    "A list of nodes."
    nodes: [Sms!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type SmsEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Sms!
}

type SonoInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceId: String
    invoiceNumber: String
    qrString: String
    updatedAt: ISO8601DateTime!
}

type Stage implements BaseModelInterface & Node {
    blocks: [String!]
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    gid: ID!
    id: ID!
    locks: [String!]
    name: String
    pending(cart: Boolean): [String!]!
    product: Product
    seats: [String!]
    sold: [String!]!
    svg: String
    updatedAt: ISO8601DateTime!
    variation: JSON
    views: JSON
}

type State implements Node {
    abbr: String
    children: [District!]!
    country: Country
    districts: [District!]!
    gid: ID!
    id: ID!
    name: String
    preferences: JSON
    updatedAt: ISO8601DateTime
}

type StateChange implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String
    nextState: String
    previousState: String
    statefulId: ID
    statefulType: String
    updatedAt: ISO8601DateTime!
    user: User
}

"The connection type for State."
type StateConnection {
    "A list of edges."
    edges: [StateEdge!]!
    "A list of nodes."
    nodes: [State!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type StateEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: State!
}

type StaticRate implements BaseModelInterface & CalculatorInterface & Node {
    calculableId: Int
    calculableType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    preferences: JSON
    preferredAmount: Float!
    preferredCurrency: String!
    type: String
    updatedAt: ISO8601DateTime!
}

type StockCountType implements BaseModelInterface & Node {
    backorderable: Boolean!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    onHand: Int!
    stockLocation: StockLocation
    updatedAt: ISO8601DateTime!
}

type StockItem implements BaseModelInterface & Node {
    backorderable: Boolean
    canI(action: CanIAction!): Boolean!
    countOnHand: Int!
    countOnStockLocation: Int! @deprecated(reason: "Will be removed in future")
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    stockLocation: StockLocation
    stockLocationId: ID!
    updatedAt: ISO8601DateTime!
    variant: Variant
}

"The connection type for StockItem."
type StockItemConnection {
    "A list of edges."
    edges: [StockItemEdge!]!
    "A list of nodes."
    nodes: [StockItem!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type StockItemEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: StockItem!
}

type StockLocation implements BaseModelInterface & Node {
    active: Boolean
    address1: String
    address2: String
    adminName: String
    backorderableDefault: Boolean
    canI(action: CanIAction!): Boolean!
    city: String
    code: String
    countryId: ID
    createdAt: ISO8601DateTime!
    default: Boolean!
    gid: ID!
    id: ID!
    name: String
    phone: String
    propagateAllVariants: Boolean
    stateId: ID
    stateName: String
    stockCount(excludeOrderId: ID, variantId: ID!): StockCountType
    storeLocation: StoreLocation
    timeSheets: JSON
    updatedAt: ISO8601DateTime!
    vendor: Vendor
    zipcode: String
}

"The connection type for StockLocation."
type StockLocationConnection {
    "A list of edges."
    edges: [StockLocationEdge!]!
    "A list of nodes."
    nodes: [StockLocation!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type StockLocationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: StockLocation!
}

type StoreCredit implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    amountUsed: Float
    canI(action: CanIAction!): Boolean!
    category: StoreCreditCategory
    categoryId: ID
    createdAt: ISO8601DateTime!
    currency: String
    gid: ID!
    id: ID!
    memo: String
    originAmount: JSON
    originText: String
    originator: StoreCreditOriginator
    originatorId: ID
    originatorType: String
    payments: [Payment!]!
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
}

type StoreCreditCategory implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    name: String!
    taxable: Boolean!
    updatedAt: ISO8601DateTime!
}

"The connection type for StoreCredit."
type StoreCreditConnection {
    "A list of edges."
    edges: [StoreCreditEdge!]!
    "A list of nodes."
    nodes: [StoreCredit!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type StoreCreditEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: StoreCredit!
}

type StoreCreditEvent implements BaseModelInterface & Node {
    action: String!
    amount: Float!
    authorizationCode: String!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    order: Order
    originatorId: ID
    originatorType: String
    storeCredit: StoreCredit!
    storeCreditId: ID!
    updatedAt: ISO8601DateTime!
    userTotalAmount: Float!
}

"The connection type for StoreCreditEvent."
type StoreCreditEventConnection {
    "A list of edges."
    edges: [StoreCreditEventEdge!]!
    "A list of nodes."
    nodes: [StoreCreditEvent!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type StoreCreditEventEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: StoreCreditEvent!
}

type StoreCreditReport implements BaseModelInterface & Node {
    action: String
    amount: Float
    authorizationCode: String
    byOriginUsedAmount: JSON
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    number: String
    storeCredit: StoreCredit
    type: String
    updatedAt: ISO8601DateTime!
    userTotalAmount: Float
}

type StoreItem {
    countOnHand: Int!
    storeLocation: StoreLocation
}

type StoreListing implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    listing: Listing
    status: String
    updatedAt: ISO8601DateTime!
    vendor: Vendor
}

"The connection type for StoreListing."
type StoreListingConnection {
    "A list of edges."
    edges: [StoreListingEdge!]!
    "A list of nodes."
    nodes: [StoreListing!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type StoreListingEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: StoreListing!
}

type StoreLocation implements BaseModelInterface & Node {
    address: String
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    brandNames: String
    "Returns list of brands"
    brands(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BrandFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BrandConnection!
    businessType: BusinessType
    canI(action: CanIAction!): Boolean!
    clientsStore: ClientsStore
    code: String
    createdAt: ISO8601DateTime!
    departmentStore: DepartmentStore
    distance: Float
    driverIds: [ID!]!
    drivers: [User!]!
    "Store location staffs"
    employees(role: String): [AssetRole!]
    externalStockLocationIds: [ID!]!
    floor: Int
    gid: ID!
    id: ID!
    image: ImageVariation
    locationAddress: Address
    managerId: ID
    map: String
    phone: String
    photo: String
    position: Int
    preferences: JSON
    schedule: JSON
    stockLocationIds: [ID!]!
    "Returns list of ETickets"
    stockLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StockLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StockLocationConnection!
    store: Brand
    timeSheets: JSON
    title: String
    updatedAt: ISO8601DateTime!
    vendor: Vendor
    winterTimeSheets: JSON
}

"The connection type for StoreLocation."
type StoreLocationConnection {
    "A list of edges."
    edges: [StoreLocationEdge!]!
    "A list of nodes."
    nodes: [StoreLocation!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type StoreLocationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: StoreLocation!
}

type StorePayInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceId: String
    mobile: String
    updatedAt: ISO8601DateTime!
}

type Subscription {
    "when business client status changed"
    businessClientUpdated(id: ID!): BusinessClient
    "New chat room for user"
    chatRoomUpdated: Room
    "new dispatch call on shopper"
    dispatchCall: DispatchCall
    "subscribe to inventory swap requests"
    inventorySwapRequested(id: ID!): Order
    "When background job progress updates"
    jobUpdated(id: ID!): JobLog
    "New messaged added on chat room"
    newChatMessage: Message
    "Notification created"
    newNotification: Notification
    notificationUpdated: Int
    "when order changed"
    orderUpdated(id: ID!): Order
}

type SubscriptionManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    id: ID!
    image: String
    listings: [Listing!]!
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    productCat: String
    sku: String
    slug: String!
    subscriptionType: String!
    totalOnHand: Int
    vendor: Vendor
    weight: Float
}

type SupplierCategory implements BaseModelInterface & Node {
    active: Boolean
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    "Returns list of merchants"
    merchants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MerchantFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MerchantConnection!
    name: String
    position: Int
    updatedAt: ISO8601DateTime!
    website: Website
    websiteId: ID
}

"The connection type for SupplierCategory."
type SupplierCategoryConnection {
    "A list of edges."
    edges: [SupplierCategoryEdge!]!
    "A list of nodes."
    nodes: [SupplierCategory!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type SupplierCategoryEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: SupplierCategory!
}

type SupplySegment implements BaseModelInterface & Node {
    active: Boolean!
    "Returns list of employees"
    businessUsers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessUserFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): EmployeeConnection!
    businessUsersSegmentIds(filter: BusinessUsersSegmentFilter): [ID!]!
    businessUsersSegments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessUsersSegmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BusinessUsersSegmentConnection!
    canI(action: CanIAction!): Boolean!
    "Returns list of business clients"
    clients(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessClientFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BusinessClientConnection!
    clientsCount: Int!
    code: String
    createdAt: ISO8601DateTime!
    createdBy: User
    createdById: ID
    gid: ID!
    id: ID!
    name: String!
    originId: ID
    preferences: JSON!
    "Returns list of promotions"
    promotions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        dateType: String,
        filter: PromotionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        from: String,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        to: String
    ): PromotionConnection!
    "Returns list of segment clients"
    segmentClientIds(filter: SegmentClientFilter): [ID!]!
    "Returns list of segment clients"
    segmentClients(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SegmentClientFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SegmentClientConnection!
    type: String
    updatedAt: ISO8601DateTime!
    userSegmentIds(filter: UserSegmentFilter): [ID!]!
    userSegments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserSegmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserSegmentConnection!
    "Returns list of users"
    users(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserConnection!
    usersCount: Int!
    vendor: Vendor!
    vendorId: ID!
    websiteIds: [ID!]!
    websites: [Website!]!
    "Returns list of white"
    whiteLists(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SegmentWhiteListFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SegmentWhiteListConnection!
}

"The connection type for SupplySegment."
type SupplySegmentConnection {
    "A list of edges."
    edges: [SupplySegmentEdge!]!
    "A list of nodes."
    nodes: [SupplySegment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type SupplySegmentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: SupplySegment!
}

type Tag implements Node {
    articlesCount: Int
    authorsCount: Int
    gid: ID!
    id: ID!
    impressionsCount: Int
    name: String
    taggingsCount: Int
}

"The connection type for Tag."
type TagConnection {
    "A list of edges."
    edges: [TagEdge!]!
    "A list of nodes."
    nodes: [Tag!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

type TagCount implements Node {
    gid: ID!
    id: ID!
    name: String
    taggingsCount: Int
}

"An edge in a connection."
type TagEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Tag!
}

type TaxCategory implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    isDefault: Boolean
    name: String!
    taxCode: String
    updatedAt: ISO8601DateTime!
    website: Website
    websiteId: ID
}

"The connection type for TaxCategory."
type TaxCategoryConnection {
    "A list of edges."
    edges: [TaxCategoryEdge!]!
    "A list of nodes."
    nodes: [TaxCategory!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type TaxCategoryEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TaxCategory!
}

type TaxRate implements BaseModelInterface & Node {
    amount: Float!
    calculatorAttributes: JSON
    calculatorType: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    includedInPrice: Boolean!
    name: String!
    showRateInLabel: Boolean!
    taxCategory: TaxCategory
    taxCategoryId: ID
    updatedAt: ISO8601DateTime!
    website: Website
    websiteId: ID
    zone: Zone
    zoneId: ID
}

"The connection type for TaxRate."
type TaxRateConnection {
    "A list of edges."
    edges: [TaxRateEdge!]!
    "A list of nodes."
    nodes: [TaxRate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type TaxRateEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TaxRate!
}

type Taxon implements BaseModelInterface & Node {
    absoluteTaxCode: String
    bannerLink: String
    canI(action: CanIAction!): Boolean!
    children: [Taxon!]!
    childrenCount: Int!
    createdAt: ISO8601DateTime!
    data: JSON
    depth: Int
    description: String
    expanded: Boolean
    gid: ID!
    hasChildren: Boolean!
    icon: String
    iconUpdatedAt: ISO8601DateTime
    id: ID!
    imeiCodesEnabled: Boolean
    isAdult: Boolean
    isDisabled: Boolean
    keywords: [Keyword!]!
    labelCodesEnabled: Boolean
    lft: Int
    "Тухайн харилцагчийн авч болох бүх Listing жагсаалтын буцаана"
    listings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    listingsCount: Int!
    metaDescription: String
    metaKeywords: String
    metaTitle: String
    name: String
    optionTypes: [OptionType!]!
    parent: Taxon
    parentId: ID
    permalink: String!
    position: Int
    prettyName: String
    properties: [Property!]!
    propertyIds: [ID!]!
    prototypes: [Prototype!]!
    queryString: String
    rgt: Int
    seoTitle: String
    taxCode: String
    translationEn: String
    updatedAt: ISO8601DateTime!
    website: Website
}

"The connection type for Taxon."
type TaxonConnection {
    "A list of edges."
    edges: [TaxonEdge!]!
    "A list of nodes."
    nodes: [Taxon!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type TaxonEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Taxon!
}

type TdbmLeaseSource implements BaseModelInterface & Node & PaymentSourceInterface {
    acceptedMonths: Int
    amount: Float
    bankMessage: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    customerFee: Float
    downPayment: Float
    gid: ID!
    id: ID!
    incomeConfirm: Boolean
    interest: Float
    limit: Float
    longMessage: String
    merchantFee: Float
    months: Int
    paymentMethod: PaymentMethod!
    repaymentDay: Int
    requirements: String
    termsAccepted: Boolean
    updatedAt: ISO8601DateTime!
    user: User!
}

type Template implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    html: String
    id: ID!
    name: String
    text: String
    updatedAt: ISO8601DateTime!
    website: Website
}

"ETicket/Coupon pdf template"
type TicketTemplate implements BaseModelInterface & Node {
    body: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    height: Int
    id: ID!
    pos: Boolean
    sku: String
    storeLocation: StoreLocation
    updatedAt: ISO8601DateTime!
    vendor: Vendor
    website: Website
    width: Int
}

"The connection type for TicketTemplate."
type TicketTemplateConnection {
    "A list of edges."
    edges: [TicketTemplateEdge!]!
    "A list of nodes."
    nodes: [TicketTemplate!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type TicketTemplateEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TicketTemplate!
}

type TicketType implements Node {
    area: String
    cinema: Cinema!
    code: String
    description: String
    gid: ID!
    id: ID!
    idx: String
    isComplimentary: Boolean
    isPackage: Boolean
    isRedemption: Boolean
    movieTickets: MovieTicket!
    name: String
    price: Int
    session: Session!
    tax: Int
}

type TokiInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceId: String
    invoiceNumber: String
    mobile: String
    requestId: String
    status: String
    updatedAt: ISO8601DateTime!
}

type TrackableType implements BaseModelInterface & Node {
    acceptedOrderCount: Int
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    distance: Float
    gid: ID!
    id: ID!
    isAvailable: Boolean!
    lastTrackingDate: ISO8601DateTime
    latitude: String
    longitude: String
    orderCount: Int
    rejectedOrderCount: Int
    trackings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TrackingTypeConnection!
    updatedAt: ISO8601DateTime!
    user: User
    website: Website
}

"The connection type for TrackableType."
type TrackableTypeConnection {
    "A list of edges."
    edges: [TrackableTypeEdge!]!
    "A list of nodes."
    nodes: [TrackableType!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type TrackableTypeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TrackableType!
}

type TrackingType implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    latitude: String
    longitude: String
    trackable: TrackableType!
    updatedAt: ISO8601DateTime!
}

"The connection type for TrackingType."
type TrackingTypeConnection {
    "A list of edges."
    edges: [TrackingTypeEdge!]!
    "A list of nodes."
    nodes: [TrackingType!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type TrackingTypeEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TrackingType!
}

type Transaction implements BaseModelInterface & Node {
    action: String!
    amount: Float!
    amountLeft: Float
    amountRepaid: Float
    archived: Boolean!
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    authorizedAt: ISO8601DateTime
    authorizedBy: User
    authorizedById: ID
    balance: Float
    bonus: Float!
    canI(action: CanIAction!): Boolean!
    cgw: CorporateGateway
    cgwId: ID
    code: String
    createdAt: ISO8601DateTime!
    currency: String!
    description: String
    dueDate: ISO8601DateTime
    gid: ID!
    id: ID!
    isCredit: Boolean!
    isDebit: Boolean!
    isLoan: Boolean!
    isRepaid: Boolean
    loan: Transaction
    loanStatus: String!
    number: String
    relatedAccount: String
    repayments: [Transaction!]!
    source: Source
    status: String!
    transactionAt: ISO8601DateTime
    transactionDate: ISO8601Date
    typeCode: String!
    updatedAt: ISO8601DateTime!
    verificationSentAt: ISO8601DateTime
    wallet: Wallet!
    walletCode: String!
    website: Website!
    xxoatTransactions: [Transaction!]!
}

"The connection type for Transaction."
type TransactionConnection {
    "A list of edges."
    edges: [TransactionEdge!]!
    "A list of nodes."
    nodes: [Transaction!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type TransactionEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Transaction!
}

type UPointCard implements BaseModelInterface & Node {
    balance: Float
    bonus: Float
    canI(action: CanIAction!): Boolean!
    cardNumber: String
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    uPointCreatedAt: String
    uPointId: String
    updatedAt: ISO8601DateTime!
    user: User!
    website: Website!
}

type UbcAddress implements Node {
    address: Addressable
    addressId: ID
    addressType: String
    gid: ID!
    id: ID!
    source: JSON
    ubcAddressId: ID
}

type User implements BaseModelInterface & Node {
    accessToken: String
    appsflyerAppId: String
    appsflyerId: String
    "Returns list of assets"
    assetRoles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AssetFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AssetRoleConnection!
    audits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuditConnection!
    authenticationToken: String
    avatar: String
    averageRating: Float!
    bankAccounts: JSON!
    banks: [Bank!]!
    billAddress: Address
    billAddressId: ID
    birthday: ISO8601Date
    businessEmployments(merchantOnly: Boolean, vendorId: ID): [Employee!]!
    "Returns list of business clients"
    businessSuppliers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessClientFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BusinessClientConnection
    canI(action: CanIAction!): Boolean!
    "Paid but cancelled"
    cancelledCommercesCount: Int!
    "Paid but cancelled"
    cancelledPurchasesCount: Int!
    cards: [Card!]!
    "Returns list of orders"
    claimedOrders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        status: OrderStatus
    ): OrderConnection!
    clickGobozorMiniAppAcceptance: Boolean
    clickMiniAppAcceptance: Boolean
    "Returns list of orders"
    commerceOrders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        status: OrderStatus
    ): OrderConnection!
    confirmationSentAt: ISO8601DateTime
    confirmedAt: ISO8601DateTime
    "Returns list of promotions"
    coupons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CouponFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CouponConnection!
    createdAt: ISO8601DateTime!
    currentEvent(event: String): JSON
    currentOrder(currency: String, flag: String, key: String, number: String, orderToken: String): Order
    currentSignInAt: ISO8601DateTime
    currentSignInIp: String
    "Returns a wallet"
    currentWallet(websiteId: ID): Wallet!
    deletedAt: ISO8601DateTime
    "Returns list of One Signal devices"
    devices(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OneSignalDeviceFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        segmentId: ID,
        "Sorting functionality"
        sort: SortFilter
    ): DeviceConnection!
    downloadables(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DownloadableFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PurchasedDownloadableConnection!
    "тухайн сайт дахь хэрэглэгчийн цахим тасалбарын тоо"
    eTicketCount: Int!
    "Returns list of ETickets"
    eTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ETicketFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ETicketConnection!
    eduDegree: String
    education: UserEducation
    email: String
    emergencyContacts: [EmergencyContact!]!
    employment: UserEmployment
    failedAttempts: Int!
    familyName: String
    finance: UserFinance
    firstName: String
    "Returns followers list"
    followers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FollowerFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FollowerConnection!
    gender: String
    gid: ID!
    golomtCards: [GolomtCard!]!
    id: ID!
    isValidUserClearance: Boolean
    "KYC interface"
    kyc(type: String!): KycInterface
    lastName: String
    lastRequestAt: ISO8601DateTime
    lastSignInAt: ISO8601DateTime
    lastSignInIp: String
    leasingInfo: LeasingInfo
    "тухайн сайт дахь хэрэглэгчийн лицензийн тоо"
    licenseCount: Int!
    licenses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: LicenseFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): LicenseConnection!
    "Тухайн харилцагчийн авч болох бүх Listing жагсаалтын буцаана"
    listings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    loanContracts: [Contract!]!
    lockedAt: ISO8601DateTime
    login: String
    loyaltyCard: LoyaltyCard
    mailBounced: Boolean
    mailComplained: Boolean
    maritalStatus: String
    "Returns list of merchants"
    merchants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MerchantFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MerchantConnection!
    mobile: String
    mobileConfirmationSentAt: ISO8601DateTime
    mobileConfirmedAt: ISO8601DateTime
    "тухайн сайт дахь хэрэглэгчийн кино тасалбарын тоо"
    movieTicketCount: Int!
    "Returns list of movie tickets"
    movieTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MovieTicketFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MovieTicketConnection!
    myReview: Review
    nationality: String
    ndCode: String
    ndCodeAt: ISO8601DateTime
    orderCount: Int!
    "Returns list of order templates"
    orderTemplates(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderTemplateFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): OrderTemplateConnection!
    "Returns list of orders"
    orders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        status: OrderStatus
    ): OrderConnection!
    passport: String
    passportBack: String
    "Paid, not delivered"
    pendingCommercesCount: Int!
    "Paid but not delivered"
    pendingPurchasesCount: Int!
    perishableToken: String
    persistenceToken: String
    portrait: String
    "Prescriptions list"
    prescriptions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PrescriptionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PrescriptionConnection!
    publishedListingsCount: Int!
    "тухайн сайт дахь хэрэглэгчийн захиалгын тоо"
    purchaseCount: Int!
    qPayCards: [QPayCard!]!
    "Returns recently viewed listings on current website for the user."
    recentlyViewedListings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): RecentlyViewedListingConnection!
    referralSource: String
    registerNum: String
    rememberCreatedAt: ISO8601DateTime
    rememberToken: String
    resetPasswordSentAt: ISO8601DateTime
    resetPasswordToken: String
    reviews(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ReviewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        isDeleted: Boolean,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ReviewConnection!
    roleMatrix: JSON
    roles: [String!]!
    savedArticles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserArticleFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserArticleConnection!
    segmentIds(byWebsiteVendor: Boolean): [ID!]!
    segments: [SupplySegment!]!
    shipAddress: Address
    "Paid and shipped"
    shippedCommercesCount: Int!
    shippedCount(from: ISO8601DateTime, to: ISO8601DateTime): Int!
    "Paid and shipped"
    shippedPurchasesCount: Int!
    shoppyHubEntryCount: Int!
    shoppyTrackable: TrackableType
    signInCount: Int!
    storeCreditBalance: JSON!
    storeCreditEvents(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreCreditEventFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreCreditEventConnection!
    storeLocationIds: [ID!]!
    subscribed: Boolean
    takenCount(from: ISO8601DateTime, to: ISO8601DateTime): Int!
    "тухайн сайт дахь хэрэглэгчийн захиалгын нийт дүн"
    totalPurchase: Float!
    totalReviews: Int!
    totpEnabled: Boolean!
    totpLink: String!
    uPointCard: UPointCard
    unapprovedListingsCount: Int!
    unconfirmedEmail: String
    unconfirmedMobile: String
    unlockToken: String
    "Payment pending"
    unpaidPurchasesCount: Int!
    unpublishedListingsCount: Int!
    updatedAt: ISO8601DateTime!
    "Returns list of address for an user"
    userAddresses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserAddressFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserAddressConnection!
    userAuthentications: [UserAuthentication!]!
    userInvitationCode: String
    userSegments: [UserSegment!]!
    validatedBirthday: String
    validatedFirstName: String
    validatedLastName: String
    validatedMiddleName: String
    validatedPassportNumber: String
    validatedPinFl: String
    "KYC interface"
    vccRequest(id: ID, requestId: ID): VCCRequest
    verifiedAt: ISO8601DateTime
    "Returns list of promotions"
    vouchers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        dateType: String,
        filter: PromotionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        from: String,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        to: String
    ): PromotionConnection!
    "Тухайн сайт дахь хэрэглэгчийн хэтэвчний үлдэгдэл"
    wallet: Float!
    wallets: [Wallet!]!
    website: Website
    websiteAgreement(websiteId: ID): UserAgreement
    websiteAgreements: [UserAgreement!]
    wishlist(accessHash: String): Wishlist
    xpartnersClickId: String
    xpartnersExpireAt: ISO8601DateTime
}

type UserAddress implements BaseModelInterface & Node {
    address: Address
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    updatedAt: ISO8601DateTime!
    user: User
}

"The connection type for UserAddress."
type UserAddressConnection {
    "A list of edges."
    edges: [UserAddressEdge!]!
    "A list of nodes."
    nodes: [UserAddress!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type UserAddressEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: UserAddress!
}

type UserAgreement implements BaseModelInterface & Node {
    calculatedAt: ISO8601Date!
    canI(action: CanIAction!): Boolean!
    cartState: String
    cartTotal: Float!
    createdAt: ISO8601DateTime!
    currency: String
    gid: ID!
    id: ID!
    ordersCount: Int!
    ordersTotal: Float!
    storeLocation: StoreLocation
    updatedAt: ISO8601DateTime!
    user: User!
    website: Website
}

"The connection type for UserAgreement."
type UserAgreementConnection {
    "A list of edges."
    edges: [UserAgreementEdge!]!
    "A list of nodes."
    nodes: [UserAgreement!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type UserAgreementEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: UserAgreement!
}

type UserArticle implements BaseModelInterface & Node {
    article: Article
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: JSON
    gid: ID!
    id: ID!
    updatedAt: ISO8601DateTime!
    user: User
    website: Website
}

"The connection type for UserArticle."
type UserArticleConnection {
    "A list of edges."
    edges: [UserArticleEdge!]!
    "A list of nodes."
    nodes: [UserArticle!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type UserArticleEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: UserArticle!
}

type UserAuthentication implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    provider: String!
    token: String
    uid: String!
    updatedAt: ISO8601DateTime!
    user: User!
}

"The connection type for User."
type UserConnection {
    "A list of edges."
    edges: [UserEdge!]!
    "A list of nodes."
    nodes: [User!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type UserEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User!
}

type UserEducation implements BaseModelInterface & Node {
    active: Boolean
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    degree: String
    gid: ID!
    id: ID!
    profession: String
    school: String
    since: ISO8601Date
    updatedAt: ISO8601DateTime!
    user: User
}

type UserEmployment implements BaseModelInterface & Node {
    address: String
    canI(action: CanIAction!): Boolean!
    company: String
    companyFullName: String
    createdAt: ISO8601DateTime!
    employeeCount: String
    gid: ID!
    id: ID!
    jobTitle: String
    phone: String
    since: ISO8601Date
    updatedAt: ISO8601DateTime!
    user: User
    years: String
}

type UserFinance implements BaseModelInterface & Node {
    businessIncome: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    creditLimit: Float
    gid: ID!
    groceryOutcome: Float
    hasCreditcard: Boolean
    hasLoan: Boolean
    householdOutcome: Float
    id: ID!
    income: Float
    loanExceed60: Boolean
    loanpaymentAmoutMonthly: Float
    otherIncome: Float
    otherOutcome: Float
    updatedAt: ISO8601DateTime!
    user: User
}

type UserInvitation implements BaseModelInterface & Node {
    acceptedCount: Int!
    accepts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): InvitationAcceptConnection!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    generatedAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invitation: Invitation!
    invitationId: ID!
    number: String!
    sharedCount: Int!
    updatedAt: ISO8601DateTime!
    user: User!
    userId: ID!
    website: Website!
    websiteId: ID!
}

"The connection type for UserInvitation."
type UserInvitationConnection {
    "A list of edges."
    edges: [UserInvitationEdge!]!
    "A list of nodes."
    nodes: [UserInvitation!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type UserInvitationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: UserInvitation!
}

type UserSegment implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    expiresAt: ISO8601Date!
    gid: ID!
    id: ID!
    segment: SupplySegment!
    segmentId: ID!
    sourceId: ID
    sourceType: String
    status: String!
    total: Int!
    updatedAt: ISO8601DateTime!
    usedCount: Int!
    user: User!
    userId: ID!
    website: Website!
    websiteId: ID!
}

"The connection type for UserSegment."
type UserSegmentConnection {
    "A list of edges."
    edges: [UserSegmentEdge!]!
    "A list of nodes."
    nodes: [UserSegment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type UserSegmentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: UserSegment!
}

type UserSelectableGiftPromises implements ActionInterface & Node {
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    preferredInterval: Int
    preferredLimit: Int
    preferredMatchPolicy: String!
    preferredRule: String!
    promotion: Promotion!
    promotionActionLineItems: [PromotionActionLineItem!]!
    promotionId: ID!
    type: String
}

type UserSelectableItems implements ActionInterface & Node {
    calculator: CalculatorInterface!
    deletedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    position: Int
    preferences: JSON
    preferredExcludeOnSale: Boolean!
    preferredLimit: Int
    promotion: Promotion!
    promotionActionLineItems: [PromotionActionLineItem!]!
    promotionId: ID!
    type: String
}

type UserToken implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    duration: Int!
    generatedAt: ISO8601DateTime
    gid: ID!
    id: ID!
    number: String
    updatedAt: ISO8601DateTime!
    usedAt: ISO8601DateTime
    usedBy: User
    user: User
    website: Website
}

type UserVerification implements BaseModelInterface & Node {
    approvedAt: ISO8601DateTime
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    message: String
    passport: String
    passportApprovedAt: ISO8601DateTime
    passportBack: String
    passportBackApprovedAt: ISO8601DateTime
    passportBackRejectedAt: ISO8601DateTime
    passportRejectedAt: ISO8601DateTime
    rejectedAt: ISO8601DateTime
    requestedAt: ISO8601DateTime
    selfie: String
    selfieApprovedAt: ISO8601DateTime
    selfieRejectedAt: ISO8601DateTime
    status: String
    updatedAt: ISO8601DateTime!
    user: User!
    userId: ID!
    website: Website!
    websiteId: ID!
}

type UzumNasiyaSource implements BaseModelInterface & Node & PaymentSourceInterface {
    buyerId: String
    canI(action: CanIAction!): Boolean!
    canceledAt: ISO8601Date
    confirmedAt: ISO8601Date
    createdAt: ISO8601DateTime!
    gid: ID!
    hasLimit: Boolean!
    id: ID!
    invoiceNo: String
    mobile: String
    orderNo: String
    paymentMethod: PaymentMethod!
    paymentMethodId: ID!
    period: String
    periods: JSON
    response: JSON
    status: String
    updatedAt: ISO8601DateTime!
    user: User!
    userId: ID!
    webview: String
}

type VCCRequest implements BaseModelInterface & Node {
    amount: Float
    branchId: String
    canI(action: CanIAction!): Boolean!
    chrgAmount: Float
    confAmount: Float
    confirmedDate: ISO8601DateTime
    createdAt: ISO8601DateTime!
    crnCode: String
    disbChrgInt: Float
    embossName: String
    feePercent: Float
    gid: ID!
    id: ID!
    instType: String
    interest: Float
    loanAccount: String
    loanSubType: String
    loanType: String
    monthlyAmount: Float
    payDay: ISO8601DateTime
    period: Int
    preferences: JSON
    prepaidAmt: Float
    prodCode: String
    prodType: String
    registerNum: String
    requestId: String
    scoringAmount: Float
    scoringDate: ISO8601DateTime
    scoringReason: String
    staffInterest: Float
    status: String
    topupFlg: String
    updatedAt: ISO8601DateTime!
    userId: ID
}

type Variant implements BaseModelInterface & Node {
    associatedAudits: [Audit!]!
    backorderable: Boolean
    barcode: String
    bonusPoint: Float
    canI(action: CanIAction!): Boolean!
    canSupply: Boolean!
    costCurrency: String
    costPrice: Float
    createdAt: ISO8601DateTime!
    currency: String
    defaultPrices: [Price!]!
    deletedAt: ISO8601DateTime
    depth: Float
    description: String
    discontinueOn: ISO8601DateTime
    downloadableAttachments: [DownloadableAttachment!]!
    eventEndDate: ISO8601DateTime
    eventPrice: Float
    fragile: Boolean!
    gid: ID!
    hasRules: Boolean!
    height: Float
    hsCode: String
    id: ID!
    image(
        "Use CDN Mirror ? defaults to TRUE"
        mirror: Boolean = true,
        "Alias"
        size: ProductImageSize
    ): String
    imageLinks: [String!]!
    images: [ProductImage!]!
    isBackorderable: Boolean!
    isMaster: Boolean!
    labelCode: String
    listedWebsites: [Website!]!
    manifestImage: String
    manifestName: String!
    manifestSlug: String!
    merchantSku: String
    name: String
    netWeight: Float
    nonReturnable: Boolean!
    nutritionFact: NutritionFact
    optionValues: [OptionValue!]!
    optionsText: String!
    originalPrice: Float
    packageCode: String
    parent: Variant
    partsVariants: [AssemblyPart!]!
    position: Int
    price(
        "currency"
        currency: String,
        "Optional stock location id"
        stockLocationId: ID
    ): Float!
    prices: [SalePrice!]!
    product: Product!
    purchasable: Boolean!
    rules: [VariantRule!]!
    saleEndDate: ISO8601DateTime
    salePrice(
        "optional currency"
        currency: String
    ): Float
    salePrices(active: Boolean, currency: String): [SalePrice!]!
    saleStartDate: ISO8601DateTime
    sellingPrice(
        "currency"
        currency: String,
        "stock location id"
        stockLocationId: ID,
        "optional website id"
        websiteId: ID
    ): Float!
    series: Series
    sku: String!
    slug: String!
    stockCounts(excludeOrderId: ID, stockLocationId: ID): [StockCountType!]
    stockItems(stockLocationIds: [ID!]): [StockItem!]!
    "Returns list of ETickets"
    stockLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StockLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StockLocationConnection
    stockLocked: Boolean
    storeItems: [StoreItem!]!
    taxCode: String
    "Total count on hand"
    totalCountOnHand: Float! @deprecated(reason: "Will be removed in future")
    "Find count on hand for locations"
    totalCountOnStockLocations(stockLocationIds: [ID!]): Float! @deprecated(reason: "Will be removed in future")
    totalOnHand: Float!
    trackInventory: Boolean
    updatedAt: ISO8601DateTime!
    variantSeries: [Variant!]!
    vendor: Vendor
    websitePrices: [SalePrice!]! @deprecated(reason: "Will be removed in future")
    weight: Float
    width: Float
}

"The connection type for Variant."
type VariantConnection {
    "A list of edges."
    edges: [VariantEdge!]!
    "A list of nodes."
    nodes: [Variant!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type VariantEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Variant!
}

type VariantRule implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    ratio: Float!
    targetVariant: Variant!
    targetVariantId: ID!
    updatedAt: ISO8601DateTime!
    variant: Variant!
    variantId: ID!
    website: Variant!
    websiteId: ID!
}

type Vendor implements BaseModelInterface & Node {
    address: String
    averageRating: Float!
    "Returns list of branches of given company"
    branches(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BranchFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BranchConnection
    businessClientAttachments: [BusinessVerificationAttachmentType!]
    "Returns business clients of current vendor"
    businessClients(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessClientFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BusinessClientConnection
    businessSupplier: BusinessClient
    "Returns business owners of current vendor"
    businessSuppliers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessClientFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BusinessClientConnection
    campaigns(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CampaignFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShoppyCampaignConnection!
    canI(action: CanIAction!): Boolean!
    category: String
    cdq: [ID!]
    channel(websiteId: ID): Merchant
    "Returns list of channels of given company"
    channels(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MerchantFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MerchantConnection
    "Returns list of client stores"
    clientsStoresRelay(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ClientsStoreFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ClientsStoreConnection
    country: Country
    "Returns coupons of current vendor"
    coupons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CouponFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CouponConnection
    createdAt: ISO8601DateTime!
    data: JSON
    "Shipper shipments"
    deliveryOrders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShipmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShipmentConnection!
    description: String
    district: District
    "Returns list of drivers"
    drivers(filter: OrderFilter, from: ISO8601DateTime!, to: ISO8601DateTime!): [Order!]
    "Returns eTicket activation methods of current vendor"
    eTicketActivationMethods(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        "Vendor ID"
        vendorId: ID
    ): ETicketActivationMethodConnection
    "Returns eTickets of current vendor"
    eTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ETicketFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ETicketConnection
    ebarimtType: String
    elasticReport(params: JSON, websiteId: ID): JSON
    email: String
    "Returns list of employees"
    employees(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessUserFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): EmployeeConnection
    "Returns erp integrations of current vendor"
    erpIntegrations: [ErpIntegration!]!
    exportTemplate: String
    facebook: String
    follow(websiteId: ID): Follow!
    follows: [Follow!]!
    "Returns list of fulfillment ready orders"
    fulfillmentDashboard(filter: OrderFilter): JSON
    fullAddress: String
    gid: ID!
    hideInfo: Boolean
    id: ID!
    instagram: String
    isBlocking: Boolean!
    isCityTaxPayer: Boolean
    isExcSelling: Boolean!
    isIndividual: Boolean
    isVerified: Boolean
    latitude: String
    "Returns report result of line items"
    lineItemReport(coupon: Boolean, couponFrom: String, couponTo: String, filter: LineItemFilter, flag: JSON, sort: SortFilter, storeId: ID, vendorId: ID): [LineItemReport!]
    "Тухайн харилцагчын авч болох бүх Line Item жагсаалтын буцаана"
    lineItems(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        excludeBankPending: Boolean,
        filter: LineItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        ready: Boolean,
        reportType: String,
        "Sorting functionality"
        sort: SortFilter
    ): LineItemConnection
    "Returns listings of current vendor"
    listings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection
    logo: String
    longitude: String
    manager: String
    myReview: Review
    name: String
    nameEn: String
    note1: String
    note2: String
    note3: String
    note4: String
    note5: String
    note6: String
    note7: String
    note8: String
    "Returns nutrition facts created by current vendor"
    nutritionFacts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: NutritionFactFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): NutritionFactConnection
    "Returns list of order report"
    orderReport(filter: OrderFilter, from: String!, promotion: Boolean, status: String, to: String!, vendorId: ID): [OrderReport!]
    "Returns orders of current vendor"
    orders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CommerceOrderConnection
    otherVendorsSelling: Boolean
    personalNumber: String
    phone: String
    pos: Boolean
    "Returns pos listings of current vendor"
    posListings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PosListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PosListingConnection
    "Returns payment data"
    posOrdersData(businessId: ID!, from: ISO8601DateTime!, to: ISO8601DateTime!, userId: ID, websiteId: ID!): JSON
    preferredBusinessModels: [String!]
    preferredNameValidated: Boolean
    preferredRegisterValidated: Boolean
    preferredSeoAutoUpdate: Boolean
    preferredVatValidated: Boolean
    primaryTaxons: [ID!]!
    primaryTaxonsData: JSON
    "Returns list of product returns"
    productReturns(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ProductReturnFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ProductReturnConnection!
    "Returns list of products owned by parent vendor"
    products(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ProductFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        websiteId: ID
    ): ProductConnection
    productsCount: Int
    "Returns promotions of current vendor"
    promotions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        dateType: String,
        filter: PromotionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        from: String,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        to: String
    ): PromotionConnection
    publishedListingsCount: Int!
    quarter: Quarter
    register: String
    reviews(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ReviewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        isDeleted: Boolean,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ReviewConnection!
    salesCount: Int!
    "Returns list of segment clients"
    segmentClients(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SegmentClientFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SegmentClientConnection!
    "Returns shipments of current vendor"
    shipments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShipmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShipmentConnection
    "Returns business images of current vendor"
    shoppyImages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShoppyImageFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ImageConnection
    "Returns supply segments of vendor"
    sizingGuides(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SizingGuideFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SizingGuideConnection
    "Returns list of sms"
    sms(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SmsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SmsConnection!
    "Returns list of sms counts"
    smsReport(filter: SmsFilter, interval: String): JSON
    state: State
    stockItems(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StockItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StockItemConnection
    "Returns stockLocations of current vendor"
    stockLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StockLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StockLocationConnection
    "Returns list of store credit events"
    storeCreditReport(filter: StoreCreditEventFilter, from: String, sort: SortFilter, to: String): [StoreCreditReport!]
    storeCredits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreCreditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreCreditConnection!
    storeListings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreListingConnection!
    storeLocation(id: ID!): StoreLocation
    "Returns storeLocations of current vendor"
    storeLocations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreLocationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreLocationConnection
    "Returns list of supplier category"
    supplierCategories(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SupplierCategoryFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SupplierCategoryConnection!
    supplySegment(id: ID!): SupplySegment
    "Returns supply segments of vendor"
    supplySegments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SupplySegmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SupplySegmentConnection
    taxNumber: String
    token: String
    totalReviews: Int!
    unapprovedListingsCount: Int!
    unpublishedListingsCount: Int!
    updatedAt: ISO8601DateTime!
    userSegments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserSegmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserSegmentConnection!
    "Returns list of variants owned by parent vendor"
    variants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: VariantFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        permission: VariantsPermission,
        "Sorting functionality"
        sort: SortFilter
    ): VariantConnection
    vat: Boolean
    vendorIsSelling: Boolean
    wallets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WalletFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WalletConnection
    website: String
    "Returns list of websites owned by company"
    websites(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WebsiteFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WebsiteConnection
    "Returns list of white"
    whiteListEntries(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WhiteListEntryFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WhiteListEntryConnection!
    "Returns list of white"
    whiteLists(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SegmentWhiteListFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SegmentWhiteListConnection!
    withSalesCount: Int
}

"The connection type for Vendor."
type VendorConnection {
    "A list of edges."
    edges: [VendorEdge!]!
    "A list of nodes."
    nodes: [Vendor!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type VendorEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Vendor!
}

type VirtualManifest implements Node & ProductManifestInterface {
    brand: Brand
    canSupply: Boolean
    expireAt: ISO8601DateTime
    fulfillDuration: Int
    gid: ID!
    id: ID!
    image: String
    maxQty: Int
    name: String!
    optionsText: String
    price: Float!
    productCat: String
    sku: String
    slug: String!
    totalOnHand: Int
    vendor: Vendor
    virtualProduct: VirtualProduct
    weight: Float
}

type VirtualProduct implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    data: String
    gid: ID!
    id: ID!
    image: String
    lineItem: LineItem!
    name: String
    options: String
    order: Order!
    price: Float
    sku: String
    updatedAt: ISO8601DateTime!
    userId: ID!
    website: Website!
    websiteId: ID!
}

type Wallet implements BaseModelInterface & Node {
    availableAmount: Float!
    balance: Float!
    banks: [Bank!]!
    bonus: Float!
    canI(action: CanIAction!): Boolean!
    code: String!
    createdAt: ISO8601DateTime!
    creditProfile: CreditProfile
    currency: String!
    dueDate: ISO8601DateTime
    freezeAmount: Float!
    gid: ID!
    id: ID!
    isVerified: Boolean!
    lastTransactionDate: ISO8601DateTime
    name: String!
    pinCodeStatus: String
    pinCodeUpdatedAt: ISO8601DateTime
    product: WalletProduct!
    status: String!
    totalActivePaidAmount: Float!
    totalActiveRepaidAmount: Float!
    totalAllocatedAmount: Float!
    totalAmountLeft: Float!
    totalCashInAmount: Float!
    totalCreditAmount: Float!
    totalCreditUsedAmount: Float!
    totalDebitAmount: Float!
    totalPaymentAmount: Float!
    totalPendingAmount: Float!
    totalRepaidAmount: Float!
    totalSurplusRepaidAmount: Float!
    transactions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: TransactionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TransactionConnection
    updatedAt: ISO8601DateTime!
    user: User
    vendor: Vendor
    vendorId: ID
    verifications: [UserVerification!]!
    website: Website!
    withdrawalAmount: Float!
}

"The connection type for Wallet."
type WalletConnection {
    "A list of edges."
    edges: [WalletEdge!]!
    "A list of nodes."
    nodes: [Wallet!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type WalletEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Wallet!
}

type WalletPaymentSourceType implements BaseModelInterface & Node & PaymentSourceInterface {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    paymentMethod: PaymentMethod!
    transactionId: String
    updatedAt: ISO8601DateTime!
    user: User!
    wallet: Wallet!
    walletTransaction: Transaction
}

type WalletProduct implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    code: String
    createdAt: ISO8601DateTime!
    currency: String
    gid: ID!
    id: ID!
    loanDays: Int
    name: String
    updatedAt: ISO8601DateTime!
    wallets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WalletFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WalletConnection!
}

type WalletRequest implements BaseModelInterface & Node {
    authorizedBy: User
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    reason: String
    status: String
    updatedAt: ISO8601DateTime!
    user: User!
    vendor: Vendor!
    wallet: Wallet!
    website: Website!
}

"The connection type for WalletRequest."
type WalletRequestConnection {
    "A list of edges."
    edges: [WalletRequestEdge!]!
    "A list of nodes."
    nodes: [WalletRequest!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type WalletRequestEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: WalletRequest!
}

type Warranty implements BaseModelInterface & Node {
    branch: String
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    createdBy: User
    deletedAt: ISO8601DateTime
    duration: Int
    email: String
    emailSentAt: ISO8601DateTime
    expireDate: ISO8601Date
    firstName: String
    gid: ID!
    id: ID!
    isActive: Boolean
    lastName: String
    mobile: String
    number: String
    order: Order
    serialNumber: String
    startDate: ISO8601Date
    updatedAt: ISO8601DateTime!
    usedAt: ISO8601DateTime
    user: User
    variant: Variant
    vendor: Vendor
    website: Website
}

type Website implements BaseModelInterface & Node {
    activeQuiz: Quiz
    address: String
    agendaTags(filter: TagFilter): [Tag!]
    agendas(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AgendaFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AgendaConnection!
    alternateDomain: String
    articleTags(filter: TagFilter): [Tag!]
    "Returns list of menus"
    articles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ArticleFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ArticleConnection!
    "Returns list of assets"
    assetRoles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AssetFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AssetRoleConnection!
    "Returns list of authors"
    authors(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AuthorFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AuthorConnection!
    autoAcceptBusinessClients: Boolean
    autoAcceptMerchants: Boolean
    availableTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ProductConnection!
    badge(id: ID!): Badge
    badges(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BadgeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BadgeConnection!
    black: String
    bonus: Float
    "Returns list of branch"
    branches(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BranchFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BranchConnection!
    "Returns list of brands"
    brands(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BrandListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BrandListingConnection!
    "Returns list of business clients"
    businessClients(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessClientFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BusinessClientConnection!
    "Returns list of business types"
    businessTypes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BusinessTypeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): BusinessTypeConnection!
    campaign(id: ID!): ShoppyCampaign!
    campaigns(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CampaignFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShoppyCampaignConnection!
    canI(action: CanIAction!): Boolean!
    cancelHour: Int
    "Returns list of cancel orders"
    cancelReasons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CancelReasonConnection!
    candy: Boolean
    categoryHeader: String
    "List of chat rooms"
    chatRooms(
        active: Boolean,
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: RoomFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): RoomConnection!
    "Returns a client store"
    clientsStore(id: ID!): ClientsStore
    "Returns list of client stores"
    clientsStores(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ClientsStoreFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ClientsStoreConnection!
    commission: Float
    contactStats: JSON
    copyrightText: String
    coupon: Boolean
    "Returns list of promotions"
    coupons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CouponFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CouponConnection!
    createdAt: ISO8601DateTime!
    creditCards(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: CreditCardsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): CreditCardConnection!
    currency: String
    data: JSON
    "get single data property by name"
    dataBooleanProperty(
        "name"
        name: String!
    ): Boolean
    deliveryUntil: Int
    domain: String!
    "Returns list of donations"
    donations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DonationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DonationConnection!
    "Returns list of drivers"
    drivers(filter: OrderFilter, from: ISO8601DateTime!, to: ISO8601DateTime!): [Order!]!
    "Returns list of ETickets"
    eTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ETicketFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ETicketConnection!
    ebarimt: Boolean
    elastic8Support: Boolean!
    email: String
    emailFrom: String
    erpIntegrations(filter: ErpIntegrationFilter): [ErpIntegration!]!
    eventEntries(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: EventEntryFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): eventEntryConnection
    eventInvite(id: ID!): EventInvite!
    eventInvites(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: EventInviteFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): EventInviteConnection!
    facebookAppId: String
    facebookChatId: String
    features: [FeatureType!]!
    feedbackTopics(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FeedbackTopicFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FeedbackTopicConnection!
    feedbacks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FeedbackFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): FeedbackTypeConnection!
    forms(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: FormFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShoppyFormConnection!
    "Returns list of fulfillment ready orders"
    fulfillmentDashboard(filter: OrderFilter): JSON
    "Returns list of gamifications"
    gamifications(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: GamificationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): GamificationConnection!
    gc(id: String, redemptionCode: String, websiteId: ID): GiftCard
    gid: ID!
    giftCard: Boolean
    "Returns list of GiftCards"
    giftCards(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: GiftCardFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): GiftCardConnection!
    group: Boolean
    groupIds: [String!]!
    id: ID!
    index: String!
    integrationReports(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: IntegrationReportFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): IntegrationReportConnection
    isActive: Boolean
    language: String!
    languages: [String!]!
    lastUsedPaymentMethods: [PaymentMethod!]!
    leaseAccount: String
    leaseName: String
    leaseV3Sources(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentSourceFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentSourceConnection!
    leasing: Boolean
    "Тухайн харилцагчын авч болох бүх Line Item жагсаалтын буцаана"
    lineItems(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        excludeBankPending: Boolean,
        filter: LineItemFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        ready: Boolean,
        reportType: String,
        "Sorting functionality"
        sort: SortFilter
    ): LineItemConnection!
    listingBonus: Boolean
    listingDuration: Int!
    "Тухайн харилцагчийн авч болох бүх Listing жагсаалтын буцаана"
    listings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    logo: String
    lookBooks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: LookBookFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): LookBookConnection!
    main: String
    massMessages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MassMessageFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MassMessageConnection!
    maximumAmount: Float!
    menu(
        "id"
        id: ID,
        "title: if no id is provided defaults to \"system_navigation\""
        title: String = "system_navigation"
    ): DynamicMenu
    menus: [DynamicMenu!]!
    merchant(
        "id"
        id: ID!
    ): Merchant
    "Returns list of merchants"
    merchants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MerchantFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MerchantConnection!
    minCartAmount: Float
    "Returns list of movie tickets"
    movieTickets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MovieTicketFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MovieTicketConnection!
    name: String!
    news(
        "id"
        id: ID!
    ): News
    newsTags(filter: TagFilter, websiteSpecific: Boolean): [Tag!]
    "Returns list of menus"
    newses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: NewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): NewsConnection!
    notices(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: NoticeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): NoticeConnection!
    notifications(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: NotificationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): NotificationConnection!
    onesignalAppId: String
    "Returns list of option types"
    optionTypes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OptionTypeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): OptionTypeConnection!
    orderCancellationBase: Float
    orderCancellationFee: Float
    "Returns statistic of orders"
    orderDashboard(filter: OrderFilter): JSON
    "Захиалгын тэмдэглэлүүд"
    orderNotes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderCommentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): OrderCommentConnection
    "Returns statistic of payment methods"
    orderPaymentDashboard(filter: OrderFilter): JSON
    "Returns list of order templates"
    orderTemplates(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderTemplateFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): OrderTemplateConnection!
    "Returns list of orders"
    orders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        status: OrderStatus
    ): OrderConnection!
    page(
        "id"
        id: ID,
        "SLUG: pathname"
        slug: String
    ): DynamicPage
    "Returns list of pages"
    pages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PageFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DynamicPageConnection!
    parent: Website
    "Returns a website payment acount data"
    paymentAccountData: JSON
    paymentGuideText: String
    "Returns list of payment methods"
    paymentMethods(active: Boolean, afterPay: Boolean, displayOn: [PmDisplayKind!]): [PaymentMethod!]!
    paymentReturnReasons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentReturnReasonFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentReturnReasonConnection!
    paymentReturnSources(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentReturnSourceFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentReturnSourceConnection!
    "Returns list of Payment returns"
    paymentReturns(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentReturnFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentReturnConnection!
    "Returns list of payments"
    payments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentConnection!
    phone1: String
    phone2: String
    polls(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PollFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PollConnection!
    prescription(id: ID!): Prescription
    "Prescriptions list"
    prescriptions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PrescriptionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PrescriptionConnection!
    "Returns list of printing"
    printings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PrintingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PrintingConnection!
    "Returns list of product returns"
    productReturns(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ProductReturnFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ProductReturnConnection!
    "Returns list of promotions"
    promotions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        dateType: String,
        filter: PromotionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        from: String,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        to: String
    ): PromotionConnection!
    prototypes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PrototypeFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PrototypeConnection!
    pushTemplates(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PushTemplateFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PushTemplateConnection!
    relatedProducts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: RelationFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): RelationConnection!
    reportReasons: [ReportReason!]!
    reports(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ReportsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ReportConnection!
    requireKycVerification: Boolean
    reviews(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ReviewsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        isDeleted: Boolean,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ReviewConnection!
    searchSuggestion: String
    shipmentHours: Int
    "Return shipment tracking list"
    shipmentTrackings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShipmentTrackingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShipmentTrackingConnection!
    "Returns list of shipment"
    shipments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShipmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShipmentConnection!
    "Returns list of shippers"
    shippers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ShipperConnection!
    "Returns list of shipping category"
    shippingCategories(filter: ShippingCategoryFilter): [ShippingCategory!]!
    "Returns list of shipping methods"
    shippingMethods(filter: ShippingMethodFilter): [ShippingMethod!]!
    shoppyImages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ShoppyImageFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ImageConnection!
    showUser: Boolean
    signonBonus: Float
    smsFee: Int
    smsFrom: String
    sslExpiresAt: ISO8601Date
    storeCredits(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StoreCreditFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StoreCreditConnection!
    storeLocation(id: ID!): StoreLocation
    "Returns list of address"
    storesAddresses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        categoryIds: [ID!],
        filter: AddressFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        wid: ID
    ): AddressConnection!
    "Returns list of supplier category"
    supplierCategories(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SupplierCategoryFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SupplierCategoryConnection!
    supplySegments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SupplySegmentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SupplySegmentConnection!
    tags(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: TagFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter,
        websiteSpecific: Boolean
    ): TagConnection!
    taxCategories(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TaxCategoryConnection!
    taxRates(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TaxRateConnection!
    taxons(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: TaxonFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TaxonConnection!
    ticket: Boolean
    ticketTemplates(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: TicketTemplateFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TicketTemplateConnection
    unreadNotifications: Int!
    updatedAt: ISO8601DateTime!
    useAlternatePassword: Boolean
    useCustomPrototypes: Boolean
    useDeliveryCode: Boolean!
    useWallet: Boolean
    user(id: ID!): User
    "Returns list of user agreements"
    userAgreements(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserAgreementFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserAgreementConnection!
    "Returns list of users"
    users(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserConnection!
    vatSender: String!
    vendor: Vendor
    "Returns list of vendors"
    vendors(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: VendorFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): VendorConnection!
    version: String
    wallet: Boolean
    walletRequests(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WalletRequestFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WalletRequestConnection!
    wallets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WalletFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WalletConnection!
    "Тухайн сайтын авч болох бүх Listing жагсаалтын буцаана"
    webListings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListingFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ListingConnection!
    white: String
    wishedProducts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WishedProductFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WishedProductConnection!
    wishlists(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: WishlistFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): WishlistConnection!
    zones: [Zone!]!
}

"The connection type for Website."
type WebsiteConnection {
    "A list of edges."
    edges: [WebsiteEdge!]!
    "A list of nodes."
    nodes: [Website!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type WebsiteEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Website!
}

type WhiteListEntry implements BaseModelInterface & Node {
    addedUser: User
    addedUserId: ID
    canI(action: CanIAction!): Boolean!
    company: String
    createdAt: ISO8601DateTime!
    entryDate: ISO8601Date
    gid: ID!
    id: ID!
    registerNo: String
    segment: SupplySegment
    segmentId: ID
    updatedAt: ISO8601DateTime!
    used: Boolean
    whiteList: SegmentWhiteList
}

"The connection type for WhiteListEntry."
type WhiteListEntryConnection {
    "A list of edges."
    edges: [WhiteListEntryEdge!]!
    "A list of nodes."
    nodes: [WhiteListEntry!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type WhiteListEntryEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: WhiteListEntry!
}

type WishedProduct implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    quantity: Int
    remark: String
    slug: String
    total: Int!
    updatedAt: ISO8601DateTime!
    variant: Variant!
    variantId: ID!
    websiteTotal: Int!
    wishlist: Wishlist!
}

"The connection type for WishedProduct."
type WishedProductConnection {
    "A list of edges."
    edges: [WishedProductEdge!]!
    "A list of nodes."
    nodes: [WishedProduct!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type WishedProductEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: WishedProduct!
}

type Wishlist implements BaseModelInterface & Node {
    accessHash: String!
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    isDefault: Boolean!
    isPrivate: Boolean!
    name: String!
    updatedAt: ISO8601DateTime!
    user: User!
    website: Website!
    wishedProducts(take: Int): [WishedProduct!]!
    wishedVariantIds: [ID!]!
}

"The connection type for Wishlist."
type WishlistConnection {
    "A list of edges."
    edges: [WishlistEdge!]!
    "A list of nodes."
    nodes: [Wishlist!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type WishlistEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Wishlist!
}

type Zipcode implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    level: Int
    name: String
    nameEn: String
    parent: Zipcode
    point: String
    polydataString: String
    state: State
    updatedAt: ISO8601DateTime!
    zipcode: String
}

type Zone implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    countries: [Country!]!
    createdAt: ISO8601DateTime!
    defaultTax: Boolean
    description: String
    districts: [District!]!
    gid: ID!
    id: ID!
    kind: String
    name: String
    pup: Boolean!
    quarters: [Quarter!]!
    states: [State!]!
    updatedAt: ISO8601DateTime!
    website: Website
    zonableIds: [ID!]!
    zoneMembersCount: Int
}

type clickPaymentInvoice implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    gid: ID!
    id: ID!
    invoiceNumber: String
    paymentMethod: PaymentMethod
    paymentMethodId: ID
    phone: String
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
}

type eventEntry implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    entree: EventEntree
    entreeIdx: String
    entryDate: ISO8601DateTime
    gid: ID!
    id: ID!
    number: String
    score: Int
    status: String
    updatedAt: ISO8601DateTime!
    website: Website
    winning: EventWinning
    winningIdx: String
    winnings: [EventEntryWinning!]!
}

"The connection type for eventEntry."
type eventEntryConnection {
    "A list of edges."
    edges: [eventEntryEdge!]!
    "A list of nodes."
    nodes: [eventEntry!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    sum(field: String!): Float!
    tagCounts: [TagCount!]!
    totalCount: Int!
}

"An edge in a connection."
type eventEntryEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: eventEntry!
}

type eventTry implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    description: String
    gid: ID!
    id: ID!
    quantity: Int
    updatedAt: ISO8601DateTime!
    user: User
    website: Website
}

type lotteryEntry implements BaseModelInterface & Node {
    canI(action: CanIAction!): Boolean!
    createdAt: ISO8601DateTime!
    entree: LotteryEntree
    entryDate: ISO8601DateTime
    gid: ID!
    id: ID!
    number: String
    updatedAt: ISO8601DateTime!
    website: Website
    winning: LotteryWinning
}

type paynetPaymentSource implements BaseModelInterface & Node & PaymentSourceInterface {
    amount: Float
    canI(action: CanIAction!): Boolean!
    cancelTime: ISO8601DateTime
    createdAt: ISO8601DateTime!
    fiscalSent: Boolean!
    gid: ID!
    id: ID!
    paymentMethod: PaymentMethod
    paymentMethodId: ID
    performTime: ISO8601DateTime
    status: Int
    transactionId: Int
    updatedAt: ISO8601DateTime!
    user: User
    userId: ID
}

"Merchant AfterPay type"
enum AfterPay {
    "approved"
    approved
    "inactive"
    inactive
    "pending"
    pending
}

enum ApproveAction {
    "approve"
    approve
    "cancel"
    cancel
    "order"
    order
    "revert"
    revert
}

"Asset target type enum"
enum AssetTarget {
    "branch type"
    branch
    "business type"
    business
    "business client type"
    business_client
    "business supplier type"
    business_supplier
    "merchant type"
    channel
    "clients store type"
    clients_store
    "store location type"
    store_location
    "user type"
    user
    "website type"
    website
}

enum B2bApprovalDecisionStatusEnum {
    "Approved"
    approved
    "Declined"
    declined
    "Disabled"
    disabled
    "Hidden"
    hidden
    "Pending"
    pending
    "Suspended"
    suspended
}

"Can i ability actions"
enum CanIAction {
    "delete object"
    delete
    "update object"
    update
}

"Clients store status"
enum ClientsStoreStatus {
    "1"
    approved
    "4"
    declined
    "3"
    disabled
    "0"
    pending
    "2"
    suspended
}

"Ebarimt type"
enum Ebarimt {
    "Гэрээлсэн НӨАТ төлөгч бус"
    contracted_not_payer
    "Гэрээлсэн НӨАТ төлөгч"
    contracted_vat_payer
    "НӨАТ төлөгч бус"
    not_payer
    "Бүртгэлгүй"
    not_registered
    "Өөрсдийн POS оор хэвлэдэг"
    self_print
    "НӨАТ төлөгч"
    vat_payer
}

"Employee Role"
enum EmployeeRole {
    "admin"
    admin
    "employee"
    employee
}

"Whom will be accumulated by this goal"
enum GamificationGoalAccumulateBy {
    "business"
    business
    "user"
    user
}

"Frequency of this goal"
enum GamificationGoalRepeat {
    "daily"
    daily
    "goal"
    goal
    "monthly"
    monthly
    "no_repeat"
    no_repeat
    "quarterly"
    quarterly
    "weekly"
    weekly
    "yearly"
    yearly
}

"Gender"
enum Gender {
    "Female"
    F
    "Male"
    M
}

"Image format"
enum ImageFormat {
    "jpeg"
    jpeg
    "png"
    png
    "webp"
    webp
}

"KycStatus"
enum KycStatus {
    "approved"
    approved
    "pending"
    pending
    "rejected"
    rejected
}

"OrderAction"
enum LineItemAction {
    "Mark as brought"
    brought
    "Mark as no stock"
    no_stock
    "mark as not taken"
    not_taken
    "Mark inventory units as not shipped"
    on_hand
    "Mark as Ready"
    ready
    "Mark inventory units as returned"
    returned
    "Mark inventory units as shipped"
    shipped
    "mark as taken"
    taken
}

"OrderAction"
enum OrderAction {
    "Add or remove flag on order"
    add_flag
    "archive"
    archive
    "order canceling"
    cancel
    "Claim for order"
    claim
    "Claim driver on order"
    claim_manual
    "Modify order fields"
    modify
    "Pickpack order fields"
    pick_pack
    "Release sequence"
    release
    "Send ebarimt email"
    resend_ebarimt_email
    "Resend email to user"
    resend_email
    "Resend sms to user"
    resend_sms
    "resume canceled order"
    resume
    "Send lease information to bank"
    send_id2
    "Send order information to bank"
    send_id6
    "Send parcel options to user"
    send_parcel_options
    "Assign sequence"
    sequence
    "Ship all shipments for order"
    ship
    "Un Archive"
    un_archive
}

"Order types"
enum OrderStatus {
    "Unpaid orders"
    balanceDue
    "Only completed orders"
    complete
    "!Not Completed /cart order/"
    incomplete
    "Only paid orders"
    paid
    "Fulfilled/Shipped Orders"
    shipped
    "Only claimable orders"
    to_claim
    "Unfulfilled"
    unfulfilled
    "Use wallet on payment process failed"
    wallet_failed
}

"PassportFileType"
enum PassportFile {
    "Passport back"
    back
    "Passport front"
    front
    "Personal selfie"
    selfie
}

"Payment method types"
enum PaymentMethodKind {
    "AlifPay"
    alif_pay
    "ArdInApp"
    ard_in_app
    "BankTransfer"
    bank_transfer
    "BinancePay"
    binance_pay
    "BitPayment"
    bit_payment
    "Bogus"
    bogus
    "BogusSimple"
    bogus_simple
    "BonumApplePay"
    bonum_apple_pay
    "CandyInApp"
    candy_in_app
    "CashOnDelivery"
    cash_on_delivery
    "Check"
    check
    "ClickPayment"
    click_payment
    "CashOnDelivery"
    complete
    "DigiPayInApp"
    digi_pay_in_app
    "DigitalCredit"
    digital_credit
    "DownPayment"
    down_payment
    "AccountsReceivable"
    erp_integration_accounts_receivable
    "Golomt"
    golomt
    "GolomtDigitalBank"
    golomt_digital_bank
    "GolomtInApp"
    golomt_in_app
    "GolomtPosTerminal"
    golomt_pos_terminal
    "GolomtWallet"
    golomt_wallet
    "GolomtWallet"
    golomt_wallet_social_pay
    "HiPay"
    hi_pay
    "HiPayInApp"
    hi_pay_in_app
    "HiPayWeChat"
    hi_pay_we_chat
    "Intend"
    intend
    "ItLeasing"
    it_leasing
    "Khaan"
    khaan
    "KhaanInApp"
    khaan_in_app
    "KhaanLeasing"
    khaan_leasing
    "Lend"
    lend
    "LendInApp"
    lend_in_app
    "LendPay"
    lend_pay
    "MBankCard"
    m_bank_card
    "MBankInApp"
    m_bank_in_app
    "MBankMerchant"
    m_bank_merchant
    "MemePay"
    meme_pay
    "MessengerLoanInApp"
    messenger_loan_in_app
    "MongolChat"
    mongol_chat
    "Moni"
    moni
    "Monpay"
    monpay
    "MonpayInApp"
    monpay_in_app
    "MonpayV2"
    monpay_v2
    "Most"
    most
    "MostInApp"
    most_in_app
    "MostOts"
    most_ots
    "MostTan"
    most_tan
    "MostV2"
    most_v2
    "NetCapital"
    net_capital
    "NonBanking"
    non_banking
    "Numur"
    numur
    "Omniway"
    omniway
    "Pass"
    pass
    "PayMe"
    pay_me
    "PayMeCard"
    pay_me_card
    "PayPalGateway"
    pay_pal_gateway
    "PaynetPayment"
    paynet_payment
    "Paypal"
    paypal
    "Pocket"
    pocket
    "PocketInApp"
    pocket_in_app
    "PocketZero"
    pocket_zero
    "Qpay"
    qpay
    "QpayMerchant"
    qpay_merchant
    "QpayV2"
    qpay_v2
    "QpayWallet"
    qpay_wallet
    "WalletPayment"
    shoppy_wallet
    "Simple"
    simple
    "SimpleInApp"
    simple_in_app
    "SimpleV2"
    simple_v2
    "SocialPay"
    social_pay
    "SocialPayQr"
    social_pay_qr
    "Sono"
    sono
    "StorePay"
    store_pay
    "StoreCredit"
    storecredit
    "Stripe"
    stripe
    "StripeApplePay"
    stripe_apple_pay
    "TdbInApp"
    tdb_in_app
    "Tdbm"
    tdbm
    "TdbmApplePay"
    tdbm_apple_pay
    "TdbmECommerce"
    tdbm_e_commerce
    "TdbmLease"
    tdbm_lease
    "TdbmLeaseV2"
    tdbm_lease_v2
    "TdbmLeaseV3"
    tdbm_lease_v3
    "TdbmPosTerminal"
    tdbm_pos_terminal
    "Toki"
    toki
    "TokiInApp"
    toki_in_app
    "TokiPayLater"
    toki_pay_later
    "UzumNasiya"
    uzum_nasiya
    "WeChat"
    we_chat
    "Wellbee"
    wellbee_credit_gateway
    "Xac"
    xac
    "XacLeasing"
    xac_leasing
}

"Payment method types"
enum PmDisplayKind {
    back_end
    both
    front_end
}

enum PrescriptionItemStatus {
    "active"
    active
    "used"
    used
}

enum PrescriptionStatus {
    "accepted"
    accepted
    "cancelled"
    cancelled
    "pending"
    pending
    "used"
    used
}

"Product Types"
enum ProductCat {
    "accessory"
    accessory
    "activity"
    activity
    "air_ticket"
    air_ticket
    "alibaba"
    alibaba
    "assembly"
    assembly
    "auto"
    auto
    "beauty"
    beauty
    "book"
    book
    "booking"
    booking
    "booking_stock"
    booking_stock
    "coupon"
    coupon
    "donation"
    donation
    "downloadable"
    downloadable
    "dropship"
    dropship
    "dynamic_price"
    dynamic_price
    "e_ticket"
    e_ticket
    "education"
    education
    "food"
    food
    "gift_card"
    gift_card
    "health"
    health
    "hotel"
    hotel
    "insurance"
    insurance
    "license"
    license
    "movie_ticket"
    movie_ticket
    "music"
    music
    "package"
    package
    "package_pre_order"
    package_pre_order
    "pharmaceutical"
    pharmaceutical
    "pre_order"
    pre_order
    "prescription_drug"
    prescription_drug
    "printing"
    printing
    "product"
    product
    "promotion_only"
    promotion_only
    "seated"
    seated
    "stage"
    stage
    "subscription"
    subscription
    "temporary"
    temporary
    "travel"
    travel
    "virtual"
    virtual
}

"Product Image size"
enum ProductImageSize {
    "image size 35x35#"
    color
    "image size 647x647>"
    large
    "!Only available for certain vendors: image size 365x365>"
    list
    "image size 87x87>"
    mini
    "!!!Careful file size can be DANGEROUSLY BIG!!! Original upload"
    original
    "image size 250x250>"
    product
    "image size 170x170#"
    small
    "image size 1500x1500>"
    zoom
}

"Push template names"
enum PushTemplateName {
    "brand_new_product"
    brand_new_product
    "brand_sale"
    brand_sale
    "c2c_after_pay_activated"
    c2c_after_pay_activated
    "c2c_listing_create"
    c2c_listing_create
    "c2c_listing_expire_reminder"
    c2c_listing_expire_reminder
    "c2c_listing_expired"
    c2c_listing_expired
    "c2c_listing_sales"
    c2c_listing_sales
    "c2c_new_feedback"
    c2c_new_feedback
    "order_to_drivers"
    order_to_drivers
    "system_campaign_cancel"
    system_campaign_cancel
    "system_campaign_success"
    system_campaign_success
    "system_dispatch_call"
    system_dispatch_call
    "system_leasing_status"
    system_leasing_status
    "system_merchant_order"
    system_merchant_order
    "system_chat_message"
    system_new_chat
    "system_no_stock"
    system_no_stock
    "system_order_cancel"
    system_order_cancel
    "system_order_claim"
    system_order_claim
    "system_order_completed"
    system_order_completed
    "system_order_ebarimt"
    system_order_ebarimt
    "system_order_paid"
    system_order_paid
    "system_order_purchased"
    system_order_purchased
    "system_order_purchased"
    system_order_purchased_location
    "system_order_shipment_ready"
    system_order_shipment_ready
    "system_order_shipped"
    system_order_shipped
    "system_prescription_accepted"
    system_prescription_accepted
    "system_prescription_created"
    system_prescription_created
    "system_user_birthday"
    system_user_birthday
    "system_vendor_follow"
    system_vendor_follow
    "templated_order_created"
    templated_order_created
}

"Shipment transfer"
enum ShipmentTransfer {
    "Create new shipment from location"
    location
    "To existing shipment"
    shipment
}

"Swap item swap action"
enum ShopperCartItemAction {
    "Collect inventory items to swap"
    collect
    "Discard inventory items of line_item if it's unavailable"
    discard
    "Collect partial of items"
    partial
    "Pick one out of swap variants"
    pick_variant
    "Ask consumer for swap inventory approval"
    swap_request
}

"Sort Direction"
enum SortDirection {
    "Ascending"
    asc
    "Descending"
    desc
}

"Cart item action"
enum SwapActionEnum {
    "Discard the given line item"
    discard
    "Replace the given line item if original variant is unavailable"
    swap
}

"Variant Permission"
enum VariantsPermission {
    "Only displayable variants"
    display
    "Only manageable variants"
    manage
}

"Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string."
scalar BigInt

"An ISO 8601-encoded date"
scalar ISO8601Date

"An ISO 8601-encoded datetime"
scalar ISO8601DateTime

"Represents untyped JSON"
scalar JSON

scalar Upload

"Autogenerated input type of AddFeedback"
input AddFeedbackInput {
    body: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    firstName: String
    image: Upload
    orderId: ID
    phone: String
    topicId: ID!
}

"Autogenerated input type of AddFeedbackTopic"
input AddFeedbackTopicInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    orderRequired: Boolean
    parentId: ID
    position: Int
    positive: Boolean
    title: String!
    websiteId: ID!
}

input AddressFilter {
    address1: StringFilter
    address2: StringFilter
    countryId: IDFilter
    createdAt: DateFilter
    district: DistrictFilter
    districtId: IDFilter
    firstname: StringFilter
    id: IDFilter
    isCompany: BoolFilter
    lastname: StringFilter
    mnQuarter: QuarterFilter
    mnQuarterId: IDFilter
    phone: StringFilter
    state: StateFilter
    stateId: IDFilter
    updatedAt: DateFilter
}

input AddressInput {
    address1: String
    address2: String
    alias: String
    alternativePhone: String
    apartment: String
    cdq: [ID!]
    company: String
    consumerNo: String
    coordinate: JSON
    districtId: ID
    entrance: String
    firstname: String
    floor: String
    house: String
    houseKorpus: String
    "ID"
    id: ID
    intercom: String
    isBillAddress: Boolean
    isCompany: Boolean
    isPup: Boolean
    lastname: String
    latitude: String
    longitude: String
    mnQuarterId: ID
    nationality: String
    note: String
    owningType: String
    passportNumber: String
    phone: String
    pinFl: String
    preferences: JSON
    stateId: ID
    tin: String
    what3words: String
    year: String
}

input AgendaFilter {
    createdAt: DateFilter
    date: DateFilter
    id: IDFilter
    location: StringFilter
    tags: TagFilter
    time: StringFilter
    title: StringFilter
    updatedAt: DateFilter
}

input ArticleFilter {
    author: AuthorFilter
    createdAt: DateFilter
    id: IDFilter
    isDraft: BoolFilter
    isPublished: BoolFilter
    preview: StringFilter
    publishedAt: DateFilter
    tags: TagFilter
    title: StringFilter
    trending: IntFilter
    updatedAt: DateFilter
}

"Filter object for Order"
input AssetFilter {
    assetId: IDFilter
    assetType: StringFilter
    createdAt: DateFilter
    email: StringFilter
    id: IDFilter
    number: StringFilter
    state: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    userEmailOrUserMobile: StringFilter
    userEmailOrUserMobileOrUserFirstName: StringFilter
    withRoles: [String!]
}

input AssetTargetRoleInput {
    peopleIds: [ID!]!
    roles: [String!]!
    targetIds: [ID!]!
    targetType: AssetTarget!
}

input AuditFilter {
    action: StringFilter
    associatedId: IntFilter
    auditableType: StringFilter
    comment: StringFilter
    createdAt: DateFilter
    id: IDFilter
    remoteAddress: StringFilter
    sku: StringFilter
    updatedAt: DateFilter
    userEmail: StringFilter
    website: StringFilter
}

input AuthorFilter {
    createdAt: DateFilter
    followersCount: IntFilter
    fullName: StringFilter
    id: IDFilter
    updatedAt: DateFilter
    user: UserFilter
    username: StringFilter
}

input BadgeFilter {
    active: BoolFilter
    createdAt: DateFilter
    expireAt: DateFilter
    id: IDFilter
    name: StringFilter
    priority: IntFilter
    promotable: BoolFilter
    searchState: String
    startAt: DateFilter
    updatedAt: DateFilter
    url: StringFilter
    website: WebsiteFilter
}

input BankInput {
    _destroy: Boolean
    accountNo: String
    active: Boolean
    additionalDetails: String
    "ID"
    id: ID
    name: String
}

input BoolFilter {
    "equals to"
    eq: Boolean
    "not equals to"
    notEq: Boolean
    "is null ?"
    notNull: Boolean
    "is null ?"
    null: Boolean
}

input BranchFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input BrandFilter {
    blackLogo: ShoppyImageFilter
    brandWebsitesWebsiteId: StringFilter
    brandWebsitesWebsiteName: StringFilter
    categoryType: StringFilter
    code: StringFilter
    createdAt: DateFilter
    domain: StringFilter
    id: IDFilter
    isPublished: BoolFilter
    name: StringFilter
    products: ProductFilter
    productsListingsWebsiteName: StringFilter
    storeType: StringFilter
    updatedAt: DateFilter
    whiteLogo: ShoppyImageFilter
}

input BrandListingFilter {
    active: BoolFilter
    code: StringFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    store: BrandFilter
    storeId: IDFilter
    updatedAt: DateFilter
    website: WebsiteFilter
    websiteId: IDFilter
}

input BusinessClientFilter {
    aliasOrClientName: StringFilter
    client: VendorFilter
    clientName: StringFilter
    clientNameOrClientRegister: StringFilter
    createdAt: DateFilter
    email: StringFilter
    id: IDFilter
    localId: StringFilter
    msCode: StringFilter
    name: StringFilter
    organizationId: StringFilter
    phone: StringFilter
    phoneOrEmail: StringFilter
    phoneOrEmailOrLocalIdOrClientNameOrClientRegister: StringFilter
    salesManagers: BusinessUserFilter
    segmentsClients: SegmentClientFilter
    updatedAt: DateFilter
    vendor: VendorFilter
    vendorNameOrVendorRegister: StringFilter
    withStatus: StringFilter
}

input BusinessTypeFilter {
    code: StringFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input BusinessUserFilter {
    addedBy: UserFilter
    assetRoles: AssetFilter
    businessUserGroups: BusinessUserGroupFilter
    createdAt: DateFilter
    email: StringFilter
    emailOrFirstNameOrLastNameOrMobile: StringFilter
    firstName: StringFilter
    id: IDFilter
    lastName: StringFilter
    mobile: StringFilter
    msCode: StringFilter
    role: StringFilter
    searchAll: String
    updatedAt: DateFilter
    user: UserFilter
    vendor: VendorFilter
}

input BusinessUserGroupFilter {
    code: StringFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input BusinessUsersSegmentFilter {
    businessUser: BusinessUserFilter
    businessUserId: IDFilter
    createdAt: DateFilter
    expiresAt: DateFilter
    id: IDFilter
    segment: SupplySegmentFilter
    segmentId: IDFilter
    status: StringFilter
    updatedAt: DateFilter
}

input CampaignFilter {
    createdAt: DateFilter
    description: StringFilter
    endsAt: DateFilter
    fulfillDate: DateFilter
    id: IDFilter
    location: StringFilter
    startsAt: DateFilter
    status: StringFilter
    title: StringFilter
    updatedAt: DateFilter
    vendor: VendorFilter
    website: WebsiteFilter
}

input CampaignListingFilter {
    campaign: CampaignFilter
    createdAt: DateFilter
    id: IDFilter
    price: IntFilter
    updatedAt: DateFilter
    variant: VariantFilter
}

input CampaignListingInput {
    "Display order"
    position: Int
    "Price"
    price: Float!
    "Quantity"
    quantity: Int
    "VariantId"
    variantId: ID!
}

input CartItemInput {
    "Attachments"
    attachments: [Upload!]
    "Additional data"
    data: JSON
    "additional options"
    options: JSON
    "Quantity"
    quantity: Int
    "SKU"
    sku: String
    "VariantId"
    variantId: ID
}

input ClientsStoreFilter {
    businessClient: BusinessClientFilter
    category: SupplierCategoryFilter
    createdAt: DateFilter
    id: IDFilter
    statusEq: ClientsStoreStatus
    storeLocation: StoreLocationFilter
    supplierStockLocations: StockLocationFilter
    updatedAt: DateFilter
}

input CollectFilter {
    createdAt: DateFilter
    id: IDFilter
    "0: pending, 1: collected, 2: driver_taken, 3: shipped, 4: cancelled"
    status: IntFilter
    updatedAt: DateFilter
    user: UserFilter
}

"Filter object for Digital contract"
input ContractFilter {
    createdAt: DateFilter
    handedAt: DateFilter
    id: IDFilter
    isMaster: BoolFilter
    order: OrderFilter
    receivedAt: DateFilter
    registerNum: StringFilter
    signedAt: DateFilter
    updatedAt: DateFilter
    user: UserFilter
}

input CountryFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input CouponFilter {
    amount: IntFilter
    createdAt: DateFilter
    deactivatedAt: DateFilter
    id: IDFilter
    itemType: StringFilter
    lineItem: LineItemFilter
    number: StringFilter
    order: OrderFilter
    receiverEmail: StringFilter
    receiverName: StringFilter
    receiverPhone: StringFilter
    scannedBy: UserFilter
    sentAt: DateFilter
    state: StringFilter
    status: StringFilter
    updatedAt: DateFilter
    usedAt: DateFilter
    user: UserFilter
    userEmailOrUserMobileOrUserFirstName: StringFilter
    vendor: VendorFilter
    website: WebsiteFilter
}

"Autogenerated input type of CreateOrder"
input CreateOrderInput {
    billAddress: AddressInput!
    channel: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    clientVendorId: ID
    clientsStoreId: ID
    couponCode: String
    ebarimt: Boolean
    email: String
    extraData: JSON
    flag: String
    isConfirmation: Boolean
    lineItems: [LineItemInput!]
    parcelDelivery: Boolean
    paymentState: Boolean
    payments: [JSON!]
    shipAddress: AddressInput
    useBilling: Boolean
    userId: ID!
    websiteId: ID!
    whenToShip: ISO8601DateTime
}

input CreditCardsFilter {
    cardType: EnumStringFilter
    createdAt: DateFilter
    id: IDFilter
    lastDigits: StringFilter
    name: StringFilter
    number: StringFilter
    registerNum: StringFilter
    status: EnumStringFilter
    updatedAt: DateFilter
    user: UserFilter
}

input DateFilter {
    "equals to"
    eq: String
    "Greater than"
    gt: String
    "Greater than or equals"
    gteq: String
    "Less than"
    lt: String
    "Less than or equals"
    lteq: String
    "not equals to"
    notEq: String
    "is null ?"
    notNull: Boolean
    "is null ?"
    null: Boolean
}

input DepartmentStoreFilter {
    address: StringFilter
    createdAt: DateFilter
    description: StringFilter
    email: StringFilter
    id: IDFilter
    phoneNumber: StringFilter
    timeSheets: StringFilter
    title: StringFilter
    updatedAt: DateFilter
}

input DistrictFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    stateId: IntFilter
    updatedAt: DateFilter
}

input DonationFilter {
    active: BoolFilter
    amount: IntFilter
    createdAt: DateFilter
    donationType: StringFilter
    id: IDFilter
    phone: StringFilter
    product: ProductFilter
    sender: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input DownloadableFilter {
    createdAt: DateFilter
    id: IDFilter
    title: StringFilter
    updatedAt: DateFilter
}

input DropshipBrandFilter {
    createdAt: DateFilter
    id: IDFilter
    key: StringFilter
    name: StringFilter
    presentation: StringFilter
    provider: ProviderFilter
    providerId: StringFilter
    slug: StringFilter
    updatedAt: DateFilter
}

input DropshipCategoryFilter {
    createdAt: DateFilter
    depth: IntFilter
    id: IDFilter
    key: StringFilter
    name: StringFilter
    parent: DropshipCategoryFilter
    parentId: IDFilter
    presentation: StringFilter
    productCount: IntFilter
    provider: ProviderFilter
    providerId: IDFilter
    slug: StringFilter
    updatedAt: DateFilter
}

input DropshipProductFilter {
    createdAt: DateFilter
    currency: IntFilter
    id: IDFilter
    key: StringFilter
    listed: BoolFilter
    name: StringFilter
    price: IntFilter
    providerId: StringFilter
    quantity: IntFilter
    sku: StringFilter
    slug: StringFilter
    syncedAt: DateFilter
    updatedAt: DateFilter
}

input EMailContactFilter {
    createdAt: DateFilter
    email: StringFilter
    firstName: StringFilter
    id: IDFilter
    lastName: StringFilter
    rating: IntFilter
    segment: EMailSegmentFilter
    segmentId: IDFilter
    source: StringFilter
    state: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    website: WebsiteFilter
}

input EMailEventFilter {
    contact: EMailContactFilter
    createdAt: DateFilter
    eventType: StringFilter
    id: IDFilter
    sourceId: StringFilter
    sourceType: StringFilter
    updatedAt: DateFilter
}

input EMailSegmentFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    operator: StringFilter
    status: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input ETicketFilter {
    amount: IntFilter
    createdAt: DateFilter
    id: IDFilter
    lineItem: LineItemFilter
    number: StringFilter
    order: OrderFilter
    product: ProductFilter
    receiverEmail: StringFilter
    scannedBy: UserFilter
    scannedByMobileOrScannedByEmail: StringFilter
    state: StringFilter
    status: StringFilter
    updatedAt: DateFilter
    usedAt: DateFilter
    variant: VariantFilter
}

input EducationInput {
    active: Boolean
    degree: String
    id: ID
    profession: String
    school: String
    since: ISO8601Date
}

input EmergencyContactInput {
    _destroy: Boolean
    address: String
    firstName: String
    id: ID
    lastName: String
    mobile: String
    relation: String
}

input EmploymentInput {
    address: String
    company: String
    employeeCount: String
    id: ID
    jobTitle: String
    phone: String
    since: ISO8601Date
    years: String
}

input EnumStringFilter {
    "equals to"
    eq: String
    "in: Matches any values in giver array"
    in: [String!]
    "not equals to"
    notEq: String
    "in: Matches none of values in giver array"
    notIn: [String!]
    "is null ?"
    notNull: Boolean
    "is null ?"
    null: Boolean
}

input ErpIntegrationFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
    vendor: VendorFilter
}

input EventEntryFilter {
    createdAt: DateFilter
    description: StringFilter
    entree: UserFilter
    entreeId: IDFilter
    entreeType: StringFilter
    entryDate: DateFilter
    id: IDFilter
    score: IntFilter
    sourceId: IDFilter
    sourceType: StringFilter
    status: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
    winning: PromotionFilter
    winningId: IDFilter
    winningType: StringFilter
}

input EventInviteFilter {
    company: StringFilter
    createdAt: DateFilter
    description: StringFilter
    id: IDFilter
    number: StringFilter
    order: OrderFilter
    product: ProductFilter
    status: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    userMobileOrUserEmail: StringFilter
    website: WebsiteFilter
}

input EventInviteItemFilter {
    createdAt: DateFilter
    eTickets: ETicketFilter
    email: StringFilter
    id: IDFilter
    invite: EventInviteFilter
    inviteId: IDFilter
    receiverName: StringFilter
    status: EnumStringFilter
    updatedAt: DateFilter
    variant: VariantFilter
    variantId: IDFilter
}

input FeedbackFilter {
    body: StringFilter
    createdAt: DateFilter
    description: StringFilter
    email: StringFilter
    firstName: StringFilter
    id: IDFilter
    imageFileName: StringFilter
    lastName: StringFilter
    mainType: StringFilter
    orderNumber: StringFilter
    phone: StringFilter
    phoneOrUserMobile: StringFilter
    resolver: UserFilter
    status: StringFilter
    topicParentTitle: StringFilter
    topicTitle: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    website: WebsiteFilter
}

input FeedbackTopicFilter {
    createdAt: DateFilter
    id: IDFilter
    orderRequired: BoolFilter
    parentId: StringFilter
    parentTitle: StringFilter
    positive: BoolFilter
    title: StringFilter
    updatedAt: DateFilter
    websiteId: StringFilter
}

input FinanceInput {
    businessIncome: Float
    creditLimit: Float
    groceryOutcome: Float
    hasCreditcard: Boolean
    hasLoan: Boolean
    householdOutcome: Float
    id: ID
    income: Float
    loanExceed60: Boolean
    loanpaymentAmoutMonthly: Float
    otherIncome: Float
    otherOutcome: Float
}

input FollowFilter {
    createdAt: DateFilter
    id: IDFilter
    targetId: StringFilter
    targetType: StringFilter
    updatedAt: DateFilter
    vendorName: String
    website: WebsiteFilter
}

input FollowerFilter {
    createdAt: DateFilter
    follow: FollowFilter
    id: IDFilter
    status: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    vendorName: String
}

input FormAnswerFilter {
    body: StringFilter
    createdAt: DateFilter
    entry: FormEntryFilter
    field: FormFieldFilter
    id: IDFilter
    updatedAt: DateFilter
}

input FormAnswerInput {
    attachment: Upload
    body: String!
    fieldId: ID!
}

input FormEntryFilter {
    answers: FormAnswerFilter
    createdAt: DateFilter
    form: FormFilter
    id: IDFilter
    node: StringFilter
    status: StringFilter
    updatedAt: DateFilter
}

input FormFieldFilter {
    active: BoolFilter
    answers: FormAnswerFilter
    createdAt: DateFilter
    description: StringFilter
    fieldType: StringFilter
    form: FormFilter
    id: IDFilter
    label: StringFilter
    title: StringFilter
    updatedAt: DateFilter
}

input FormFieldInput {
    _destroy: Boolean
    active: Boolean
    data: JSON
    description: String
    fieldType: String
    "FormId"
    formId: ID
    "ID"
    id: ID
    label: String
    position: Int
    preferences: JSON
    "WebsiteId"
    websiteId: ID
}

input FormFilter {
    active: BoolFilter
    createdAt: DateFilter
    createdBy: UserFilter
    description: StringFilter
    entries: FormEntryFilter
    fields: FormFieldFilter
    id: IDFilter
    permalink: StringFilter
    title: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input GamificationFilter {
    active: BoolFilter
    createdAt: DateFilter
    expiresAt: DateFilter
    id: IDFilter
    name: StringFilter
    startsAt: DateFilter
    updatedAt: DateFilter
    vendor: VendorFilter
    website: WebsiteFilter
}

input GamificationProgressFilter {
    createdAt: DateFilter
    cycle: StringFilter
    date: DateFilter
    id: IDFilter
    ownerId: IDFilter
    ownerType: StringFilter
    updatedAt: DateFilter
}

input GiftCardFilter {
    amount: IntFilter
    createdAt: DateFilter
    deactivatedAt: DateFilter
    id: IDFilter
    number: StringFilter
    order: OrderFilter
    printed: BoolFilter
    product: ProductFilter
    purchaserName: StringFilter
    recipientEmail: StringFilter
    recipientName: StringFilter
    redeemable: BoolFilter
    redeemedAt: DateFilter
    redeemer: UserFilter
    redeemerEmailOrRedeemerMobile: StringFilter
    redemptionCode: StringFilter
    sendEmailAt: DateFilter
    sentAt: DateFilter
    updatedAt: DateFilter
    usedOrderNumber: StringFilter
    usedOrders: OrderFilter
    variant: VariantFilter
    website: WebsiteFilter
}

"Autogenerated input type of HandleCartItem"
input HandleCartItemInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Line item id"
    id: ID
    "Cart Action action to perform"
    itemAction: ShopperCartItemAction!
    "Notify consumer about the changes on this cart?"
    notify: Boolean
    "Order number"
    number: String
    "Quantity"
    quantity: Int
    "SKU"
    sku: String
    "Order token"
    token: String
    "Variant id of the inventory to replace with"
    variantId: ID
    "Variant index of a variant located in data[\"on_unavailable\"][\"variants\"]"
    variantIndex: Int
}

input IDFilter {
    "is blank ?"
    blank: Boolean
    "equals to"
    eq: ID
    "Greater than"
    gt: Int
    "Greater than or equals"
    gteq: Int
    "in: Matches any values in giver array"
    in: [ID!]
    "Less than"
    lt: Int
    "Less than or equals"
    lteq: Int
    "not equals to"
    notEq: ID
    "in: Matches none of values in giver array"
    notIn: [ID!]
    "is null ?"
    notNull: Boolean
    "is null ?"
    null: Boolean
    "Starts with"
    start: Int
}

input IntFilter {
    "is blank ?"
    blank: Boolean
    "equals to"
    eq: Float
    "Greater than"
    gt: Float
    "Greater than or equals"
    gteq: Float
    "in: Matches none of values in giver array"
    in: [Float!]
    "Less than"
    lt: Float
    "Less than or equals"
    lteq: Float
    "not equals to"
    notEq: Float
    "in: Matches none of values in giver array"
    notIn: [Float!]
    "is null ?"
    null: Boolean
}

input IntegrationRecordFilter {
    createdAt: DateFilter
    erpIntegration: ErpIntegrationFilter
    erpIntegrationId: IDFilter
    id: IDFilter
    idx: StringFilter
    notFound: BoolFilter
    preferences: StringFilter
    status: IntFilter
    updatedAt: DateFilter
}

input IntegrationReportFilter {
    category: StringFilter
    created: IntFilter
    createdAt: DateFilter
    data: StringFilter
    description: StringFilter
    endedAt: DateFilter
    excluded: IntFilter
    id: IDFilter
    message: StringFilter
    notFound: IntFilter
    ownerId: IDFilter
    ownerType: StringFilter
    received: IntFilter
    skipped: IntFilter
    source: OrderFilter
    sourceId: IDFilter
    sourceType: StringFilter
    startedAt: DateFilter
    status: StringFilter
    synced: IntFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input InventoryUnitActionFilter {
    actionBy: UserFilter
    createdAt: DateFilter
    id: IDFilter
    inventoryUnit: InventoryUnitFilter
    lineItem: LineItemFilter
    location: StoreLocationFilter
    order: OrderFilter
    quantity: StringFilter
    shipment: ShipmentFilter
    updatedAt: DateFilter
    variant: VariantFilter
}

"Filter object for Order"
input InventoryUnitFilter {
    createdAt: DateFilter
    id: IDFilter
    lineItems: LineItemFilter
    order: OrderFilter
    pending: BoolFilter
    quantity: IntFilter
    state: StringFilter
    updatedAt: DateFilter
    variant: VariantFilter
}

input KeywordFilter {
    alias: StringFilter
    byRelevance: String
    createdAt: DateFilter
    id: IDFilter
    mn: StringFilter
    name: StringFilter
    prototype: PrototypeFilter
    updatedAt: DateFilter
}

input LicenseFilter {
    amount: IntFilter
    createBy: UserFilter
    createdAt: DateFilter
    id: IDFilter
    lineItem: LineItemFilter
    number: StringFilter
    order: OrderFilter
    product: ProductFilter
    status: StringFilter
    updatedAt: DateFilter
    variant: VariantFilter
}

input LineItemFilter {
    VariantProductStoreCategoryType: StringFilter
    actn: StringFilter
    actnNull: String
    createdAt: DateFilter
    id: IDFilter
    inventoryUnits: InventoryUnitFilter
    order: OrderFilter
    packedAt: DateFilter
    packedAtTime: StringFilter
    packedBy: UserFilter
    price: IntFilter
    product: ProductFilter
    quantity: IntFilter
    segment: SupplySegmentFilter
    segmentId: IDFilter
    takeLocation: StoreLocationFilter
    takenAt: DateFilter
    takenBy: UserFilter
    takenLocation: StoreLocationFilter
    updatedAt: DateFilter
    variant: VariantFilter
    vendor: VendorFilter
    vendorId: IDFilter
}

input LineItemInput {
    options: JSON
    quantity: Int
    variantId: ID
}

"Listing хайх талбарууд"
input ListingFilter {
    afterPay: BoolFilter
    approved: BoolFilter
    createdAt: DateFilter
    fulfillDuration: IntFilter
    hideOnSearch: BoolFilter
    id: IDFilter
    maxQty: IntFilter
    minQty: IntFilter
    product: ProductFilter
    published: BoolFilter
    seoDescription: StringFilter
    seoKeywords: StringFilter
    seoTitle: StringFilter
    shippingCategory: ShippingCategoryFilter
    slug: StringFilter
    stockLocations: StockLocationFilter
    taxons: TaxonFilter
    updatedAt: DateFilter
    vendorListing: VendorListingFilter
    withSale: Int
}

input ListingSaleInput {
    amount: Float!
    expireAt: ISO8601DateTime
    id: ID!
    remove: Boolean
    startAt: ISO8601DateTime
}

input ListingVendorFilter {
    listingId: ID!
    status: String!
}

input LoanContractInput {
    attachments: [Upload!]
    "ID"
    id: ID
    name: String
}

input LookBookFilter {
    createdAt: DateFilter
    description: StringFilter
    id: IDFilter
    isDraft: BoolFilter
    title: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input MassMessageFilter {
    acceptedBy: UserFilter
    content: StringFilter
    createdAt: DateFilter
    id: IDFilter
    segment: StringFilter
    status: StringFilter
    type: StringFilter
    updatedAt: DateFilter
    user: UserFilter
}

input MassPromoFilter {
    createdAt: DateFilter
    createdBy: UserFilter
    finishedAt: DateFilter
    id: IDFilter
    promotion: PromotionFilter
    status: StringFilter
    updatedAt: DateFilter
    userCount: IntFilter
    users: StringFilter
}

input MemberFilter {
    createdAt: DateFilter
    id: IDFilter
    role: StringFilter
    updatedAt: DateFilter
    user: UserFilter
}

input MerchantFilter {
    afterPay: StringFilter
    afterPayApprovedAt: DateFilter
    afterPayApprover: UserFilter
    afterPayEq: AfterPay
    alias: StringFilter
    aliasOrVendorName: StringFilter
    allowCampaign: BoolFilter
    autoApprove: BoolFilter
    category: SupplierCategoryFilter
    createdAt: DateFilter
    featured: Boolean
    id: IDFilter
    isActive: IntFilter
    listingsCount: IntFilter
    receiveOrderNotifications: BoolFilter
    searchState: String
    updatedAt: DateFilter
    vendor: VendorFilter
    vendorNameOrVendorRegister: StringFilter
    vendorNameOrVendorRegisterOrVendorPhone: StringFilter
    website: WebsiteFilter
    websiteNameOrWebsiteDomain: StringFilter
    withListings: BoolFilter
    withTaxon: StringFilter
}

input MessageFilter {
    content: StringFilter
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input MovieFilter {
    createdAt: DateFilter
    id: IDFilter
    idx: StringFilter
    imdb: IntFilter
    runtime: IntFilter
    title: StringFilter
    updatedAt: DateFilter
}

input MovieTicketFilter {
    active: BoolFilter
    createdAt: DateFilter
    id: IDFilter
    lineItem: LineItemFilter
    order: OrderFilter
    price: IntFilter
    product: ProductFilter
    seat: StringFilter
    status: StringFilter
    updatedAt: DateFilter
    variant: VariantFilter
}

input NewsFilter {
    active: BoolFilter
    cat: StringFilter
    createdAt: DateFilter
    id: IDFilter
    taggedWith: String
    tags: TagFilter
    title: StringFilter
    updatedAt: DateFilter
}

input NoticeFilter {
    createdAt: DateFilter
    id: IDFilter
    path: StringFilter
    title: StringFilter
    updatedAt: DateFilter
}

input NotificationFilter {
    createdAt: DateFilter
    id: IDFilter
    read: Boolean
    unread: Boolean
    updatedAt: DateFilter
}

input NutritionFactFilter {
    code: StringFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
    vendor: VendorFilter
}

input OneSignalDeviceFilter {
    adId: StringFilter
    amountSpent: StringFilter
    badgeCount: StringFilter
    country: StringFilter
    createdAt: DateFilter
    deviceModel: StringFilter
    deviceOs: StringFilter
    deviceType: StringFilter
    gameVersion: StringFilter
    id: IDFilter
    identifier: StringFilter
    ip: StringFilter
    lang: StringFilter
    language: StringFilter
    lastActive: StringFilter
    oneSignalId: StringFilter
    sessionCount: StringFilter
    subscribed: IntFilter
    tags: StringFilter
    timezone: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    webAuth: StringFilter
    webP256: StringFilter
    website: WebsiteFilter
}

input OptionTypeFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    nameOrPresentation: StringFilter
    presentation: StringFilter
    updatedAt: DateFilter
    websiteId: IDFilter
}

input OptionValueFilter {
    byRelevance: String
    code: StringFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    nameOrPresentation: StringFilter
    optionType: OptionTypeFilter
    presentation: StringFilter
    updatedAt: DateFilter
}

"Filter object for OrderComment"
input OrderCommentFilter {
    comment: StringFilter
    commentTypeId: StringFilter
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
    user: UserFilter
}

"Filter object for Order"
input OrderFilter {
    adjustmentTotal: IntFilter
    approvedAt: DateFilter
    approvedOrder: OrderFilter
    approvedOrderId: IDFilter
    approver: UserFilter
    approverId: IDFilter
    archived: BoolFilter
    billAddress: AddressFilter
    channel: StringFilter
    clientsStore: ClientsStoreFilter
    clientsStoreId: IDFilter
    collect: CollectFilter
    comments: OrderCommentFilter
    completedAt: DateFilter
    contractStatus: StringFilter
    createdAt: DateFilter
    driver: UserFilter
    driverTakenAt: DateFilter
    flag: StringFilter
    flaggedAt: DateFilter
    hasComments: StringFilter
    id: IDFilter
    itemCount: IntFilter
    itemTotal: IntFilter
    leaseLeft: IntFilter
    leaseState: StringFilter
    leasingContract: ContractFilter
    lineItems: LineItemFilter
    localCode: StringFilter
    number: StringFilter
    paidAt: DateFilter
    paymentState: StringFilter
    payments: PaymentFilter
    segment: SupplySegmentFilter
    shipAddress: AddressFilter
    shipmentState: StringFilter
    shipmentTotal: IntFilter
    shippedAt: DateFilter
    state: StringFilter
    stockLocationName: StringFilter
    storeLocation: StoreLocationFilter
    supplierStockLocation: StockLocationFilter
    supplierStockLocationId: IDFilter
    total: IntFilter
    updatedAt: DateFilter
    userFirstNameOrUserLastName: StringFilter
    userId: IDFilter
    whenToShip: DateFilter
}

"Filter object for order template"
input OrderTemplateFilter {
    branch: BranchFilter
    business: VendorFilter
    createdAt: DateFilter
    createdBy: UserFilter
    id: StringFilter
    name: StringFilter
    nextDate: DateFilter
    rule: StringFilter
    status: StringFilter
    updatedAt: DateFilter
    vendor: VendorFilter
    website: WebsiteFilter
    whenToShip: StringFilter
}

input OrderTemplateItemInput {
    "ID"
    id: ID
    orderTemplateId: ID
    quantity: Int
    variantId: ID
}

input PageFilter {
    createdAt: DateFilter
    id: IDFilter
    metaDescription: StringFilter
    metaKeywords: StringFilter
    metaTitle: StringFilter
    seoDescription: StringFilter
    seoKeywords: StringFilter
    seoTitle: StringFilter
    seoVisible: BoolFilter
    slug: StringFilter
    title: StringFilter
    updatedAt: DateFilter
    visible: BoolFilter
}

"Filter object for Payment"
input PaymentFilter {
    amount: IntFilter
    bankName: StringFilter
    capturedBy: UserFilter
    createdAt: DateFilter
    id: IDFilter
    number: StringFilter
    order: OrderFilter
    paymentMethod: PaymentMethodFilter
    sourceType: StringFilter
    state: StringFilter
    updatedAt: DateFilter
}

"Filter object for Order"
input PaymentMethodFilter {
    active: BoolFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input PaymentReturnFilter {
    accountBank: StringFilter
    accountName: StringFilter
    accountNumber: StringFilter
    amount: IntFilter
    createdAt: DateFilter
    creator: UserFilter
    id: IDFilter
    message: StringFilter
    note: StringFilter
    number: StringFilter
    order: OrderFilter
    payment: PaymentFilter
    returner: UserFilter
    status: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input PaymentReturnReasonFilter {
    createdAt: DateFilter
    description: StringFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input PaymentReturnSourceFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input PaymentSourceFilter {
    createdAt: DateFilter
    id: IDFilter
    idx: StringFilter
    idx2: StringFilter
    invoice: StringFilter
    order: OrderFilter
    orderNumber: StringFilter
    payment: PaymentFilter
    paymentMethod: PaymentMethodFilter
    secureData: StringFilter
    updatedAt: DateFilter
    user: UserFilter
}

input PollFilter {
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input PollQuestionInput {
    _destroy: Boolean
    "ID"
    id: ID
    name: String
}

"Pos Listing хайх талбарууд"
input PosListingFilter {
    approved: BoolFilter
    createdAt: DateFilter
    id: IDFilter
    product: ProductFilter
    published: BoolFilter
    slug: StringFilter
    updatedAt: DateFilter
}

input PrescriptionFilter {
    code: StringFilter
    createdAt: DateFilter
    diagnosis: StringFilter
    doctorHospital: StringFilter
    doctorName: StringFilter
    id: IDFilter
    number: StringFilter
    order: OrderFilter
    patientName: StringFilter
    reviewer: UserFilter
    status: EnumStringFilter
    updatedAt: DateFilter
    user: UserFilter
    website: WebsiteFilter
}

input PriceFilter {
    amount: IntFilter
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input PrintingFilter {
    createdAt: DateFilter
    firstName: StringFilter
    id: IDFilter
    lastName: StringFilter
    lineItem: LineItemFilter
    mobile: StringFilter
    order: OrderFilter
    preview: StringFilter
    product: ProductFilter
    publishedAt: DateFilter
    title: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input ProductFilter {
    availableOn: DateFilter
    availableUntil: DateFilter
    canSupply: StringFilter
    createdAt: DateFilter
    hasImage: StringFilter
    id: IDFilter
    keyword: KeywordFilter
    listings: ListingFilter
    master: VariantFilter
    metaDescription: StringFilter
    metaKeywords: StringFilter
    metaTitle: StringFilter
    name: StringFilter
    nameOrSlug: StringFilter
    productCat: StringFilter
    productProperties: ProductPropertyFilter
    prototype: PrototypeFilter
    sellingPrice: IntFilter
    slug: StringFilter
    store: BrandFilter
    title: StringFilter
    totalOnHand: IntFilter
    updatedAt: DateFilter
    variantsIncludingMaster: VariantFilter
    vendor: VendorFilter
}

input ProductInput {
    cancelDuration: Int
    condition: String
    keywordId: ID
    name: String
    productCat: ProductCat
    shippingCategoryId: ID
    storeId: ID
    title: String
}

input ProductPropertyFilter {
    createdAt: DateFilter
    id: IDFilter
    property: PropertyFilter
    updatedAt: DateFilter
    value: StringFilter
}

input ProductReturnFilter {
    createdAt: DateFilter
    id: IDFilter
    returnAt: DateFilter
    returnBy: StringFilter
    returnByDate: DateFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input PromotionActionFilter {
    createdAt: DateFilter
    id: IDFilter
    promotion: PromotionFilter
    promotionActionLineItems: PromotionActionLineItemFilter
    type: StringFilter
    updatedAt: DateFilter
}

input PromotionActionLineItemFilter {
    createdAt: DateFilter
    id: IDFilter
    promotionAction: PromotionActionFilter
    quantity: StringFilter
    updatedAt: DateFilter
    variant: VariantFilter
}

input PromotionActionPromiseFilter {
    createdAt: DateFilter
    id: IDFilter
    order: OrderFilter
    promotionAction: PromotionActionFilter
    status: StringFilter
    updatedAt: DateFilter
}

input PromotionFilter {
    code: StringFilter
    createdAt: DateFilter
    expiresAt: DateFilter
    gifts: Boolean
    id: IDFilter
    minType: StringFilter
    name: StringFilter
    orders: OrderFilter
    percents: Boolean
    promotionActions: PromotionActionFilter
    promotionRules: PromotionRuleFilter
    startsAt: DateFilter
    updatedAt: DateFilter
    usageLimit: IntFilter
    vendor: VendorFilter
    websites: WebsiteFilter
    withProduct: StringFilter
    withVariant: StringFilter
}

input PromotionRuleFilter {
    createdAt: DateFilter
    id: IDFilter
    promotion: PromotionFilter
    type: StringFilter
    updatedAt: DateFilter
}

input PropertyFilter {
    advancedSearch: String
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    nameOrPresentation: StringFilter
    presentation: StringFilter
    prettyName: StringFilter
    updatedAt: DateFilter
}

input PropertyValueFilter {
    createdAt: DateFilter
    id: IDFilter
    property: PropertyFilter
    propertyId: IDFilter
    updatedAt: DateFilter
    value: StringFilter
}

input PrototypeFilter {
    createdAt: DateFilter
    depth: IntFilter
    id: IDFilter
    name: StringFilter
    parent: PrototypeFilter
    parentId: IDFilter
    position: IntFilter
    prettyName: StringFilter
    updatedAt: DateFilter
}

input ProviderFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    status: StringFilter
    type: StringFilter
    updatedAt: DateFilter
}

input PushTemplateFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
    websiteId: IntFilter
}

input QuarterFilter {
    createdAt: DateFilter
    districtId: IntFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input RelationFilter {
    createdAt: DateFilter
    discountAmount: IntFilter
    expireAt: DateFilter
    id: IDFilter
    position: IntFilter
    relatedSku: StringFilter
    relatedToSku: StringFilter
    relationType: RelationTypeFilter
    relationTypeId: IDFilter
    startAt: DateFilter
    updatedAt: DateFilter
    website: WebsiteFilter
    websiteId: IDFilter
}

input RelationTypeFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input ReportReasonFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input ReportsFilter {
    createdAt: DateFilter
    id: IDFilter
    message: StringFilter
    reportReason: ReportReasonFilter
    reportReasonId: IntFilter
    targetId: IntFilter
    targetType: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    userFirstNameOrUserMobileOrUserEmail: StringFilter
    withStatus: StringFilter
    withTargetKinds: StringFilter
    withTargets: StringFilter
}

input ReviewsFilter {
    comment: StringFilter
    createdAt: DateFilter
    id: IDFilter
    rating: StringFilter
    reviewableId: IntFilter
    reviewableType: StringFilter
    sourceId: IDFilter
    sourceType: StringFilter
    updatedAt: DateFilter
    userFirstNameOrUserMobileOrUserEmail: StringFilter
    withReviewableKinds: StringFilter
    withReviewables: StringFilter
}

input RoomFilter {
    aroundWebsiteId: IDFilter
    createdAt: DateFilter
    id: IDFilter
    members: MemberFilter
    membersUserMobileOrMembersUserFirstName: StringFilter
    messages: MessageFilter
    productId: IntFilter
    productVendorId: IntFilter
    title: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    userEmailOrUserMobileOrUserFirstName: StringFilter
    userId: IDFilter
    website: WebsiteFilter
}

input SegmentClientFilter {
    client: BusinessClientFilter
    clientId: IDFilter
    createdAt: DateFilter
    id: IDFilter
    segment: SupplySegmentFilter
    segmentId: IDFilter
    segmentedAt: DateFilter
    status: EnumStringFilter
    updatedAt: DateFilter
}

input SegmentWhiteListFilter {
    company: StringFilter
    createdAt: DateFilter
    email: StringFilter
    entries: WhiteListEntryFilter
    id: IDFilter
    mobile: StringFilter
    referral: UserFilter
    referralId: IDFilter
    registerNo: StringFilter
    segment: SupplySegmentFilter
    segmentId: IDFilter
    status: StringFilter
    updatedAt: DateFilter
}

"Autogenerated input type of SendErpLoyaltyRequest"
input SendErpLoyaltyRequestInput {
    address: String!
    birthDate: String!
    cardId: String!
    cardPassword: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    customerName: String!
    customerParentName: String!
    email: String!
    gender: String!
    maritalStatus: String!
    mobilePhone: String!
    note: String!
    registerNumber: String!
    workAddress: String!
}

input ShipmentFilter {
    address: AddressFilter
    cost: IntFilter
    createdAt: DateFilter
    id: IDFilter
    inventoryUnits: InventoryUnitFilter
    number: StringFilter
    order: OrderFilter
    shippedAt: DateFilter
    shippedBy: UserFilter
    shippedById: StringFilter
    state: StringFilter
    step: IntFilter
    stockLocations: StockLocationFilter
    updatedAt: DateFilter
}

input ShipmentTrackingFilter {
    createdAt: DateFilter
    id: IDFilter
    order: OrderFilter
    trackingNumber: StringFilter
    updatedAt: DateFilter
}

input ShippingCategoryFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    step: IntFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input ShippingMethodFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    shippingCategoriesId: IDFilter
    step: IntFilter
    updatedAt: DateFilter
}

input ShoppyImageFilter {
    attachmentContentType: StringFilter
    attachmentFileName: StringFilter
    attachmentFileSize: IntFilter
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
    user: UserFilter
    vendor: VendorFilter
    website: WebsiteFilter
}

input ShoppyTrackableFilter {
    acceptedOrderCount: IntFilter
    createdAt: DateFilter
    id: IDFilter
    isAvailable: BoolFilter
    latitude: StringFilter
    longitude: StringFilter
    orderCount: IntFilter
    rejectedOrderCount: IntFilter
    updatedAt: DateFilter
}

input SizingGuideFilter {
    ageGroup: StringFilter
    createdAt: DateFilter
    gender: StringFilter
    grouping: StringFilter
    id: IDFilter
    store: BrandFilter
    title: StringFilter
    updatedAt: DateFilter
    vendor: VendorFilter
    withListing: StringFilter
}

input SmsFilter {
    content: StringFilter
    createdAt: DateFilter
    from: StringFilter
    id: IDFilter
    operator: StringFilter
    price: IntFilter
    sender: StringFilter
    sentAt: DateFilter
    status: StringFilter
    to: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
}

input SortFilter {
    direction: SortDirection
    field: String!
}

input StateFilter {
    countryId: IntFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input StockItemFilter {
    address1: StringFilter
    adminName: StringFilter
    backorderable: BoolFilter
    countOnHand: IntFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    stockLocation: StockLocationFilter
    storeLocation: StoreLocationFilter
    updatedAt: DateFilter
    vendor: VendorFilter
}

input StockLocationFilter {
    active: BoolFilter
    address1: StringFilter
    createdAt: DateFilter
    default: BoolFilter
    id: IDFilter
    listings: ListingFilter
    name: StringFilter
    nameOrAdminName: StringFilter
    storeLocation: StoreLocationFilter
    updatedAt: DateFilter
    withProduct: StringFilter
}

input StoreCreditEventFilter {
    action: StringFilter
    amount: IntFilter
    createdAt: DateFilter
    id: IDFilter
    storeCredit: StoreCreditFilter
    updatedAt: DateFilter
    user: UserFilter
    userTotalAmount: IntFilter
    website: WebsiteFilter
}

input StoreCreditFilter {
    amount: IntFilter
    amountAuthorized: StringFilter
    amountUsed: IntFilter
    categoryId: StringFilter
    createdAt: DateFilter
    id: IDFilter
    memo: StringFilter
    originator: GiftCardFilter
    originatorId: IDFilter
    originatorType: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    userEmailOrUserMobile: StringFilter
    website: WebsiteFilter
}

input StoreListingFilter {
    createdAt: DateFilter
    id: IDFilter
    listing: ListingFilter
    status: StringFilter
    updatedAt: DateFilter
    vendor: VendorFilter
}

input StoreListingInput {
    description: String
    listingId: ID!
    status: String!
    vendorId: ID!
}

input StoreLocationFilter {
    address: StringFilter
    businessType: BusinessTypeFilter
    code: StringFilter
    createdAt: DateFilter
    departmentStore: DepartmentStoreFilter
    id: IDFilter
    locationAddress: AddressFilter
    phone: StringFilter
    store: BrandFilter
    stores: BrandFilter
    title: StringFilter
    titleOrVendorName: StringFilter
    updatedAt: DateFilter
    vendor: VendorFilter
    withStatus: StringFilter
}

input StringFilter {
    "is blank ?"
    blank: Boolean
    "contains"
    cont: String
    "ends with"
    end: String
    "equals to"
    eq: String
    "in: Matches any values in giver array"
    in: [String!]
    "not equals to"
    notEq: String
    "in: Matches none of values in giver array"
    notIn: [String!]
    "is null ?"
    notNull: Boolean
    "is null ?"
    null: Boolean
    "starts with"
    start: String
}

"Filter object for Supplier Category"
input SupplierCategoryFilter {
    active: BoolFilter
    createdAt: DateFilter
    description: StringFilter
    id: IDFilter
    name: StringFilter
    position: IntFilter
    updatedAt: DateFilter
}

input SupplySegmentFilter {
    active: BoolFilter
    clientsCount: IntFilter
    code: StringFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    nameOrCode: StringFilter
    type: StringFilter
    updatedAt: DateFilter
    usersCount: IntFilter
}

input SwapItemInput {
    "quantity"
    quantity: Int!
    "variant ID"
    variantId: ID!
}

input TagFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input TaxonFilter {
    createdAt: DateFilter
    depth: IntFilter
    id: IDFilter
    listingsCount: IntFilter
    name: StringFilter
    parent: TaxonFilter
    parentId: IDFilter
    permalink: StringFilter
    position: IntFilter
    prettyName: StringFilter
    taxCode: StringFilter
    updatedAt: DateFilter
    website: WebsiteFilter
    withListings: BoolFilter
}

input TicketTemplateFilter {
    createdAt: DateFilter
    height: IntFilter
    id: IDFilter
    pos: BoolFilter
    sku: StringFilter
    storeLocation: StoreLocationFilter
    updatedAt: DateFilter
    vendor: VendorFilter
    website: WebsiteFilter
    width: IntFilter
}

input TransactionFilter {
    action: EnumStringFilter
    amount: IntFilter
    archived: BoolFilter
    authorizedAt: DateFilter
    balance: IntFilter
    bonus: IntFilter
    cgwId: IDFilter
    code: StringFilter
    createdAt: DateFilter
    description: StringFilter
    dueDate: DateFilter
    id: IDFilter
    loanStatus: EnumStringFilter
    number: StringFilter
    relatedAccount: StringFilter
    status: EnumStringFilter
    transactionAt: DateFilter
    transactionDate: DateFilter
    typeCode: EnumStringFilter
    updatedAt: DateFilter
    wallet: WalletFilter
    website: WebsiteFilter
}

input TranslationInput {
    _destroy: Boolean
    body: String
    locale: String!
    metaDescription: String
    metaKeywords: String
    metaTitle: String
    name: String
    title: String
}

input UserAddressFilter {
    address: AddressFilter
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input UserAgreementFilter {
    calculatedAt: DateFilter
    cartState: StringFilter
    cartTotal: IntFilter
    createdAt: DateFilter
    id: IDFilter
    ordersCount: IntFilter
    ordersTotal: IntFilter
    search: StringFilter
    storeLocation: StoreLocationFilter
    termsAccepted: BoolFilter
    updatedAt: DateFilter
    user: UserFilter
    website: WebsiteFilter
}

input UserArticleFilter {
    article: ArticleFilter
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input UserEmploymentFilter {
    company: StringFilter
    createdAt: DateFilter
    id: IDFilter
    jobTitle: StringFilter
    updatedAt: DateFilter
}

input UserFilter {
    birthday: DateFilter
    createdAt: DateFilter
    email: StringFilter
    emailOrMobile: StringFilter
    emailOrMobileOrFirstName: StringFilter
    emailOrUnconfirmedEmail: StringFilter
    employment: UserEmploymentFilter
    firstName: StringFilter
    firstNameOrLastName: StringFilter
    gender: StringFilter
    id: IDFilter
    lastName: StringFilter
    mobile: StringFilter
    mobileOrUnconfirmedMobile: StringFilter
    mobileOrUnconfirmedMobileOrEmailOrFirstName: StringFilter
    orderCount: IntFilter
    registerNum: StringFilter
    shoppyTrackable: ShoppyTrackableFilter
    storeLocations: StoreLocationFilter
    updatedAt: DateFilter
    userVerifications: UserVerificationFilter
    website: WebsiteFilter
    websiteAgreements: UserAgreementFilter
}

input UserSegmentFilter {
    createdAt: DateFilter
    expiresAt: DateFilter
    id: IDFilter
    segment: SupplySegmentFilter
    segmentId: IDFilter
    status: StringFilter
    total: IntFilter
    updatedAt: DateFilter
    user: UserFilter
    userId: IDFilter
    website: WebsiteFilter
    websiteId: IDFilter
}

"Filter object for user verification"
input UserVerificationFilter {
    createdAt: DateFilter
    id: IDFilter
    status: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    vendor: VendorFilter
}

input VariantFilter {
    backorderable: StringFilter
    barcode: StringFilter
    canSupply: StringFilter
    createdAt: DateFilter
    defaultPrice: PriceFilter
    fragile: BoolFilter
    hasStock: BoolFilter
    id: IDFilter
    labelCode: StringFilter
    merchantSku: StringFilter
    name: StringFilter
    nameOrSku: StringFilter
    nonReturnable: BoolFilter
    optionsText: StringFilter
    packageCode: StringFilter
    price: IntFilter
    product: ProductFilter
    salePrices: PriceFilter
    sellingPrice: IntFilter
    sku: StringFilter
    stockItems: StockItemFilter
    stockLocked: BoolFilter
    taxCode: StringFilter
    totalOnHand: IntFilter
    updatedAt: DateFilter
    weight: IntFilter
}

input VariantInput {
    _destroy: Boolean
    barcode: String
    bonusPoint: Float
    costPrice: Float
    currency: String
    depth: Float
    fragile: Boolean
    height: Float
    hsCode: String
    "ID"
    id: ID
    imageLinks: [String!]
    images: [String!]
    labelCode: String
    merchantSku: String
    netWeight: Float
    nonReturnable: Boolean
    options: JSON
    originalPrice: Float
    packageCode: String
    position: Int
    price: Float
    priceCny: Float
    priceJpy: Float
    priceKrw: Float
    priceMnt: Float
    priceRub: Float
    priceUsd: Float
    priceUzs: Float
    sku: String
    stock: Int
    stockLocations: JSON
    stockLocked: Boolean
    taxCode: String
    weight: Float
    width: Float
}

input VendorFilter {
    channels: MerchantFilter
    createdAt: DateFilter
    ebarimtType: StringFilter
    email: StringFilter
    id: IDFilter
    isIndividual: BoolFilter
    listingVendor: ListingVendorFilter
    name: StringFilter
    nameEn: StringFilter
    nameOrRegister: StringFilter
    nameOrRegisterOrNameEn: StringFilter
    personalNumber: StringFilter
    phone: StringFilter
    pos: BoolFilter
    products: ProductFilter
    register: StringFilter
    taxNumber: StringFilter
    updatedAt: DateFilter
}

input VendorListingFilter {
    status: String!
    vendorId: ID!
}

input WalletFilter {
    availableAmount: IntFilter
    balance: IntFilter
    bonus: IntFilter
    code: StringFilter
    createdAt: DateFilter
    freezeAmount: IntFilter
    id: IDFilter
    isVerified: StringFilter
    lastTransactionDate: DateFilter
    name: StringFilter
    pinCodeStatus: StringFilter
    pinCodeUpdatedAt: DateFilter
    product: WalletProductFilter
    status: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    userFirstNameOrUserMobileOrUserEmail: StringFilter
    vendor: VendorFilter
    website: WebsiteFilter
}

input WalletProductFilter {
    code: StringFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input WalletRequestFilter {
    authorizedBy: UserFilter
    createdAt: DateFilter
    description: StringFilter
    id: IDFilter
    reason: StringFilter
    status: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    vendor: VendorFilter
    wallet: WalletFilter
    website: WebsiteFilter
}

input WebsiteFilter {
    createdAt: DateFilter
    currency: StringFilter
    domain: StringFilter
    id: IDFilter
    index: StringFilter
    isActive: BoolFilter
    name: StringFilter
    nameOrDomain: StringFilter
    sslExpiresAt: DateFilter
    updatedAt: DateFilter
    vendor: VendorFilter
}

input WhiteListEntryFilter {
    addedUser: UserFilter
    company: StringFilter
    createdAt: DateFilter
    entryDate: DateFilter
    id: IDFilter
    segment: SupplySegmentFilter
    updatedAt: DateFilter
    used: BoolFilter
    user: UserFilter
    whiteList: SegmentWhiteListFilter
}

input WishedProductFilter {
    createdAt: DateFilter
    id: IDFilter
    quantity: IntFilter
    total: IntFilter
    updatedAt: DateFilter
    user: UserFilter
    userId: IDFilter
    variant: VariantFilter
    variantId: IDFilter
    website: WebsiteFilter
    websiteId: IDFilter
    websiteTotal: IntFilter
}

input WishlistFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    userId: IDFilter
    website: WebsiteFilter
    websiteId: IDFilter
}

"Autogenerated input type of acceptMassChatMessage"
input acceptMassChatMessageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of acceptPrescription"
input acceptPrescriptionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    reviewComment: String
    status: PrescriptionStatus
}

"Autogenerated input type of actionCollect"
input actionCollectInput {
    action: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    params: JSON
}

"Autogenerated input type of activationETicket"
input activationETicketInput {
    "citizen id"
    citizenId: String!
    "citizenship"
    citizenship: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "email"
    email: String!
    "first name"
    firstName: String!
    "e-ticket id"
    id: ID!
    "last name"
    lastName: String!
    "organization"
    organization: String
    "phone"
    phone: String!
    "additional phone"
    phoneAdditional: String
}

"Autogenerated input type of activationSyncETicket"
input activationSyncETicketInput {
    "Citizen ID"
    citizenId: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Email"
    email: String
    "First name"
    firstName: String
    "e-ticket id"
    id: ID
    "Last name"
    lastName: String
    "NFC ID"
    nfcId: String!
    "e-ticket number"
    number: String
    "Phone number"
    phone: String
}

"Autogenerated input type of addBankAccount"
input addBankAccountInput {
    accountNo: String!
    additionalDetails: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    name: String!
    password: String!
}

"Autogenerated input type of addBatchStoreListings"
input addBatchStoreListingsInput {
    businessId: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    sku: String!
    status: String!
    vendorId: ID!
    websiteId: ID!
}

"Autogenerated input type of addCampaignList"
input addCampaignListInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Campaign ID"
    id: ID!
    listings: [CampaignListingInput!]!
}

"Autogenerated input type of addComment"
input addCommentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    comment: String!
    commentableId: ID!
    "vendor, order, product ..."
    commentableType: String!
    data: JSON
    mentions: [ID!]
    title: String
}

"Autogenerated input type of addEmployee"
input addEmployeeInput {
    assets: JSON
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String
    firstName: String!
    lastName: String
    "Mobile: required if email blank"
    mobile: String
    "mscode b2b"
    msCode: String
    "Employee role"
    role: EmployeeRole!
    "Reseller bonus"
    salesManagerBonus: Float
    "Is vendor"
    salesManagerIsVendor: Boolean
    "Taxpayer number"
    salesManagerTaxpayerNumber: String
    userId: ID
    "Business/Vendor id to add"
    vendorId: ID!
}

"Autogenerated input type of addOrderNote"
input addOrderNoteInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    comment: String!
    commentTypeId: ID
    mentions: [ID!]
    "Order ID"
    orderId: ID!
}

"Autogenerated input type of addPrescriptionItem"
input addPrescriptionItemInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    drugName: String!
    drugNumber: String
    frequency: Int
    prescriptionId: ID!
    quantity: Int!
    variantIds: [ID!]
}

"Autogenerated input type of addPromotionNote"
input addPromotionNoteInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    comment: String!
    commentTypeId: ID
    mentions: [ID!]
    "Promotion ID"
    promotionId: ID!
}

"Autogenerated input type of addStockToLocation"
input addStockToLocationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    quantity: Int!
    stockLocationId: ID!
    variantId: ID!
}

"Autogenerated input type of addToCart"
input addToCartInput {
    "Batch add to cart"
    batch: [CartItemInput!]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order number"
    number: String
    "Additional parameters for current action"
    params: JSON
    "Add single item"
    single: CartItemInput
    "Store location id"
    takeLocationId: ID
    "Order token"
    token: String
}

"Autogenerated input type of addToWish"
input addToWishInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    quantity: Int
    remark: String
    variantId: ID!
    wishlistId: ID
}

"Autogenerated input type of applyCoupon"
input applyCouponInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    couponCode: String!
    orderId: ID!
}

"Autogenerated input type of approveOrders"
input approveOrdersInput {
    action: ApproveAction
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    clientsStoreId: ID!
    comment: String
    ids: [ID!]!
}

"Autogenerated input type of assignMassPromo"
input assignMassPromoInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    promotionId: ID!
    "user ids"
    users: String!
}

"Autogenerated input type of authChangePassword"
input authChangePasswordInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "email or mobile"
    login: String
    password: String!
    token: String!
}

"Autogenerated input type of authChangePasswordWithOld"
input authChangePasswordWithOldInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "current valid password"
    currentPassword: String!
    password: String!
    passwordConfirm: String!
}

"Autogenerated input type of authCheckLogin"
input authCheckLoginInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Login email or mobile"
    login: String!
    "True for sending token"
    noToken: Boolean
    otp: Boolean
}

"Autogenerated input type of authRegister"
input authRegisterInput {
    birthday: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    familyName: String
    firstName: String
    gender: Gender
    lastName: String
    "email or mobile"
    login: String!
    "ISO 3166-1 alpha-2. ex: MN"
    nationality: String
    "New password"
    password: String!
    registerNum: String
    "if login is mobile, then token is required"
    token: String
}

"Autogenerated input type of authResetPassword"
input authResetPasswordInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Имэйл эсвэл утасны дугаар"
    login: String!
    """

    Хэрэв email ээр сэргээж байгаа бол холбоосоор redirect хийх хаягийг тодорхойлж болно жишээ нь:
    `https://shoppy.mn/password/reset` эсвэл deeplink `shoppy://reset/pass`
    """
    redirectUri: String
}

"Autogenerated input type of authValidateOTP"
input authValidateOTPInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "email or mobile"
    login: String!
    token: String!
}

"Autogenerated input type of batchUpdateVariants"
input batchUpdateVariantsInput {
    barcode: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    costPrice: Float
    depth: Float
    fragile: Boolean
    height: Float
    hsCode: String
    id: [ID!]!
    labelCode: String
    netWeight: Float
    nonReturnable: Boolean
    packageCode: String
    price: Float
    priceCny: Float
    priceJpy: Float
    priceKrw: Float
    priceMnt: Float
    priceRub: Float
    priceUsd: Float
    priceUzs: Float
    taxCode: String
    weight: Float
    width: Float
}

"Autogenerated input type of blackFridayPromotion"
input blackFridayPromotionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of cancelOrderTemplate"
input cancelOrderTemplateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of changeItem"
input changeItemInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Line item id"
    id: ID!
    "Item quantity"
    quantity: Int
    "Order token"
    token: String
    variantId: ID!
}

"Autogenerated input type of changeLoyaltyCardPassword"
input changeLoyaltyCardPasswordInput {
    cardId: ID!
    cardPassword: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    otp: String!
}

"Autogenerated input type of changeWalletPin"
input changeWalletPinInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID
    pinCode: String!
    previousCode: String
}

"Autogenerated input type of chargeGiftCard"
input chargeGiftCardInput {
    amount: Float!
    billAddress: AddressInput
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    number: String!
}

"Autogenerated input type of checkAlifPayCard"
input checkAlifPayCardInput {
    cardNum: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    paymentId: ID!
}

"Autogenerated input type of checkGolomtCardPassword"
input checkGolomtCardPasswordInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    golomtCardId: ID!
    password: String
}

"Autogenerated input type of checkIntendUser"
input checkIntendUserInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    username: String!
}

"Autogenerated input type of checkLoyaltyCardInfo"
input checkLoyaltyCardInfoInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    phone: String!
}

"Autogenerated input type of checkMobile"
input checkMobileInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    mobile: String!
}

"Autogenerated input type of checkPayment"
input checkPaymentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of checkPosStageTicket"
input checkPosStageTicketInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    options: JSON
    "Quantity of tickets to book"
    quantity: Int!
    "Stage ticket variant id"
    variantId: ID!
}

"Autogenerated input type of checkSegmentWhiteList"
input checkSegmentWhiteListInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "email"
    options: JSON
}

"Autogenerated input type of christmasSlotPromotion"
input christmasSlotPromotionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of claimGift"
input claimGiftInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    ids: [ID!]!
    lineItemId: ID
    orderId: ID
    promiseId: ID!
}

"Autogenerated input type of claimPromotion"
input claimPromotionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    ids: [ID!]!
}

"Autogenerated input type of clearViewTrack"
input clearViewTrackInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    datetime: String
}

"Autogenerated input type of clearWish"
input clearWishInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    wishlistId: ID!
}

"Autogenerated input type of collectOrder"
input collectOrderInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    orderId: ID!
}

"Autogenerated input type of confirmAlifPayCharge"
input confirmAlifPayChargeInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    lang: String
    otp: String!
    paymentId: ID!
}

"Autogenerated input type of confirmGolomtVCC"
input confirmGolomtVCCInput {
    amount: Int
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    requestId: String!
}

"Autogenerated input type of confirmIntendInvoice"
input confirmIntendInvoiceInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String!
    paymentId: ID!
}

"Autogenerated input type of confirmMerchant"
input confirmMerchantInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "MerchantId to confirm"
    id: ID!
}

"Autogenerated input type of confirmPosStageTicket"
input confirmPosStageTicketInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order number"
    orderNumber: String!
}

"Autogenerated input type of confirmPrescription"
input confirmPrescriptionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    shippingAddress: AddressInput
    shippingAddressId: ID
}

"Autogenerated input type of createAddress"
input createAddressInput {
    address1: String
    address2: String
    alias: String
    alternativePhone: String
    cdq: [ID!]
    city: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    company: String
    countryId: ID
    districtId: ID
    firstname: String
    gender: String
    geoPoint: String
    isCompany: Boolean
    lastname: String
    latitude: String
    longitude: String
    mnQuarterId: ID
    owningType: String
    phone: String
    quarterId: ID
    stateId: ID
    what3words: String
    year: String
    zipcode: String
}

"Autogenerated input type of createAssetRole"
input createAssetRoleInput {
    "Asset id"
    assetId: ID!
    "Asset type"
    assetType: String!
    "First name"
    businessId: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "People id"
    peopleId: ID!
    "roles"
    roles: [String!]!
}

"Autogenerated input type of createBranch"
input createBranchInput {
    businessTypeId: ID
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    email: String
    name: String!
    phone: String
    phone1: String
    supplySegmentIds: [ID!]
    vendorId: ID!
}

"Autogenerated input type of createCampaign"
input createCampaignInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    cover: Upload
    description: String
    endsAt: ISO8601DateTime!
    fulfillDate: ISO8601Date!
    listings: [CampaignListingInput!]!
    location: String
    maxItemsCount: Int!
    minItemsCount: Int!
    startsAt: ISO8601DateTime!
    title: String!
    vendorId: ID!
}

"Autogenerated input type of createCard"
input createCardInput {
    cardHolder: String
    cardNumber: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "MMYY"
    expiresAt: String!
    provider: String!
}

"Autogenerated input type of createChatRoom"
input createChatRoomInput {
    aroundId: ID!
    "product, listing"
    aroundType: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of createEMailContact"
input createEMailContactInput {
    additionalInfo: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Contact email"
    email: String!
    firstName: String
    lastName: String
    "Website id"
    websiteId: ID
}

"Autogenerated input type of createForm"
input createFormInput {
    active: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    fields: [FormFieldInput!]
    image: Upload
    permalink: String!
    title: String!
    websiteId: ID!
}

"Autogenerated input type of createLease"
input createLeaseInput {
    "Billing Address"
    address: AddressInput
    birthday: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    eduDegree: String
    "User education status"
    education: EducationInput
    "User emergency contracts"
    emergencyContracts: [EmergencyContactInput!]!
    "User employment information"
    employment: EmploymentInput
    familyName: String
    "User finance status"
    finance: FinanceInput
    firstName: String
    gender: String
    lastName: String
    "Loan contracts"
    loanContracts: LoanContractInput
    maritalStatus: String
    nameInvalid: String
    nationality: String
    ndCode: String
    registerNum: String
    repaymentDay: Int
}

"Autogenerated input type of createListings"
input createListingsInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    fulfillDuration: Int
    maxQty: Int
    minQty: Int
    productIds: [ID!]!
    shippingCategoryId: ID!
    stockLocationIds: [ID!]
    taxCategoryId: ID
    websiteId: ID!
}

"Autogenerated input type of createLoyaltyCard"
input createLoyaltyCardInput {
    address: String
    birthDate: String
    cardPassword: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    customerName: String
    customerParentName: String
    email: String
    gender: String
    homeAddress: AddressInput
    maritalStatus: String
    note: String
    otp: String
    phone: String!
    registerNumber: String
}

"Autogenerated input type of createOptionValueImage"
input createOptionValueImageInput {
    "image to upload"
    attachment: Upload!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    optionValueId: ID!
    productId: ID!
}

"Autogenerated input type of createOrUpdateStoreListing"
input createOrUpdateStoreListingInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    storeListings: [StoreListingInput!]!
}

"Autogenerated input type of createOrderTemplateFromOrder"
input createOrderTemplateFromOrderInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    name: String!
    orderId: ID!
}

"Autogenerated input type of createOrderTemplate"
input createOrderTemplateInput {
    "Billing Address"
    billAddress: AddressInput
    branchId: ID
    businessId: ID
    businessTypeIds: [ID!]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "1,3,5,7 or 2. Monday = 1, Sunday = 7"
    dayOfWeek: String
    extraData: JSON
    isDefault: Boolean
    items: [OrderTemplateItemInput!]
    name: String!
    "Start date"
    nextDate: ISO8601DateTime!
    "singular, daily, weekly, monthly"
    rule: String
    "Shipping Address"
    shipAddress: AddressInput
    "Take Location"
    storeLocationId: ID
    "08:00, 15:00, 21:00, 20:30 ..."
    time: String
    vendorId: ID
    websiteId: ID
    whenToShip: ISO8601DateTime
}

"Autogenerated input type of createPoll"
input createPollInput {
    active: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    expireAt: ISO8601DateTime
    image: Upload
    question: String!
    startAt: ISO8601DateTime
    websiteId: ID!
}

"Autogenerated input type of createPrescription"
input createPrescriptionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    image: Upload!
    image1: Upload
}

"Autogenerated input type of createProduct"
input createProductInput {
    "Available on"
    availableOn: String
    barcode: String
    "Brand"
    brand: String
    "Order cancel duration by minutes"
    cancelDuration: Int
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Condition"
    condition: String
    "currency"
    currency: String
    "Description"
    description: String
    fileImages: [Upload!]
    imageLinks: [String!]
    images: [String!]
    info: JSON
    "Keyword"
    keyword: String
    "Keyword ID"
    keywordId: ID
    labelCode: String
    listingOptions: JSON
    merchantSku: String
    "Meta description: SEO recommended to 160 characters"
    metaDescription: String
    "Meta keywords: SEO recommended to 10% of total words on page"
    metaKeywords: String
    "Meta title: SEO, recommended 50 to 60 characters"
    metaTitle: String
    "Product name"
    name: String
    packageCode: String
    price: Float
    "Product Type"
    productCat: ProductCat
    property: JSON
    "Shipping Category ID"
    shippingCategoryId: ID
    sku: String
    "SLUG: url suffix"
    slug: String
    stock: Int
    "Brand ID"
    storeId: ID
    taxCode: String
    "Taxon ids for listing"
    taxonIds: [ID!]
    "Common name"
    title: String
    "Product translations"
    translations: [TranslationInput!]
    "Variants to update"
    variants: [VariantInput!]
    "Vendor attributes to be updated"
    vendor: JSON
    "Vendor ID"
    vendorId: ID!
    "youtube link"
    youtube: String
}

"Autogenerated input type of createPushTemplate"
input createPushTemplateInput {
    appId: ID
    appIds: [ID!]
    body: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    deeplink: String
    "Template Title code"
    name: PushTemplateName!
    "Template Title code"
    title: String!
    url: String
    websiteId: ID!
}

"Autogenerated input type of createReport"
input createReportInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    message: String
    reportReasonId: ID
    targetId: ID!
    "vendor, user, product ..."
    targetType: String!
}

"Autogenerated input type of createReportReason"
input createReportReasonInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    name: String!
    position: Int!
    status: String
    websiteId: ID!
}

"Autogenerated input type of createReview"
input createReviewInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    comment: String
    images: [Upload!]
    rating: Float!
    reviewableId: ID!
    "vendor, user, product ..."
    reviewableType: String!
}

"Autogenerated input type of createSalePrice"
input createSalePriceInput {
    amount: Float!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    currency: String
    eventLabel: Boolean
    expireAt: ISO8601DateTime
    forceOthers: Boolean
    isEvent: Boolean
    qty: Int
    segmentId: ID
    startAt: ISO8601DateTime
    updateAll: Boolean
    variantId: ID!
    websiteId: ID
}

"Autogenerated input type of createShipper"
input createShipperInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    email: String
    logo: Upload
    name: String!
    phoneNumber: String
    taxer: Boolean
    vendorId: ID!
    websiteId: ID!
}

"Autogenerated input type of createShoppyImage"
input createShoppyImageInput {
    attachment: Upload!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    vendorId: ID
    websiteId: ID
}

"Autogenerated input type of createStockLocation"
input createStockLocationInput {
    active: Boolean
    address1: String
    adminName: String!
    backorderableDefault: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    countryId: ID
    default: Boolean
    name: String!
    phone: String
    propagateAllVariants: Boolean
    stateId: ID
    storeLocationId: ID
    timeSheets: JSON
    vendorId: ID!
}

"Autogenerated input type of createTecAlliancePrice"
input createTecAlliancePriceInput {
    articleId: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    price: Float
    stock: Int
}

"Autogenerated input type of createTecAlliancePrices"
input createTecAlliancePricesInput {
    articles: JSON!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of createTracking"
input createTrackingInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    latitude: String!
    longitude: String!
}

"Autogenerated input type of createUPointCard"
input createUPointCardInput {
    cardNumber: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    mobile: String!
    pinCode: String!
}

"Autogenerated input type of createUserAddress"
input createUserAddressInput {
    address: AddressInput!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    userId: ID
}

"Autogenerated input type of createUserArticle"
input createUserArticleInput {
    articleId: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of createVariantImage"
input createVariantImageInput {
    "image to upload"
    attachment: Upload!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    variantId: ID!
}

"Autogenerated input type of createVariant"
input createVariantInput {
    barcode: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    costPrice: Float
    depth: Float
    fragile: Boolean
    height: Float
    hsCode: String
    labelCode: String
    merchantSku: String
    netWeight: Float
    nonReturnable: Boolean
    options: JSON
    packageCode: String
    price: Float
    priceCny: Float
    priceJpy: Float
    priceKrw: Float
    priceMnt: Float
    priceRub: Float
    priceUsd: Float
    priceUzs: Float
    productId: ID!
    sku: String
    taxCode: String
    weight: Float
    width: Float
}

"Autogenerated input type of createVendor"
input createVendorInput {
    address: String
    "City district quarter ids as array: [12, 1212, 121256]"
    cdq: [ID!]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Introduction"
    description: String
    districtId: ID
    "Business e-mail"
    email: String
    "Facebook URL"
    facebook: String
    "Hide mobile number on listings"
    hideInfo: Boolean
    "Instagram URL"
    instagram: String
    "Business register or citizen ID"
    isIndividual: Boolean!
    latitude: String
    "Logo image to upload"
    logo: Upload
    longitude: String
    "Business name"
    name: String!
    "English name"
    nameEn: String
    "Personal Information Number"
    personalNumber: String
    "Business phone"
    phone: String
    "Primary taxons"
    primaryTaxons: [ID!]
    quarterId: ID
    "Business register or citizen ID"
    register: String
    "City ID"
    stateId: ID
    "Tax Identification Number"
    taxNumber: String
    "Business website URL"
    website: String
}

"Autogenerated input type of createWishlist"
input createWishlistInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    isDefault: Boolean
    isPrivate: Boolean
    name: String!
}

"Autogenerated input type of deactivateCard"
input deactivateCardInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID
}

"Autogenerated input type of deactivateVoucher"
input deactivateVoucherInput {
    adjustmentId: ID
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    "Order number"
    number: String
    "Additional parameters for current action"
    params: JSON
    "Order token"
    token: String
}

"Autogenerated input type of destroyAssetRole"
input destroyAssetRoleInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "AssetRole id to remove"
    id: ID!
}

"Autogenerated input type of destroyBankAccount"
input destroyBankAccountInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    password: String!
}

"Autogenerated input type of destroyBatchVariants"
input destroyBatchVariantsInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: [ID!]!
}

"Autogenerated input type of destroyBranch"
input destroyBranchInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Branch id to remove"
    id: ID!
}

"Autogenerated input type of destroyDepartmentStore"
input destroyDepartmentStoreInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyEmployee"
input destroyEmployeeInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Employee id to remove"
    id: ID!
}

"Autogenerated input type of destroyFeedbackTopic"
input destroyFeedbackTopicInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Feedback Topic ID to remove"
    id: ID!
}

"Autogenerated input type of destroyForm"
input destroyFormInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyLineItem"
input destroyLineItemInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyListings"
input destroyListingsInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    ids: [ID!]!
    index: String
}

"Autogenerated input type of destroyMerchant"
input destroyMerchantInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Merchant id to remove"
    id: ID!
}

"Autogenerated input type of destroyOrderTemplate"
input destroyOrderTemplateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyPoll"
input destroyPollInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyProductImage"
input destroyProductImageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    variantId: ID!
}

"Autogenerated input type of destroyProductOptionValueImage"
input destroyProductOptionValueImageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    optionValueId: ID!
    productId: ID!
}

"Autogenerated input type of destroyPushTemplate"
input destroyPushTemplateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Push Template ID to remove"
    id: ID!
}

"Autogenerated input type of destroyReview"
input destroyReviewInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyReviews"
input destroyReviewsInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    ids: [ID!]!
    restore: Boolean
}

"Autogenerated input type of destroySalePrice"
input destroySalePriceInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroySavedCard"
input destroySavedCardInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    kind: String!
}

"Autogenerated input type of destroyShipper"
input destroyShipperInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyShoppyImage"
input destroyShoppyImageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyStockItem"
input destroyStockItemInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyStockLocation"
input destroyStockLocationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Stock Location ID to remove"
    id: ID!
}

"Autogenerated input type of destroyStoreListing"
input destroyStoreListingInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyUserAddress"
input destroyUserAddressInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "User Address ID"
    id: ID!
}

"Autogenerated input type of destroyUserArticle"
input destroyUserArticleInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyVariant"
input destroyVariantInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyWish"
input destroyWishInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID
    variantId: ID
    wishlistId: ID
}

"Autogenerated input type of destroyWishlist"
input destroyWishlistInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of disableCurrentUser"
input disableCurrentUserInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    password: String!
}

"Autogenerated input type of disableTotp"
input disableTotpInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "6 digit code"
    otp: String!
}

"Autogenerated input type of emptyCart"
input emptyCartInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order number"
    number: String!
    "Only clear cart for this seller"
    seller: String
    "Order token"
    token: String!
}

"Autogenerated input type of enableTotp"
input enableTotpInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Base 32 encoded key"
    key: String!
    "6 digit code"
    otp: String!
}

"Autogenerated input type of eventBuy"
input eventBuyInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Quantity"
    quantity: Int!
}

"Autogenerated input type of generateLoyaltyCardQr"
input generateLoyaltyCardQrInput {
    cardId: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of generateUserTokenQr"
input generateUserTokenQrInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of generateVariants"
input generateVariantsInput {
    barcode: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    costPrice: Float
    depth: Float
    fragile: Boolean
    height: Float
    hsCode: String
    id: ID!
    netWeight: Float
    nonReturnable: Boolean
    options: JSON
    price: Float
    weight: Float
    width: Float
}

"Autogenerated input type of golomtOTP"
input golomtOTPInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    otp: String
    scope: String!
    state: String!
}

"Autogenerated input type of halloweenPromotion"
input halloweenPromotionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of imageSearch"
input imageSearchInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    image: Upload!
}

"Autogenerated input type of importShoppyImages"
input importShoppyImagesInput {
    attachments: [Upload!]!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    vendorId: ID
    websiteId: ID
}

"Autogenerated input type of inviteEmployee"
input inviteEmployeeInput {
    "Asset information"
    assets: JSON
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "E-Mail"
    email: String
    "First name"
    firstName: String!
    "Last name"
    lastName: String
    "Mobile: required if email blank"
    mobile: String
    "Employee role"
    role: EmployeeRole!
    "Business/Vendor id to add"
    vendorId: ID!
}

"Autogenerated input type of inviteMerchant"
input inviteMerchantInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    vendorId: ID!
    websiteId: ID!
}

"Autogenerated input type of joinBusiness"
input joinBusinessInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    storeLocationId: ID
    vendorId: ID
}

"Autogenerated input type of leaseAcceptTerm"
input leaseAcceptTermInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order number"
    number: String
}

"Autogenerated input type of leaseCancel"
input leaseCancelInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order number"
    number: String
}

"Autogenerated input type of leaseChangeName"
input leaseChangeNameInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    firstName: String
    lastName: String
    nameInvalid: String
    "Order number"
    number: String
}

"Autogenerated input type of leaseCompleteFix"
input leaseCompleteFixInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order number"
    number: String
}

"Autogenerated input type of leaseComplete"
input leaseCompleteInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Lease amount"
    leaseAmount: Float
    "Duration of lease"
    months: Int
    "Order number"
    number: String
    "Repayment day of lease"
    repaymentDay: Int
}

"Autogenerated input type of leaseDeclineTerm"
input leaseDeclineTermInput {
    "Account number"
    accountNumber: String
    "Bank name"
    bankName: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order number"
    number: String
}

"Autogenerated input type of leaseMakeNormal"
input leaseMakeNormalInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order number"
    number: String
}

"Autogenerated input type of leaseUpdateAddress"
input leaseUpdateAddressInput {
    "Billing Address"
    address: AddressInput!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of leaseUpdateEducation"
input leaseUpdateEducationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "User education status"
    education: EducationInput!
}

"Autogenerated input type of leaseUpdateEmergency"
input leaseUpdateEmergencyInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "User emergency contacts"
    emergencyContacts: [EmergencyContactInput!]!
}

"Autogenerated input type of leaseUpdateEmployment"
input leaseUpdateEmploymentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "User employment information"
    employment: EmploymentInput!
}

"Autogenerated input type of leaseUpdateFinance"
input leaseUpdateFinanceInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "User finance status"
    finance: FinanceInput!
    "Loan contracts"
    loanContracts: LoanContractInput
}

"Autogenerated input type of leaseUploadPassport"
input leaseUploadPassportInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    passport: Upload
    passportBack: Upload
    selfie: Upload
}

"Autogenerated input type of leaveChatRoom"
input leaveChatRoomInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of linkDevice"
input linkDeviceInput {
    adId: String
    amountSpent: Float
    badgeCount: Float
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    country: String
    deviceModel: String
    deviceOs: String
    deviceType: Int
    gameVersion: String
    identifier: String
    lang: String
    language: String
    playerId: String!
    sessionCount: Int
    subscribed: Boolean!
    tags: String
    timezone: Int
    webAuth: String
    webP256: String
}

"Autogenerated input type of mcsCheckRegister"
input mcsCheckRegisterInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Register number to check"
    registerNum: String!
}

"Autogenerated input type of mcsRegister"
input mcsRegisterInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    mobile: String!
    password: String!
    token: String!
}

"Autogenerated input type of mcsResetPassword"
input mcsResetPasswordInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    mobile: String!
    "Register number to check"
    registerNum: String!
}

"Autogenerated input type of mcsSignup"
input mcsSignupInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    mobile: String!
    "Register number to check"
    registerNum: String!
}

"Autogenerated input type of mcsVerify"
input mcsVerifyInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    mobile: String!
    token: String!
}

"Autogenerated input type of orderPay"
input orderPayInput {
    "Payment method to perform"
    action: PaymentMethodKind!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order "
    number: String!
    "Extra parameters payment method"
    params: JSON
}

"Autogenerated input type of passCoupon"
input passCouponInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Receiver email"
    email: String!
    "Coupon id"
    id: ID!
}

"Autogenerated input type of passETicket"
input passETicketInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Receiver email"
    email: String!
    "e-ticket id"
    id: ID!
}

"Autogenerated input type of payCargoPrice"
input payCargoPriceInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    number: String!
}

"Autogenerated input type of paymentAction"
input paymentActionInput {
    "Order action to perform"
    action: PaymentMethodKind!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order "
    number: String!
    "Extra parameters for current action"
    params: JSON
}

"Autogenerated input type of performId1"
input performId1Input {
    "Billing Address"
    address: AddressInput
    birthday: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    eduDegree: String
    familyName: String
    firstName: String
    gender: String
    green: Int
    incomeConfirm: Int
    lastName: String
    maritalStatus: String
    nationality: String
    ndCode: String
    "Order number"
    number: String
    registerNum: String
    total: Int
}

"Autogenerated input type of performLineItemAction"
input performLineItemActionInput {
    "LineItem action to perform"
    action: LineItemAction!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "LineItem ID"
    id: ID!
    "Additional params"
    params: JSON
    "Shipment id required for shipping or returning"
    shipmentId: ID
}

"Autogenerated input type of performOrderAction"
input performOrderActionInput {
    "Order action to perform"
    action: OrderAction!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order ID"
    id: ID!
    "Extra parameters for current action"
    params: JSON
}

"Autogenerated input type of quickBuy"
input quickBuyInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Example: subscription "
    flag: String!
    "Product sku"
    sku: String!
}

"Autogenerated input type of readAllNotification"
input readAllNotificationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of readNotification"
input readNotificationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Notification ID to mark as read"
    id: ID!
}

"Autogenerated input type of readyShipment"
input readyShipmentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    cost: Float
    deliveryPhoto: Upload
    deliveryPhoto1: Upload
    deliveryPhoto1Url: String
    deliveryPhotoUrl: String
    "Shipment ID"
    id: ID!
}

"Autogenerated input type of receivePreorderShipment"
input receivePreorderShipmentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Shipment ID"
    id: ID!
}

"Autogenerated input type of refreshOrderTrackings"
input refreshOrderTrackingsInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order ID"
    id: ID!
}

"Autogenerated input type of registerQPayCard"
input registerQPayCardInput {
    callbackUrl: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    firstName: String
    lastName: String
    mobile: String
    registerNum: String
}

"Autogenerated input type of removeCampaignList"
input removeCampaignListInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "CampaignList ID"
    ids: [ID!]!
}

"Autogenerated input type of removeChatMessage"
input removeChatMessageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of removePrescription"
input removePrescriptionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of removePrescriptionItem"
input removePrescriptionItemInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of removeViewTrack"
input removeViewTrackInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID
}

"Autogenerated input type of requestCardOtp"
input requestCardOtpInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of requestGolomtVCC"
input requestGolomtVCCInput {
    callback: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of requestListingOTP"
input requestListingOTPInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    phoneNumber: String!
}

"Autogenerated input type of requestMerchant"
input requestMerchantInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    domain: String!
    vendorId: ID!
}

"Autogenerated input type of requestPaymentReturn"
input requestPaymentReturnInput {
    accountBank: String
    accountName: String
    accountNumber: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    orderId: ID!
    "Payment return reason id 1: Бараа дууссан"
    reasonId: ID!
}

"Autogenerated input type of resendGiftCard"
input resendGiftCardInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String!
    id: ID!
}

"Autogenerated input type of resendIntendSms"
input resendIntendSmsInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    paymentId: ID!
}

"Autogenerated input type of resendShipmentTracking"
input resendShipmentTrackingInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order ID"
    id: ID!
}

"Autogenerated input type of reviewDriver"
input reviewDriverInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    comment: String
    orderId: ID!
    rating: Float!
}

"Autogenerated input type of searchAddress"
input searchAddressInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "parent id"
    filterId: ID
    "for details"
    id: ID
    lat: String
    lon: String
    page: Int
    "Search value of address"
    q: String
    "au100, au200, au300, ...au800"
    type: String
}

"Autogenerated input type of seenChatMessage"
input seenChatMessageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    roomId: ID!
}

"Autogenerated input type of selectPrescriptionItem"
input selectPrescriptionItemInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Prescription Item ID"
    id: ID!
    "Variant Quantity"
    quantity: Int!
    "Prescription Variant ID"
    variantId: ID!
}

"Autogenerated input type of sendChangeLoyaltyCardPasswordOtp"
input sendChangeLoyaltyCardPasswordOtpInput {
    cardId: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of sendChatMessage"
input sendChatMessageInput {
    attachment: Upload
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    content: String
    roomId: ID!
}

"Autogenerated input type of sendCoupon"
input sendCouponInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Greetings"
    dateToSend: ISO8601Date
    "Greetings"
    greeting: String
    "Coupon id"
    id: ID!
    "Receiver email"
    receiverEmail: String
    "Receiver name"
    receiverName: String
    "Receiver phone"
    receiverPhone: String
    "Sender name"
    sender: String
}

"Autogenerated input type of sendCreateLoyaltyCardOtp"
input sendCreateLoyaltyCardOtpInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of sendInvoice"
input sendInvoiceInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String!
    id: ID!
}

"Autogenerated input type of sendInvoiceNotification"
input sendInvoiceNotificationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order ID"
    id: ID!
}

"Autogenerated input type of sendJobApplicationEmail"
input sendJobApplicationEmailInput {
    address: String
    award: JSON
    birthday: ISO8601DateTime
    birthplace: String
    childrenCount: Int
    clanName: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    drivingYears: Int
    email: String
    facebook: String
    familyMemberCount: Int
    familyMembers: JSON
    firstEmploymentDate: ISO8601DateTime
    firstName: String
    gender: String
    hasPoliticalInsider: Boolean
    hasServedMilitary: Boolean
    hobby: String
    image: String
    intestedPosition: String
    isMarried: Boolean
    language: JSON
    lastName: String
    married: String
    medicalCondition: String
    otherInterest: String
    primaryPhoneNumber: String
    priorEducation: JSON
    priorJobExperience: JSON
    registerAddress: String
    registerNum: String
    salary: String
    secondaryPhoneNumber: String
    "Source of information about the position opening, advertisement, etc."
    sourceOfInformation: String
    sportExperience: JSON
    strength: String
    training: JSON
    vehicle: String
    weakness: String
}

"Autogenerated input type of sendNotification"
input sendNotificationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    invoiceId: String!
    mobile: String!
}

"Autogenerated input type of sendUserTokenQr"
input sendUserTokenQrInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String!
    number: String!
}

"Autogenerated input type of setAvailability"
input setAvailabilityInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    isAvailable: Boolean!
}

"Autogenerated input type of setGolomtCardPassword"
input setGolomtCardPasswordInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    golomtCardId: ID!
    password: String
}

"Autogenerated input type of shipShipment"
input shipShipmentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Force ship! to all shipments of the orders"
    force: Boolean
    id: ID!
    pinCode: String
    "Shipper ID"
    shipperId: ID
    withoutSms: Boolean
}

"Autogenerated input type of shoppyBox"
input shoppyBoxInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Score"
    score: Int!
}

"Autogenerated input type of shoppyhubPromotion"
input shoppyhubPromotionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of submitAnswer"
input submitAnswerInput {
    answerIds: [ID!]!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of submitForm"
input submitFormInput {
    answers: [FormAnswerInput!]!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

input swapActionInput {
    action: SwapActionEnum!
    "Prioritize original variant when the stock quantity is not sufficient"
    prioritizeMainVariant: Boolean
    "Inventory to be swapped with in case there is no stock for the original variant"
    variants: [SwapItemInput!]
}

"Autogenerated input type of swapOrderDriver"
input swapOrderDriverInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String!
}

"Autogenerated input type of syncListings"
input syncListingsInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    ids: [ID!]!
}

"Autogenerated input type of syncListingsSeo"
input syncListingsSeoInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    ids: [ID!]!
}

"Autogenerated input type of syncReport"
input syncReportInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    ids: [ID!]!
    type: String
}

"Autogenerated input type of toggleFollow"
input toggleFollowInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Object ID of target"
    targetId: ID!
    "Object type of target. vendor, user, website ..."
    targetType: String!
}

"Autogenerated input type of toggleWish"
input toggleWishInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    variantId: ID!
    wishlistId: ID
}

"Autogenerated input type of topUpGiftCard"
input topUpGiftCardInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String!
}

"Autogenerated input type of transferShipment"
input transferShipmentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    quantity: Int!
    targetId: ID!
    targetType: ShipmentTransfer!
    variantId: ID!
}

"Autogenerated input type of unlockWalletPin"
input unlockWalletPinInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    otp: String
    pinCode: String
    walletId: ID!
}

"Autogenerated input type of updateAddress"
input updateAddressInput {
    address1: String
    address2: String
    alias: String
    alternativePhone: String
    apartment: String
    cdq: [ID!]
    city: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    company: String
    countryId: ID
    districtId: ID
    entrance: String
    firstname: String
    floor: String
    gender: String
    geoPoint: String
    house: String
    id: ID!
    intercom: String
    isBillAddress: Boolean
    isCompany: Boolean
    lastname: String
    latitude: String
    longitude: String
    mnQuarterId: ID
    nationality: String
    owningType: String
    passportNumber: String
    phone: String
    pinFl: String
    quarterId: ID
    stateId: ID
    stateName: String
    what3words: String
    year: String
    zipcode: String
}

"Autogenerated input type of updateAfterPay"
input updateAfterPayInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "MerchantId to request"
    id: ID!
    status: AfterPay
    types: [String!]
}

"Autogenerated input type of updateAssetRoleBatch"
input updateAssetRoleBatchInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    permissions: [AssetTargetRoleInput!]!
}

"Autogenerated input type of updateAssetRole"
input updateAssetRoleInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Asset Role id to update"
    id: ID!
    "roles"
    roles: [String!]
}

"Autogenerated input type of updateAvatar"
input updateAvatarInput {
    "Avatar image to upload"
    avatar: Upload
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of updateBankAccount"
input updateBankAccountInput {
    accountNo: String!
    additionalDetails: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    name: String!
    password: String!
}

"Autogenerated input type of updateBranch"
input updateBranchInput {
    addressId: ID
    businessTypeId: ID
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    email: String
    id: ID!
    name: String
    phone: String
    phone1: String
    supplySegmentIds: [ID!]
}

"Autogenerated input type of updateBtobOrderTemplate"
input updateBtobOrderTemplateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    name: String
    status: String
}

"Autogenerated input type of updateCampaign"
input updateCampaignInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    cover: Upload
    description: String
    endsAt: ISO8601DateTime!
    fulfillDate: ISO8601Date!
    id: ID!
    location: String
    maxItemsCount: Int!
    minItemsCount: Int!
    startsAt: ISO8601DateTime!
    status: String
    title: String!
}

"Autogenerated input type of updateCampaignList"
input updateCampaignListInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "CampaignList ID"
    id: ID!
    position: Int
    price: Float!
    quantity: Int
    "Variant ID"
    variantId: ID!
}

"Autogenerated input type of updateCard"
input updateCardInput {
    cardHolder: String
    cardNumber: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "MMYY, 0124"
    expiresAt: String
    id: ID
}

"Autogenerated input type of updateChannel"
input updateChannelInput {
    "Background image"
    background: Upload
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    "Channel ID"
    id: ID!
}

"Autogenerated input type of updateCheckoutOrder"
input updateCheckoutOrderInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    clientsStoreId: ID
    forceComplete: Boolean
    "Order number"
    number: String!
    "Parameters for current action: bill_address, email, extra_data, type(person), when_to_ship etc"
    params: JSON!
    shippingAddress: AddressInput
    "AddressId to be used"
    shippingAddressId: ID
    shippingMethodId: ID
    "Order token can be nil if user already logged in"
    token: String
    whenToShip: ISO8601DateTime
}

"Autogenerated input type of updateCompleteOrder"
input updateCompleteOrderInput {
    billAddress: AddressInput!
    channel: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    clientVendorId: ID
    clientsStoreId: ID
    couponCode: String
    ebarimt: Boolean
    email: String
    extraData: JSON
    flag: String
    isConfirmation: Boolean
    lineItems: [LineItemInput!]
    orderId: ID!
    parcelDelivery: Boolean
    paymentState: Boolean
    payments: [JSON!]
    shipAddress: AddressInput
    useBilling: Boolean
    userId: ID!
    websiteId: ID!
    whenToShip: ISO8601DateTime
}

"Autogenerated input type of updateEmployee"
input updateEmployeeInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "E-Mail"
    email: String
    "First name"
    firstName: String
    "Employee id to update"
    id: ID!
    "Last name"
    lastName: String
    "Mobile"
    mobile: String
    msCode: String
    "Employee role"
    role: EmployeeRole
    "Reseller bonus"
    salesManagerBonus: Float
    "Is vendor"
    salesManagerIsVendor: Boolean
    "Taxpayer number"
    salesManagerTaxpayerNumber: String
}

"Autogenerated input type of updateFeedback"
input updateFeedbackInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    status: String!
}

"Autogenerated input type of updateFeedbackTopic"
input updateFeedbackTopicInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    orderRequired: Boolean
    parentId: ID
    position: Int
    positive: Boolean
    title: String
}

"Autogenerated input type of updateFormEntry"
input updateFormEntryInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    note: String
    status: String
}

"Autogenerated input type of updateForm"
input updateFormInput {
    active: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    cover: Upload
    data: String
    description: String
    fields: [FormFieldInput!]
    id: ID!
    permalink: String
    preferences: JSON
    title: String
}

"Autogenerated input type of updateItem"
input updateItemInput {
    "Attachments"
    attachments: [Upload!]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Additional data"
    data: JSON
    "Line item id"
    id: ID!
    "Swap options"
    onUnavailable: swapActionInput
    "Additional options: gift_message, purchaser_name, recipient_email, recipient_name, send_email_at"
    options: JSON
    "Item quantity"
    quantity: Int
    "Order token"
    token: String
}

"Autogenerated input type of updateKycGolomt"
input updateKycGolomtInput {
    address1: String
    address2: String
    address3: String
    apartment: String
    "албан тушаал"
    appointment: String
    branchId: String
    city: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    country: String
    "Картын зээлээр авах боломж"
    creditLimit: Int
    customerCheck: Boolean
    "Мэргэжлийн зэрэг"
    degree: String
    doorNo: String
    "Картын дэвсгэр нэр"
    embossName: String
    "Сургуульд орсон огноо."
    enrollmentDate: String
    entry: String
    "Гэрлэлтийн төлөв"
    maritalStatus: String
    "төгссөн сургууль."
    schoolName: String
    "секторын код байна"
    sector: String
    "Ажилдаа орсон огноо"
    startDate: String
    state: String
    streetName: String
    subDistrict: String
    "дэд секторын код байна"
    subSector: String
    town: String
    "Хөдөлмөр эрхэлсэн нийт жил"
    yearsWork: Int
}

"Autogenerated input type of updateKyc"
input updateKycInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID
    ndCode: String
    passport: Upload
    passportBack: Upload
    selfie: Upload
}

"Autogenerated input type of updateListingBatch"
input updateListingBatchInput {
    approved: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    extendActivation: Boolean
    fulfillDuration: Int
    hideOnSearch: Boolean
    ids: [ID!]!
    maxQty: Int
    minQty: Int
    published: Boolean
    seoDescription: String
    seoKeywords: String
    seoTitle: String
    shippingCategoryId: ID
    slug: String
    taxCategoryId: ID
    taxonIds: [ID!]
}

"Autogenerated input type of updateListingES"
input updateListingESInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    param: JSON!
}

"Autogenerated input type of updateListing"
input updateListingInput {
    approved: Boolean
    badgeIds: [ID!]
    bonus: Float
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    fulfillDuration: Int
    hideOnSearch: Boolean
    id: ID!
    maxQty: Int
    minQty: Int
    product: ProductInput
    property: JSON
    published: Boolean
    seoDescription: String
    seoKeywords: String
    seoTitle: String
    shippingCategoryId: ID
    slug: String
    stepQty: Int
    stockLocationIds: [ID!]
    taxCategoryId: ID
    taxonIds: [ID!]
}

"Autogenerated input type of updateListingOptions"
input updateListingOptionsInput {
    canBuy: Boolean!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    donation: String
    email: String
    id: ID!
    otp: String
    phoneNumber: String
}

"Autogenerated input type of updateLogin"
input updateLoginInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "user id"
    id: ID
    "email or mobile"
    login: String!
    "is overwrite"
    overwrite: Boolean
}

"Autogenerated input type of updateMassChatMessage"
input updateMassChatMessageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    content: String!
    id: ID!
    roomIds: [ID!]
    sendAt: ISO8601DateTime
}

"Autogenerated input type of updateMerchant"
input updateMerchantInput {
    "Address field"
    address: String
    "Product name"
    alias: String
    allowCampaign: Boolean
    autoApprove: Boolean
    "Background image"
    background: Upload
    banks: [BankInput!]
    "Address field"
    cartAmount: Float
    categoryId: ID
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    "Ebarimt type"
    ebarimtType: Ebarimt
    "E-Mail"
    email: String
    "facebook url"
    facebook: String
    featuredFrom: ISO8601DateTime
    featuredTo: ISO8601DateTime
    fulfillmentDays: String
    "Merchant id to update"
    id: ID!
    isActive: String
    localId: String
    organizationId: String
    "Phone"
    phone: String
    preferredAllowSelfBuy: Boolean
    preferredDeliveryType: String
    preferredMaxCartAmount: Float
    preferredMinStock: Int
    preferredShippingCategoryId: ID
    preferredVatReceiverType: String
    preferredVatRegister: String
    receiveOrderNotifications: Boolean
    "Website url"
    web: String
}

"Autogenerated input type of updateOrder"
input updateOrderInput {
    billAddress: AddressInput
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    driverId: ID
    driverShippingAt: ISO8601DateTime
    driverStatus: String
    driverTakenAt: ISO8601DateTime
    email: String
    extraData: JSON
    flag: String
    id: ID!
    leaseLeft: Float
    preferences: JSON
    shipAddress: AddressInput
    whenToShip: ISO8601DateTime
}

"Autogenerated input type of updateOrderTemplate"
input updateOrderTemplateInput {
    "Billing Address"
    billAddress: AddressInput
    branchId: ID
    businessId: ID
    businessTypeIds: [ID!]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "1,3,5,7 or 2. Monday = 1, Sunday = 7"
    dayOfWeek: String
    extraData: JSON
    id: ID!
    isDefault: Boolean
    items: [OrderTemplateItemInput!]
    name: String
    "Start date"
    nextDate: ISO8601DateTime!
    "singular, daily, weekly"
    rule: String
    "Billing Address"
    shipAddress: AddressInput
    "Take Location"
    storeLocationId: ID
    "08:00, 15:00, 21:00, 20:30 ..."
    time: String
    vendorId: ID
    websiteId: ID
    whenToShip: ISO8601DateTime
}

"Autogenerated input type of updatePoll"
input updatePollInput {
    active: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    expireAt: ISO8601DateTime
    id: ID!
    image: Upload
    question: String
    questions: [PollQuestionInput!]
    startAt: ISO8601DateTime
}

"Autogenerated input type of updatePositionOptionValueImage"
input updatePositionOptionValueImageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    optionValueId: ID!
    positions: [ID!]!
    productId: ID!
}

"Autogenerated input type of updatePositionSalePrices"
input updatePositionSalePricesInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    positions: [ID!]!
    variantId: ID!
}

"Autogenerated input type of updatePositionVariantImage"
input updatePositionVariantImageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    positions: [ID!]!
    variantId: ID!
}

"Autogenerated input type of updatePrescription"
input updatePrescriptionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    diagnosis: String
    doctorHospital: String
    doctorName: String
    id: ID!
    patientName: String
    prescriptionDate: ISO8601Date
}

"Autogenerated input type of updatePrescriptionItem"
input updatePrescriptionItemInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    drugName: String
    drugNumber: String
    frequency: Int
    id: ID!
    quantity: Int
    variantIds: [ID!]
}

"Autogenerated input type of updateProduct"
input updateProductInput {
    "Product available on date / sell start date"
    availableOn: ISO8601DateTime
    "Product available until date / sell stop date"
    availableUntil: ISO8601DateTime
    barcode: String
    "Order cancel duration by minutes"
    cancelDuration: Int
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Condition"
    condition: String
    currency: String
    "dynamic components as json"
    data: JSON
    description: String
    fileImages: [Upload!]
    fragile: Boolean
    id: ID!
    imageLinks: [String!]
    "Image ids to keep"
    images: [ID!]
    info: JSON
    "Keyword ID"
    keywordId: ID
    labelCode: String
    listingOptions: JSON
    masterImageId: ID
    merchantSku: String
    "Meta description: SEO recommended to 160 characters"
    metaDescription: String
    "Meta keywords: SEO recommended to 10% of total words on page"
    metaKeywords: String
    "Meta title: SEO, recommended 50 to 60 characters"
    metaTitle: String
    name: String
    nonReturnable: Boolean
    packageCode: String
    "Preferred eticket activation method"
    preferredEticketActivationMethod: String
    "Preferred eticket require activation"
    preferredEticketRequireActivation: Boolean
    "Product price to change: only master price will change"
    price: Float
    "Product Type"
    productCat: ProductCat
    property: JSON
    "Shipping Category ID"
    shippingCategoryId: ID
    "Sizing guide ID"
    sizingGuideId: ID
    "Product SKU to change: only master sku will change"
    sku: String
    "slug: url suffix"
    slug: String
    "master variant stock"
    stock: Int
    "Brand ID"
    storeId: ID
    taxCode: String
    "Taxon ids for listing"
    taxonIds: [ID!]
    "Title: common name"
    title: String
    "Product translations"
    translations: [TranslationInput!]
    "Variants to update"
    variants: [VariantInput!]
    "Vendor attributes to be updated"
    vendor: JSON
    "Vendor ID"
    vendorId: ID
    "youtube link"
    youtube: String
}

"Autogenerated input type of updatePushTemplate"
input updatePushTemplateInput {
    appId: ID
    appIds: [ID!]
    body: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    deeplink: String
    "id to update"
    id: ID!
    "Template Title code"
    name: PushTemplateName!
    "Template Title code"
    title: String!
    url: String
}

"Autogenerated input type of updateReportReason"
input updateReportReasonInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    id: ID!
    name: String!
    position: Int!
    status: String
}

"Autogenerated input type of updateSaleListing"
input updateSaleListingInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    items: [ListingSaleInput!]!
}

"Autogenerated input type of updateSalePrice"
input updateSalePriceInput {
    amount: Float
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    currency: String
    eventLabel: Boolean
    expireAt: ISO8601DateTime
    forceOthers: Boolean
    id: ID!
    isEvent: Boolean
    qty: Int
    segmentId: ID
    startAt: ISO8601DateTime
    websiteId: ID
}

"Autogenerated input type of updateShipmentTracking"
input updateShipmentTrackingInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    deliveryCompany: String
    itemId: ID
    "Order number"
    number: String!
    pending: Boolean
    status: String
    statusDate: ISO8601DateTime
    trackingNumber: String
    "Provider type"
    type: String!
}

"Autogenerated input type of updateShipper"
input updateShipperInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    email: String
    id: ID!
    logo: Upload
    name: String
    phoneNumber: String
    status: String
    taxer: Boolean
    vendorId: ID
}

"Autogenerated input type of updateStockItem"
input updateStockItemInput {
    backorderable: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    countOnHand: Int
    "id to update"
    id: ID!
}

"Autogenerated input type of updateStockLocation"
input updateStockLocationInput {
    active: Boolean
    address1: String
    adminName: String
    backorderableDefault: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    countryId: ID
    default: Boolean
    "id to update"
    id: ID!
    name: String
    phone: String
    propagateAllVariants: Boolean
    stateId: ID
    storeLocationId: ID
    timeSheets: JSON
}

"Autogenerated input type of updateUserAddress"
input updateUserAddressInput {
    address: AddressInput!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "User Address ID"
    id: ID!
}

"Autogenerated input type of updateUserClearance"
input updateUserClearanceInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID
    isValidUserClearance: Boolean
    validatedBirthday: String
    validatedFirstName: String
    validatedLastName: String
    validatedMiddleName: String
    validatedPassportNumber: String
    validatedPinFl: String
}

"Autogenerated input type of updateUserProfile"
input updateUserProfileInput {
    appsflyerAppId: String
    appsflyerId: String
    billAddress: AddressInput
    birthday: String
    clickGobozorMiniAppAcceptance: Boolean
    clickMiniAppAcceptance: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    eduDegree: String
    education: EducationInput
    emergencyContacts: [EmergencyContactInput!]
    employment: EmploymentInput
    "Ургийн овог"
    familyName: String
    finance: FinanceInput
    firstName: String
    gender: Gender
    "Хэрэглэгчийн ID: өөрийн бүртгэлийг шинэчилж байх үед шаардлагагүй / Зөвхөн ADMIN user_id тайгаар update дуудаж чадна"
    id: ID
    "Лизинг эсэх"
    isLease: Boolean
    isValidUserClearance: Boolean
    lastName: String
    maritalStatus: String
    mobile: String
    "Улсын кодыг ISO 3166-1 alpha2 стандартаар явуулна жнь: `MN`"
    nationality: String
    "Захиалгын дугаар"
    number: String
    "New password"
    password: String
    registerNum: String
    storeLocationIds: [ID!]
    "Enable/Disable mass notifications"
    subscribed: Boolean
    unconfirmedEmail: String
    unconfirmedMobile: String
    validatedBirthday: String
    validatedFirstName: String
    validatedLastName: String
    validatedMiddleName: String
    validatedPassportNumber: String
    validatedPinFl: String
    xpartnersClickId: String
    xpartnersExpireAt: ISO8601DateTime
}

"Autogenerated input type of updateVariant"
input updateVariantInput {
    barcode: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    costCurrency: String
    costPrice: Float
    depth: Float
    fragile: Boolean
    height: Float
    hsCode: String
    id: ID!
    labelCode: String
    merchantSku: String
    netWeight: Float
    nonReturnable: Boolean
    options: JSON
    packageCode: String
    price: Float
    priceCny: Float
    priceJpy: Float
    priceKrw: Float
    priceMnt: Float
    priceRub: Float
    priceUsd: Float
    priceUzs: Float
    sku: String
    stockLocked: Boolean
    taxCode: String
    weight: Float
    width: Float
}

"Autogenerated input type of updateVendor"
input updateVendorInput {
    "Address"
    address: String
    "City district quarter ids as array: [12, 1212, 121256]"
    cdq: [ID!]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    countryId: ID
    "Vendor configs"
    data: JSON
    "Introduction"
    description: String
    districtId: ID
    "EBarimt Type"
    ebarimtType: String
    "EMail"
    email: String
    "Facebook URL"
    facebook: String
    "Hide mobile number on listings"
    hideInfo: Boolean
    "Vendor id to update"
    id: ID!
    "Instagram URL"
    instagram: String
    "Is individual ? /inverse of company/"
    isIndividual: Boolean
    latitude: String
    "Logo"
    logo: Upload
    longitude: String
    "Manager name"
    manager: String
    "name"
    name: String
    "English name"
    nameEn: String
    "Note 1: Detail"
    note1: String
    "Note 2: Location"
    note2: String
    "Note 3: Collector"
    note3: String
    "Note 4: Date"
    note4: String
    "Note 5: Contract"
    note5: String
    "Note 6: Note"
    note6: String
    "Note 7: Direction"
    note7: String
    "Note 8"
    note8: String
    "Personal Information Number"
    personalNumber: String
    "EMail"
    phone: String
    "Pos feature activated?"
    pos: Boolean
    "Business models"
    preferredBusinessModels: [String!]
    "Vendor Name validated"
    preferredNameValidated: Boolean
    "Register valid Vendor"
    preferredRegisterValidated: Boolean
    "Auto update SEO data"
    preferredSeoAutoUpdate: Boolean
    "Vendor Vat validated"
    preferredVatValidated: Boolean
    "Primary taxons"
    primaryTaxons: [ID!]
    quarterId: ID
    "register"
    register: String
    "City ID"
    stateId: ID
    "Tax Identification Number"
    taxNumber: String
    "vat"
    vat: Boolean
    "Website URL"
    website: String
}

"Autogenerated input type of updateVendorLogo"
input updateVendorLogoInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Vendor id to update"
    id: ID!
    "Logo image to upload"
    logo: Upload!
}

"Autogenerated input type of updateWishedProduct"
input updateWishedProductInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    quantity: Int
    remark: String
    variantId: ID!
}

"Autogenerated input type of updateWishlist"
input updateWishlistInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    isDefault: Boolean
    isPrivate: Boolean
    name: String!
}

"Autogenerated input type of uploadSegmentWhiteList"
input uploadSegmentWhiteListInput {
    attachment: Upload
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "email"
    options: JSON
}

"Autogenerated input type of useCoupon"
input useCouponInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of useGiftCard"
input useGiftCardInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    clientVendorId: ID
    code: String!
}

"Autogenerated input type of useLoyaltyCard"
input useLoyaltyCardInput {
    amount: Float!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    orderId: ID!
}

"Autogenerated input type of useStoreCreditByID"
input useStoreCreditByIDInput {
    amount: Float!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order id"
    id: String!
}

"Autogenerated input type of useStoreCredit"
input useStoreCreditInput {
    amount: Float
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Order number"
    number: String
    "Order token"
    token: String
}

"Autogenerated input type of useUPointCard"
input useUPointCardInput {
    amount: Float!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    orderId: ID!
}

"Autogenerated input type of useUserTokenQr"
input useUserTokenQrInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of useVoucher"
input useVoucherInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String!
    "Order number"
    number: String
    "Additional parameters for current action"
    params: JSON
    "Order token"
    token: String
}

"Autogenerated input type of validateApplePayMerchant"
input validateApplePayMerchantInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    domain: String
    merchantId: String!
    validationUrl: String!
}

"Autogenerated input type of verifyCard"
input verifyCardInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    otp: String!
}

"Autogenerated input type of verifyEMongolia"
input verifyEMongoliaInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    services: [String!]
}

"Autogenerated input type of verifyLogin"
input verifyLoginInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "email or mobile"
    login: String!
    "is overwrite"
    overwrite: Boolean
    "token for recovery"
    token: String!
}

"Autogenerated input type of verifyMnCitizenIdentity"
input verifyMnCitizenIdentityInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    file: Upload!
    type: PassportFile!
}

"Autogenerated input type of viewTrack"
input viewTrackInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    listingId: ID
    productId: ID
    slug: String
}
